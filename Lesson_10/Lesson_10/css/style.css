
/* Šinī lekcijā mēs izskatīsim jaunu tēmu: pseido elementi un pseido klases. */
/* Sākumā atceramies kā pieslēgt šriftus: */

@import url("https://fonts.googleapis.com/css?family=Poppins:regular,700&display=swap");


@font-face {
	font-family: "Gilroy";
	src:
		url("../fonts/Gilroy-Regular.woff2") format("woff2"),
		url("../fonts/Gilroy-Regular.woff") format("woff");
	font-weight: normal;
	font-style: normal;
	font-display: swap;
}

@font-face {
	font-family: "Gilroy";
	src:
		url("../fonts/Gilroy-Bold.woff2") format("woff2"),
		url("../fonts/Gilroy-Bold.woff") format("woff");
	font-weight: bold;
	font-style: normal;
	font-display: swap;
}

body {
	font-family: "Gilroy", sans-serif;
	font-size: 16px;
	font-weight: 400;
}

/* Šinī lekcijā mēs uzzināsim visu par BEM metodoloģiju. Kādēļ ir tik svarīgi to izmantot. */

/* Ikdienas darbā, ja strādājam freelance mēs varam neizmantot šo BEM metodoloģiju, bet būtībā visur tā ir obligāta prasība, strādāt pēc kādas no metodoloģijām. Populārākā ir tieši BEM metodoloģija. BEM- Bloks__Elements-Modifikators. */

/* Tā mums ir vajadzīga, lai celtu mūsu līmeni - kvalifikāciju, profesionālisma līmeni, kā speciālistam. */

/* BEM metodoloģija ir ļoti plaša, sākot no HTML dokumenta un CSS faila līdz pat datora mapju nosaukumiem. Tā skar daudzas lietas, jo tiek ielietota ļoti plaši.  */

/* BEM metodoloģija tiek izmantota, lai HTML dokumentā veidotu bloku struktūras, atkārtotu blokus, dodot tiem tādus nosaukumus (ievērojot BEM metodoloģiju), lai mēs varētu tos izmantot vairākkārt. Tādēļ mums savā darbā jāizmanto BEM metodoloģija. */

/* kas tad ir metodoloģija? Tā ir vairāku likumu, ieteikumu ievērošana, rekomendāciju ievērošana, labas prakses ieteikumi, lai gala rezultātā mēs dabūtu kaut ko labu. */

/* Vienkārši sakot - metodoloģija ir rekomendācija ievērot noteiktus ieteikumus, ievērojot to kārtību, lai piepildītos nosacījumi un mēs iegūtu vēlamo rezultātu. */

/* BEM - B. - Bloks, E. - Elements, M. - Modifikators. B.E.M. */

/* Pēc šīs lekcijas, visi mājas darbi (arī tie, kas sekos vēlāk) mums ir jau jāpilda ievērojot BEM metodoloģiju. */

/* Šī lekcija sastāvēs no teorijas un praktiskās daļas, kur mēs mācīsimies HTML dokumentā nosaukt blokus un tā elementus, modifikatorus ievērojot BEM metodoloģiju. */

/* Izskatīsim no kā tad tieši sastāv BEM metodoloģija? Bloks - patstāvīgs neatkarīgs objekts. Kapēc tas ir tik svarīgi? Tāpēc, ka šī metodoloģija palīdz mums izstrādāt lapas ļoti ātri. Piemēram, ja mums ir vairāku lapu projekts, kur bloki atkārtojas, tad, ja ievērojam metodoloģiju BEM mēs varam vienādos blokus vienkārši kopēt, ja tie mums kaut kur jau ir bijuši. */

/* Mēs jau esam pieraduši, ka hTML dokumentā bloks ir tag: <div></div>, bet tas nav tas pats, kas BEM bloks. Tādēļ mēs šos abus objektus sauksim dažādi, HTML dokumenta bloks un BEM bloks. */

/* Piemēram vairāku lapu projektā mums var atkārtoties header visās lapās jeb footer, jeb kādi HTML bloki, kur ir virsraksts, teksts, attēls. Izmantojot BEM metodoloģiju mēs varam vienādos BEM blokus vienkārši kopēt. Un uzrakstot CSS stilus, CSS parametrus vienam BEM blokam, tie tiek piemēroti visur, kur ir konkrētais BEM bloks. Tādēļ arī mūsu lapu izstrāde kļūst daudz ātrāka. Mēs vienkārši atkārtoti izmantojam jau rakstītu kodu. Tas var būt jebkas, piemēram daudzu lapu projektā saziņas forma. */

/* Ja, mēs pareizi iemācīsimies ar šo BEM metodoloģiju strādāt, tad mums kļūs ļoti viegli izstrādāt lapas, iksevišķi, ja tas būs projekts, kas sastāv no daudzām lapām. */

/* Otrs veids kā mēs varam aprakstīt BEM bloku ir: tas neietekmē lapas apkārtni - lapas saturu. Mēs varam vienkārši paņemt un ielikt to citā vietā, un mūsu lapas izstrāde nesalūzīs, jo BEM bloks ir neatkarīgs, un nekādi neiespaido citus lapas elementus. */

/* Galvenais, lai mēs varētu kopēt likt citur jau gatavus BEM blokus, mums ir pareizi tas jāizveido - jāizstrādā. */

/* Tālāk, izskatot teoriju, mēs lēnām sapratīsim kas un kā. Tagad mums ir vēl diezgan nesaprotama šī tēma, bet mēs to sapratīsim, kad strādāsim ar reāliem piemēriem. */

/* Paskatīsimies ar piemēru. Izveidojot HTML dokumentā kastīti, kāds mums būtu tai jādod klases nosaukums, lai tas būtu BEM bloks? Rakstot klases nosaukumus, mums ir jāievēro četri likumi: 
1) Pats galvenais: nosaukumam jāatbilst tam, kas ir blokā vai tā konstrukcijai, piemēram, par ko ir šis bloks: about-us, price utt. Tam jāatbild uz jautājumu: kas tas ir? ;
2) Latīņu burti, obligāti Angļu valodā;
3) Nosaukumam jābūt ar mazajiem burtiem; 
4) Ja tas sastāv no vairākiem vārdiem, atdalām tos ar zīmi: - ;
5) Nekādas hierarhijas; */

/* Pārnesam mūsu bloku no HTML dokumenta šeit. */

/* Divi vissvarīgākie metodoloģijas BEM nosacījumi:
1) Bloks - neatkarīgs objekts;
2) Neietekmē apkārt (ārējos) esošos objektus; */

/* Mēs nedrīkstam izmantot tādus CSS parametrus BEM blokam, kas izraisīs to, ka netiek ievēroti šie galvenie BEM metodoloģijas nosacījumi. Lai labāk saprastu kādus CSS parametrus mēs nedrīkstam izmantot izveidojam paragrāfus pirms un pēc mūsu bloka HTML dokumentā. */

/* Pievienojam paragrāfiem nedaudz CSS parametrus, lai mēs labāk saprastu, kur ir teksts un kur ir BEM bloks. */

p {
	background-color: #794f45;
	padding: 15px;
	color: #fff;
}

.who-we-are {
	background-color: #7a956b;
	color: #fff;
	padding: 15px;
	/* margin: 0 0 15px 0 */
}

/* Redzam, ka CSS parametri, kas ir ieslēgti neietekmē apkārt esošos objektus bet, tie, kas ir izslēgti - ietekmē apkārtējos blokus. */

/* Varētu šķist, ka CSS parametrs: margin: 15px neietekmē apkārt esošos objektus, bet tas tā tomēr nav, jo atceramies, ka CSS parametrs: margin: atgrūž citus lapas elementus no esošā, kam ir pievienots šis parametrs. */

/* Visus CSS parametrus, kas kaut kādi skar objektu ārieni, mēs nedrīkstam izmantot BEM blokam. Kādēļ tā? Tādēļ, ka mēs neievērojam vienu vienkāršu nosacījumu, ko mēs jau zinam: BEM bloks ir neatkarīgs objekts. */

/* Ja mēs kopējam BEM bloku, tas nekādi nedrīkst ietekmēt lapas apkārtni, pārējo lapas saturu. Izmēģinām to, kopējot objektus HTML dokumentā. */

/* Kas tad ir BEM neatkarīgs bloks? Tas skar ielikšanas selektorus. Piemēram mūsu BEM bloks atrodas citā kastītē, iekš cita tag: <div></div>, citā blokā. Izskatām to ar piemēru: */

/*
.item .who-we-are {
	background-color: #7a956b;
} */

/* Redzam, ka pēc šī piemēra zūd nosacījums, ka BEM bloks ir neatkarīgs objekts, jo apskatot rezultātu redzam, ka šis BEM bloks, kas atrodas iekš bloka: item ir zaļā krāsā, bet otrs BEM bloks tāds nav. Mēs redzam, ka BEM bloks kļūst atkarīgs kur tas atrodas. Šādi zūd šis nosacījums, izveidojas atkarība, kas vairs neatbilst BEM metodoloģijai. */

/* Tādēļ šādi, kā augstāk piemērā mēs nedrīkstam rīkoties, jo BEM blokam ir jābūt neatkarīgam objektam, lai mēs to varētu kopēt pārvietot, brīvi ar to rīkoties, un, lai tas neietekmētu lapas apkārtni, ārējos objektus. */

/* Lai mūsu BEM bloki būtu neatkarīgi un neietekmētu citus ārējos lapas elementus mums jāievēro nosacījums, ka tie nedrīkst atrasties iekš kāda cita bloka. Nedrīkst būt tā, kā augstāk piemērā, jo tad mūsu BEM bloks kļūst atkarīgs no augstāk esošā bloka, un zūd galvenais princips: BEM bloks ir neatkarīgs. */

/* BEM blokam ir jābūt pirmā ielikšanas līmeņa blokam. Mums no CSS jāvēršas pie tā kā pie pirmā ielikšanas līmeņa objekta. Tā kā pareizajā piemērā, kur mēs rakstām: .who-we-are {} iekavās norādot tikai tos CSS parametrus, kas nekādi neietekmē apkārt (ārēji) esošos objektus, mēs izmantojam neatkarīgus CSS parametrus BEM blokam. */

/* Bet, mēs varam vienu BEM bloku likt iekš cita BEM bloka, neskaitāmas reizes, cik vien nepieciešams. */

/* Ņemot vērā piemēru, kur mēs izdarījām tā kā nedrīkstam darīt, kad iekš viena bloka likām BEM bloku, izskatīsim variantu kā būtu pareizi. Iekš HTML dokumenta mums vis ir pareizi, bet mums tas jāizdara arī šeit izskatām to ar piemēru: */

.item {

}

.who-we-are {

}

/* Redzam, ka šajā piemērā mēs ievērojam BEM metodoloģijas nosacījumus, jo mēs ievērojam, ka BEM bloks ir neatkarīgs objekts, un neietekmē apkārt esošos objektus. */

/* Izveidojam iekš HTML dokumenta vēl dažus blokus, iekš BEM bloka: who-we-are. Vēršamies pareizi pie tiem no CSS faila, rakstot tos pirmajā līmenī. Zemāk piemērā ir pareizi uzrakstīts kā vērsties pie BEM blokiem pirmajā to līmenī. */

.item {
}

.who-we-are {
}

.item-block {
}

.item-block-2 {
}

/* Turpināsim mūsu tēmu par BEM metodoloģiju. Mēs tagad saprotam, kas ir BEM bloks. Izskatīsim, kas tad ir BEM elements? 
1) BEM elements ir atkarīgs objekts no sava BEM bloka. 
2) Tas var iespaidot apkārtni (uz ārējiem objektiem). 
3) Tas vienmēr atrodas iekš sava BEM bloka. */

/* Kā mēs veidojam BEM elementa nosaukumu? Šeit atkal tiek ievēroti vairāki nosacījumi.
1) Tā nosaukums sākās ar BEM bloka (vecāka bloka) nosaukumu, kas tiek atdalīts ar diviem apakšējiem pastrīpojumiem, ar šādu zīmi: __ ;
2) Nosaukumam jāatbilst BEM elementa saturam vai konstrukcijai. Jāatbild uz jautājumu: Kas tas ir? ;
3) Nosaukumam jābūt Angļu valodā, jāsastāv no latīņu burtiem;
4) Nosaukumam jābūt ar mazajiem burtiem;
5) Ja nosaukums sastāv no vairākiem vārdiem, atdalām tos ar zīmi: - ;
6) Nedrīgst būt nekādas hierarhijas. */

/* Pats galvenais nosacījums BEM elementa nosaukumam jāsākas ar vecāka BEM bloka nosaukumu. */

/* Izveidojam HTML dokumentā BEM bloku: who-we-are un iekš tā izveidojam galveno virsrakstu: who-we-are__title. Šādi mēs pierakstam BEM bloka nosaukumu kopā jau ar elementu. Šinī gadījumā BEM elements mums ir: __title. */

/* Par cik BEM elements ir atkarīgs no sava vecāka BEM bloka, mēs nevaram to izmantot ārpus BEM bloka. Mums tas ir jāizmanto tikai iekš konkrētā BEM bloka.  */

/* Izveidojam HTML dokumentā iekš mūsu BEM bloka vēl vienu BEM elementu: who-we-are__text, ieliekam tur kādu zivs tekstu. Pārnesam abus objektus CSS failā, lai tiem piemērotu CSS parametrus. */

.who-we-are__title {
	margin: 0 0 15px 0;
	font-size: 20px;
}

/* Kādēļ BEM elementam mēs varam izmantot CSS parametru: margin? Tādēļ, ka BEM elements nevar tikt izmantots ārpus BEM bloka. Un tādēļ iekš sava BEM bloka tas var ietekmēt visu, kas ir BEM blokā. Jo BEM bloks ir neatkarīgs objekts, bet BEM elements ir atkarīgs objekts, atkarīgs no sava vecāka, BEM bloka. */

.who-we-are__text {

}

/* Bem elements ir neatņemama BEM bloka sastāvdaļa un tas strādā iekš sava BEM bloka. */

/* Mums nav jāraksta šādi, ja izmantojam BEM metodoloģiju:
.who-we-are .who-we-are__title {
} ;, jo tas nav nepieciešams, ja mēs pareizi izmantojam BEM metodoloģiju, pareizi rakstam objektu nosaukumus. */

/* Par cik mēs izmantojam BEM metodoloģiju, lai rakstītu objektu nosaukumus, tad jebkurš, kurš atvērs mūsu kodu, ja kaut nedaudz saprot Angļu valodu, tad varēs viegli orientēties mūsu koda, saprast, kas kam atbilst, un, kas ir mūsu lapā. Šī arī ir BEM metodoloģijas viena no priekšrocībām. Ka pat cilvēks, ja viņš praktiski neko nesaprot no lapas izstrādes, tad paskatoties uz mūsu kodu, viņš aptuveni saprot, kas ir lapā - gala rezultātā. */

/* Mūsu kods kļūst viegli lasāms un viegli saprotams, ja mēs izmantojam BEM metodoloģiju. */

/* Kā arī mums pašiem jeb cilvēkam, kurš tālāk strādās ar mūsu kodu būs viegli to uzturēt, papildināt, jo vis būs viegli saprotams, kas kur ir un kas par ko atbild. */

/* Mēs varam BEM blokus likt iekš BEM elementiem. Atceramies, ka mēs varam BEM blokus likt iekš citiem BEM blokiem neskaitāmas reizes, bet tagad mēs zinām, ka mēs varam BEM blokus likt iekš BEM elementiem. */

/* Dodamies uz HTML dokumentu un izveidojam atsevišķu BEM bloku: .link, saiti, aiz paragrāfa. Bet ieliekam to iekš mūsu BEM bloka: who-we-are. Par cik tas atkal ir neatkarīgs BEM bloks, mēs to varam izvietot kur vien vēlamies, arī iekš BEM elementa. Ieliekam saiti iekš BEM elementa: who-we-are__text. */

/* Šādi rīkojoties mēs nepārkāpjam nevienu BEM metodoloģijas principu. Un, joprojām mūsu saite paliek BEM bloks. Mēs vienkārši varam to paņemt, nokopēt un ielikt piemēram - pagrabā iekš tag: <footer></footer>. */

/* Bet CSS failā, tas būs vienkārši pierakstīts šādi: .link {} iekavās dodot tam stilus, kas netraucē lapas apkārtnei - lapas ārējiem objektiem. */

.who-we-are__link {
	font-size: 20px;
	color: #ffff00;
}

/* Tālāk mazliet prakses. Izveidojam HTML dokumentā jaunu BEM bloku: contacts. */

/* Atceramies, ka, ja mums iekš BEM vecāka bloka ir vēl kāds BEM bloks un iekš tā jau ir BEM elements, mums tas jānosauc ņemot vērā pirmā vecāka BEM bloka nosaukumu, kas mūsu gadījumā būtu: about__text. Skatīt piemēru HTML dokumentā.  */

/* Vienmēr, kad veidojam BEM bloka elementu, sekojam līdzi, kas tam ir vecāks pēc pirmā augšējā līmeņa. Kā sauc pirmo augšējo BEM bloku iekš kā ir ielikts BEM elements, jo tas ir ļoti svarīgi, lai nezustu BEM metodoloģijas principi. */

/* Mums varētu ienākt prātā ievērot hierarhiju. Bet kā redzam BEM elementu nosaukumu veidošanas nosacījumā: 6: nekādas hierarhijas būt nedrīkst. */

/* BEM elementus mēs varam likt iekš citiem BEM elementiem, bet tikai savā BEM blokā. Ko tas nozīmē? Tas nozīmē, piemēram: mēs gribam iekš BEM elementa, kas atrodas BEM blokā: who-we-are ielikt saiti tag: <a>/<a>. Pareizs nosaukums, ievērojot BEM metodoloģiju būs šāds: who-we-are__link. Nekādas hierarhijas. Mums ir jāievēro visi BEM elementu nosaukumu veidošanas likumi. Atgriežamies HTML dokumentā, lai uzskatāmāk redzētu šo piemēru. */

/* Šie BEM metodoloģijas nosaukumu veidošanas principi ir jāievēro pat tad, ja mēs atrodamies BEM elementā, un iekš tā izveidojam citu BEM elementu. */

/* Ņemot vērā mūsu piemēru, mums var rasties priekšstats, ka mēs šo BEM elementu varam nosaukt arī šādi: who-we-are__text-link. Un pēc visiem BEM metodoloģijas noteikumiem, mums būs taisnība, bet šeit izpildīsies viens liegums: hierarhija, bet mums jāatceras: Nekādas hierarhijas. Un tieši tādēļ, šāds BEM elementa nosaukums ir nepareizs. */

/* BEM elementu nosaukšanas sesto punktu: nekādas hierarhijas mums ir jāievēro arī nosaucot BEM blokus. Atgriežamies un pievienojam to arī tur, jo mums var šķist, ka tā, kā piemērā HTML dokumentā, kur mums ir BEM bloks iekš BEM bloka, mēs varētu rakstīt šādi: item-who-we-are, bet tas ir nepareizi, jo mēs atkal cenšamies ievērot hierarhiju. Bet mums jāatceras nekādas hierarhijas nosaukumu veidošanā, vienalga, vai tas ir BEM bloks, vai BEM elements. */

/* Praktizējamies vēl ar BEM bloku un BEM elementu nosaukumu veidošanu, izstrādājot mazu gabaliņu no maketa: promise. Atgriežamies HTML dokumentā. */

/* Promise ir BEM bloks, kam mēs cenšamies nedod nekādus CSS parametrus. Atceramies, ka daļu CSS parametrus mēs nevaram izmantot, jo tie ietekmē apkārtni, ārējos lapas elementus. Izmantojam tikai tos CSS parametrus, kas neietekmē apkārt esošos lapas elementus, ja vien tas nav nepieciešams. */

.promise {
}

/* Tālāk mums jau seko BEM elementi, kuriem katram mēs varam dot dažādus CSS parametrus, ja tas mums ir vajadzīgs, lai panāktu vēlamo rezultātu. */

.promise__sub-title {
}
.promise__title {
}
.promise__items {
}
.promise__item {
}
.promise__icon {
}
.promise__body {
}
.promise__label {
}
.promise__text {
}

/* Ir vēl viens variants kā mēs varējām izveidot promise BEM bloku. Iekš tā izveidojot citu BEM bloku: item. Bet tad mums jāatceras, ka arī tālāk BEM elementu nosaukumiem jāsākas ar BEM bloka nosaukumu: item. Paskatamies kā tas izskatās piemērā. Atgriežamies HTML dokumentā. */

/* CSS dokumentā tas izskatīsies šādi. Šādi mēs varam darīt. Likt BEM bloku iekš BEM bloka. */

/* Item ir BEM bloks */

.item {
}

/* BEM elementi */

.item__icon {
}
.item__body {
}
.item__label {
}
.item__text {
}

/* HTML dokumentā mums ir divi piemēri, kā mēs pareizi varam veidot BEM nosaukumus blokiem un BEM elementiem. Šeit CSS dokumentā mums ir CSS selektori, gan no viena piemēra, gan no otra piemēra, kas ir HTML dokumentā. */

/* Kad saņemam maketu, kas mums ir jāizstrādā mēs uz to jau skatamies ņemot vērā BEM metodoloģiju. Mēs to analizējam, domājot, kur un kas mums būs, kādus nosaukumus dosim vienam vai otram elementam. Mēs skatamies uz maketu un uzreiz domājam, kas būs BEM bloks, kas būs BEM elements. */

/* BEM blokam mēs nedrīkstam arī izmantot CSS parametru: margin: 0 auto. Vēlāk mēs uzzināsim kāpēc. */

/* Sākumā, kad centīsimies savā lapu izstrādē ievērot BEM metodoloģiju mūsu darbs ies ļoti lēni uz priekšu. Mēs lapas, uzdevumus pildīsim ļoti lēni. BEt tad, kad mēs iemācīsimies to pareizi darīt, tad mēs izstrādāsim lapas zibenīgā ātrumā, jo mēs jau zināsim no galvas kur un kas mums jāraksta un kur un kas mums jāliek. */

/* Atceramies, ka mēs izstrādājam lapas no ārienes uz iekšu, no sākuma uz leju, tā kā mums iet HTML un CSS kods. Un līdz ar to mums ir ļoti viegli saprotams kur ir BEM bloks un kur ir BEM elementi. */

/* Paskatoties uz maketu no augšas uz leju, uz katru bloku, no sākuma uz iekšu mums ir jābūt skaidrs kas mums būs BEM bloks un, kas mums būs BEM elementi. */

/* Ja mēs kādu BEM elementu gribam lietot vēl kādā lapas vietā, tad tas mums jau sākotnēji ir jāizstrādā kā BEM bloks. */

/* BEM metodoloģijā ir vēl: Modifikators. Kas tas ir? BEM metodoloģijas modifikators ļauj veikt izmaiņas BEM blokā jeb BEM elementā. Rakstot BEM modifikatoram nosaukumu, mums ir jāievēro atkal noteikumi. Un tie ir: 
1) Tas tiek pievienots kā vēl viens klases nosaukums priekš BEM bloka jeb BEM elementa, kas sākas ar pilnu BEM bloka jeb BEM elementa nosaukumu un tiek atdalīts ar zīmi: _ (ar vienu pastrīpojuma zīmi). Nosaukumam jaatbilst pievienotajai kādai modifikācijai tas tiek izmantots un tam jāatbild uz jautājumu: Kāds? Ko tieši mēs modificējam? ;
3) Nosaukumam jābūt Angļu valodā, jāsastāv no latīņu burtiem;
4) Nosaukumam jābūt ar mazajiem burtiem;
5) Ja nosaukums sastāv no vairākiem vārdiem, atdalām tos ar zīmi: - ;
6) Nedrīgst būt nekādas hierarhijas. */

/* Izskatīsim jauno apgūstamo tēmu BEM modifikators ar praktisku piemēru. Atgriežamies HTML dokumentā pie BEM bloka: who-we-are. */

/* Izmantojam mūsu piemēru ar BEM bloku: who-we-are rakstot tam otru klases nosaukumu: who-we-are_purple. Šādi tas atbilst visiem BEM nosaukuma likumiem un tas atbild uz jautājumu: kāds? Ko tieši mēs modificējam? Kā šinī piemērā pareizi ir uzrakstīts, un šeit iekš CSS dokumenta mēs mainām tā krāsu. Izskatām to ar piemēru: */

/* Modificēts BEM bloks */

.who-we-are_purple {
	background-color: #77608d;
}

/* Mēs redzam, ka mūsu BEM bloks: who-we-are_purple ir violetā krāsā. Atceramies, ka mums ir jāraksta pilns BEM bloka jeb BEM elementa nosaukums un tikai tad BEM modifikators. */

/* Parasti BEM bloka jeb BEM elementa Modifikators ir paredzēts nelielām izmaiņām, tikai nedaudz, izmantojot CSS parametrus krāsai utt. Tas neparedz lielas izmaiņas. */

/* Ja mēs paredzam, ka būs lielas izmaiņas, tad ir ieteicams veidot jaunu BEM bloku. */

/* Paskatīsimies kā BEM modifikators darbojas ar BEM elementiem. Atgriežamies HTML dokumentā un paskatamies ar piemēru. Pievienojam pareizu klases nosaukumu, ar BEM bloka nosaukumu, ar BEM elementa nosaukumu, un ar Modifikatora: _margin nosaukumu, jo dotajā gadījumā mums ir jāveic nelielas izmaiņas, kas skar ārējo atstarpi. Mēs iekš HTML dokumenta pat varam likt zīmi: - un norādīt skaitli. Darbojamies ar piemēru šeit. */

.who-we-are__title_margin-font {
	font-size: 24px;
	margin: 0 0 30px 0;
}

/* Mēs redzam, ka tur, kur ir šāds BEM modifikators mums tiešām ir ārējā apakšējā atstarpe 30px un mēs izmainām šrifta lielumu, konkrēti šim virsrakstam, kam ir šāds BEM modifikators. */

/* Šādi strādājot mums, arī, ja mēs pēc gada atvērsim šo projektu, mums būs skaidrs, kas par ko atbild un ko tieši mēs esam domājuši veidojot kādu BEM bloku, BEM elementu un BEzm modifikatorus. Kā arī, ja mūsu kods nonāks kur tālāk, tad arī tam cilvēkam būs viegli orientēties mūsu kodā. */

/* Mēs nedrīkstam vienam un tam pašam BEM blokam jeb BEM elementam mainīt tā elementa nosaukumu kā modifikatoru, pareizi būs piemēram: who-we-are__title_margin-font (nepareizi): who-we-are__margin-font, jo tas iziet ārpus loģikas un netiek vairs ievēroti BEM naming principi - nosacījumi. Jo šādi kā otrajā nepareizajā nosaukuma piemērā sanāk, ka mēs izveidojam vēl vienu BEM elementu, nevis modifikatoru. Tādēļ tā darīt nedrīkst. */

/* Ārpus šīs dienas tēmas. Mēs HTML dokumentā veidojam kastītes tikai tik cik nepieciešams, lai izpildītu kādu uzdevumu. Ja mums nav nepieciešams, tad neveidojam neskaitāmas kastītes. Ja vien tas nav sarežģīts makets, kur tiešām ir vajadzīgas šīs te daudzās kastītes. Cenšamies strādāt vienkārši, paši sev nesarežģījot dzīvi un uzdevumus, paātrinot darbu. */

/* Mēs esam nonākuši pie sarežģītākās BEM metodoloģijas tēmas: miks. Šādus nosaukumus mēs lietojam tad, kad gribam kaut ko izmantot vairākas reizes. Mēs varam pielietot miks, miksējot BEM elementus ar BEM blokiem, lai kaut ko, kas maketā atkārtojas vairākas reizes, mēs varētu vienkārši kopēt, un tikai atsevišķos gadījumos, kad kāds kopīgs parametrs atšķiras, mēs ar miks palīdzību to atrisinām. Paskatīsimies uz šo situāciju ar praktisku piemēru HTML dokumentā. */

/* Īsi sakot miks ir: BEM bloku un BEM elementu sajaukums kopā priekš viena objekta. Pie tam BEM elements var būt kā BEM modifikators. */

/* Praktizējamies atkal HTML dokumentā ar mums jau zināmo BEM bloku: who-we-are. */

/* Mēs no mūsu piemēra, kur mums ir main-page bloks, kur iekšā ir BEM bloks: who-we-are, no BEM bloka: who-we-are izveidojam miks, un tagad mūsu piemērs vienlaicīgi ir gan BEM bloks, gan BEM elements. Tas izskatās šādi: who-we-are main-page__who-we-are. Un tas ir kļuvis par miks. */

/* Šādi rīkojoties mēs panākam to, ka no BEM bloka mēs izveidojam BEM bloku un BEM elementu, kas ļauj mums iekš CSS faila izmantot tādus CSS parametrus, kas ietekmē apkārtni, ārējos elementus, piemēram: izmantot CSS parametru: margin. Mums ir jāraksta šādi iekš CSS faila kā zemāk piemērā: */

.main-page__who-we-are {
	margin: 0 0 30px 0;
}

/* Mēs redzam, ka mūsu BEM bloks: who-we-are main-page__who-we-are ir ieguvis atstarpi apakšā 30px. */

/* Arī ar otru piemēru, kur mums ir miks no BEM bloka un BEM elementa: who-we-are contacts__who-we-are, mēs arī varam izmantot tādus CSS parametrus, kas ietekmē ārpusi. */

.contacts__who-we-are {
	margin: 0 0 50px 0;
}

/* Par cik mūsu BEM bloks kļūst par BEM elementu mēs varam tam pielietot visus CSS parametrus. */

/* Šie visi piemēri ir ar BEM neatkarīgiem blokiem. Bet kādā no situācijām tie var būt BEM elementi kādam no vecāka - augstāka bloka un tad mēs uz tiem varam izmantot CSS parametrus, kas ietekmē ārējos objektus tikai vēršoties pie tiem kā BEM bloku BEM elementiem. Kā tas izskatās realitātē? Atgriežamies HTML dokumentā. */

/* Kā mūsu piemērā, kur mums ir BEM bloks: contacts, un mums iekš tā vajag iekopēt BEM bloku: who-we-are, tad mēs to darām šādi: aiz who-we-are rakstām contacts__who-we-are, lai varētu ar to darboties ar visiem CSS parametriem, arī ar margin. */

/* Bet tas darbojas tikai tādā gadījumā, ja mūsu BEM bloks ir tīrs un tas nekādi neietekmē apkārtni, lapas ārējos objektus. Mēs varam to nokopēt, ielikt attiecīgā mums vajadzīgā vietā un pārvērst izmantojot miks BEM elementu. Tas kļūst par kaut kā, kā mūsu piemērā: contacts BEM elementu. */

/* Varētu padomāt, ka vieglāk būtu izmantot katram BEM elementam modifikatoru, bet tā nav laba prakse, iksevišķi, ja izmaiņas ir vairākas. tādēļ pareizāk ir BEM bloku izmantot kā BEM elementu, un tad mēs varam veikt kādas izmaiņas vien vēlamies. */

/* Paskatīsimies ar piemēru, kā mēs pareizi varam izstrādāt BEM bloku, BEM elementu, BEM modifikatoru un pielietot BEM miks, lai izstrādātu vienādus elementus, kas ir maketā car-repair. Atgriežamies HTML dokumentā. */

/* Izmantojam CSS parametrus dažiem CSS selektoriem. Atceramies, ka: who-we-are__header nav vairs BEM bloks, ka tas ir BEM elements un mēs droši varam lietot CSS parametrus, kas ietekmē apkārtni. */

.who-we-are {

}

.who-we-are__header {
	margin: 0 0 36px 0;
}

.header-item__sub-title {

}

.header-item__title {

}

/* Izmantojot šādu pieeju mēs varam brīvi rīkoties ar BEM blokiem un BEM elementiem pārvēršot BEM bloku par BEM elementu. Paskatīsimies kā mums jādara, ja lapā šāds BEM bloks atkārtojas. Atgriežamies HTML dokumentā. */

.promise {

}

.promise__header {
	margin: 0px 0px 68px 0px;
}

.header-item__sub-title {

}

.header-item__title {

}

/* Mums var gadīties situācija, kad miks ir kā palīglīdzeklis brīžos, kad mēs kādam elementam nezinam vairs ko rakstīt, kad mums kaut kas nesanāk. Vienā vārdā sakot - kad mums vairs nav ko uzrakstīt, ja kāds no nosaukumiem ir jau aizņemts. Ko darīt tādā situācijā? Atgriežamies HTML dokumentā, lai to labāk saprastu ar piemēru. */

/* BEM metodoloģijas miks izmantošanas nosacījums: nekādas hierarhijas: mēs rakstot papildus BEM nosaukumus neievērojam nekādu hierarhiju. Arī šinī piemērā ar: promise. Mēs nerakstam promise-item, bet apgriežam to otrādi: item-promise. Tādā veidā tiek ievēroti BEM metodoloģijas nosacījumi. */

/* Nosaukuma apgriešana otrādi ir pats pareizākais veids, jo tādejādi mēs iegūstam jaunu nosaukumu, kam, ja pirmais ir jau aizņemts, tad mēs varam izmantot otro nosaukumu, lai caur to darbotos CSS failā. */

/* Šāda pieeja, kad mēs apgriežam nosaukumu otrādi mums atbrīvojas jauni nosaukumi, kurus varam izmantot. Jo var gadīties, kad kādā iepriekšējā blokā jua ir kāds elements, bloks ar tādu nosaukumu. Tādā gadījumā pareizākā pieeja ir apgriezt to otrādi un izmantot to talāk kodā. Mēs atbrīvojam jaunus nosaukumus.  */

.item-promise {

}

.item-promise__icon {

}

.item-promise__body {

}

.item-promise__title {

}

.item-promise__text {

}

/* Mums atliek tikai caur VSCode paplašinājumu nokopēt klases un ērti strādāt CSS failā, izmantot dažādus CSS parametrus, lai panāktu vēlamo rezultātu. */

/* Praktizējamies klausoties lekciju, kur hTML dokumentā tiek veidoti piemēri ar BEM blokiem, BEM elementiem, BEM modifikatoriem un BEM nosaukumu miks. Spēlējam spēli, pareizi, nepareizi. Vēlāk varēsim šo failu apskatīt, lai labāk saprastu katru no piemēriem, kad ir pareizi uzrakstīts BEM metodoloģijas nosaukums un, kad nav pareizi uzrakstīts. */

/* Mēs nevaram lietot BEM modifikatoru BEM blokam, kas ir norādīts kā pirmais, mēs nevaram to lietot, ja nav BEM elementa. Jo tas neatbild uz jautājumu, kas tieši tiek mainīts. To mēs redzam skaidri mūsu piemērā: some-block_link. Tā nedrīkst darīt, jo mēs neievērojam BEM metodoloģiju. BEM modifikators nevar pastāvēt pats par sevi. Tam ir vajadzīga papildus klase, papildus BEM bloks vai BEM elements. Un tikai tad mēs varam to izmantot. Kā arī šeit nav norādīts modificējamais objekts, kas atbildētu uz jautājumu: ko mēs modificējam? Jo šeit ir norādīts: some-block_link. */

/* Mēs veidojot kādus BEM blokus un BEM elementus daudzas reizes saskarsimies ar to, ka mums ir nepieciešams ierobežot saturu. Tādos gadījumos mēs parasti izmantojam: container. Un tad tam dodam CSS parametrus: max-width un margin. Bet ja lietojam pierakstu piemēram: about container, kur itkā mums ir divi BEM bloki, mums vairs nav īsti saprotams, kuram no viņiem tālāk veidot BEM elementus. Tādēļ itkā šī pieeja būtu ērta, no CSS faila puses, kad izmantojam: .container {} iekš iekavām norādot dotos CSS parametrus, bet no BEM metodoloģijas puses šāda pieeja nav pareiza. Kā mums rīkoties šādos gadījumos? */

/* Šādiem gadījumiem, mums ir ieteicams lietot tehniskos klašu nosaukumus, kas šinī gadījumā būtu: _container. izmantojot šādu pierakstu mēs uzreiz saprotam, ka tā nav vairs BEM metodoloģijas klase, un, ka tā nekādi uz to neattiecas. Jo tas kļūst par palīglīdzekli, lai kontrolētu, ierobežotu kādus elementus, lietotu tiem tādus CSS parametrus, kas skar lapas ārējos objektus. */

/* Izskatām to ar piemēru HTML dokumentā izveidojot BEM bloku ar tehnisko klasi: _container un izmantojam CSS parametrus. */
/*
._container {
	max-width: 1100px;
	margin: 0 auto;
} */

/* Pierakstot šādi tehnisku klašu nosaukumus, ar domu tās izmantot vairākās vietās, mēs un arī cits, kas skatās mūsu kodu uzreiz saprot kur tieši ir BEM metodoloģija un kur ir tehniskā klase. Iespējams, ka ar laiku nāks kāds labāks risinājums kā pareizāk - labāk pierakstīt tehniskās klases, bet pagaidām mēs strādāsim šādi. Un katrs mūsu darbs pēc šīs lekcijas ir jāizgatavo - jāizstrādā ievērojot BEM metodoloģiju. */

/* Bet šāda pieeja at tehnisko klašu izmantošanu, kad mēs priekšā liekam zīmi: _, nav obligāta, jo tas nav nekur apstiprināts, ka tieši šādi ir jādara. Mēs varam vienkārši kā līdz šim izmantot kastīti: container un būt mierīgi, jo lai arī no vienas puses mēs varam izmantot šīs tehniskās klases, no 100% BEM metodoloģijas viedokļa tas nav īsti pareizi. Kaut gan BEM metodoloģijas mājas lapā ir rakstīts, ka katrs, kurš strādā pēc BEM metodoloģijas var nedaudz to mainīt. Bet kamēr mēs tikai pierodam pie tās, mēs to nedarām. */

/* No HTML dokumenta mums ir izņemtas tehniskās klases, jo tas nav vispār pieņemts likums, tādēļ arī iekš CSS faila izslēdzam aktīvo: _container kodu. */
