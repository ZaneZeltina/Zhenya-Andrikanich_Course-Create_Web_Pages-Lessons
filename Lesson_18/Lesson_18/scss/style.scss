@import url("https://fonts.googleapis.com/css?family=Roboto:regular,500,700,900&display=swap");

// Pievienojam šeit _reset.scss failu
@import "_reset";
// Pievienojam šeit _mixins.scss failu
@import "_mixins";

@font-face {
	font-family: "Gilroy";
	src: url("../fonts/Gilroy-Regular.woff2") format("woff2"),
	url("../fonts/Gilroy-Regular.woff") format("woff");
	font-weight: 400;
	font-style: normal;
	font-display: swap;
}

@font-face {
	font-family: "Gilroy";
	src: url("../fonts/Gilroy-Bold.woff2") format("woff2"),
	url("../fonts/Gilroy-Bold.woff") format("woff");
	font-weight: 700;
	font-style: normal;
	font-display: swap;
} 

@font-face {
  font-family: "Helvetica Neue";
  src: url("../fonts/HelveticaNeue-CondensedBlack.woff2") format("woff2"), 
	url("../fonts/HelveticaNeue-CondensedBlack.woff2") format("woff");
  font-weight: 900;
  font-style: normal;
  font-display: swap;
}

@font-face {
  font-family: "Helvetica Neue";
  src: url("../fonts/HelveticaNeue.woff2") format("woff2"), 
	url("../fonts/HelveticaNeue.woff") format("woff");
  font-weight: 400;
  font-style: normal;
  font-display: swap;
}

// Nosakām mainīgos, kurus izmantosim mūsu lapas izstrādē.

// Kartītes fona krāsa
$main-color: #252525;
// Lapas galvenā fona krāsa
$pageColor: #4b4b4b;
// Visbiežāk izmantojamais projekta šrifta lielums
$fontSize: 16px;

// Izmantojam ierobežojošo konteineru mūsu piemērā:

[class*="__container"] {
	max-width: 1140px;
	margin: 0 auto;
	padding: 0 15px;
}

// Mēs izmantojam šo klasi, lai ierobežotu saturu, lai tas nebūtu pārāk plats.

//  Kādēļ mēs iekš __container mainām CSS parametru: box-sizing: content-box? Mēs to mainām, tādēļ, lai tajā netiktu ieskaitīts: padding: 15px. Lai tas neietekmētu: __container izmēru. Protams mēs varam vienkārši tos 30px pieskaitīt pie konteinera max-width un nemainīt box-sizing. Jo rezultāts būs identisks. Šeit varam izmantot jeb kuru no šiem variantiem, rezultāts nemainīsies.

// Ar content-box izmantošanu ir viena priekšrocība: mums nevajag neko rēķināt, mēs vienkārši pierakstām: box-sizing: content-box un vis, bet šie aprēķini nav tik grūti, lai tos nevarētu izdarīt. Mēs aprēķinot padding varam samazināt kodu pa vienu rindu. Tam gan nav lielas nozīmes. Šeit varam izvēlēties: darīt tā kā mums ir ērtāk.

// Standarta lapas adaptīva siets

@media (max-width: 1140px) {
	[class*="__container"] {
		/* max-width: 970px; */
	}
}

@media (max-width: 991.98px) {
	[class*="__container"] {
		/* max-width: 750px; */
	}
}

@media (max-width: 767.98px) {
	[class*="__container"] {
		/* max-width: none; */
	}
} 

// # 1. SCSS pre-procesora izmantošana

// Nosakām šeit izmantojamos šablonus

// %ibg {
	// position: relative;
	// img {
		// position: absolute;
		// object-position: center;
		// object-fit: cover;
		// width: 100%;
		// height: 100%;
		// top: 0;
		// left: 0;
	// }
// }

// Nosakām šeit tehniskās klases, kuras izmantosim

/*
._ibg {
	position: relative;
	img {
		position: absolute;
		object-position: center;
		object-fit: cover;
		width: 100%;
		height: 100%;
		top: 0;
		left: 0;
	}
} */

// Šinī lekcijā mēs mācīsimies par SCSS procesora izmantošanu. Bet vēl pirms tam atgriežamies iepriekšējās lekcijas tēmā par lapas adaptīva izstrādi. Izskatām piemēru no maketa ar kartītes izveidošanu un tās adaptīva izstrādi. Atgriežamies HTML dokumentā un izveidojam kartītes struktūru.

// Kad esam izstrādājuši HTML dokumentā kartītes struktūru, atgriežamies CSS un pievienojam vajadzīgos CSS parametrus. 

// Pievienojam šeit no iepriekšējās lekcijas lapas adaptīva sietu, kas ir jau gatavs, ko varam izmantot kā šablonu.

// Kādēļ mēs attēlu liekam izmantojot HTML dokumenta teg: <img>? Tādēļ, ka domājot uz priekšu, kad mūsu lapa tiks nodota pasūtītājam, tas varēs jebkurā brīdī mainīt attēlu. Ievietot jebkuru attēlu, kas būs konkrētā izmērā, būs adaptīvs. 

// Lai attēls būtu adaptīvs, mums ir jānosaka vairāki CSS parametri. Tā, kā mūsu piemērā. Attēla izstrādē ir ieteicams izmantot CSS parametru: object-fit: cover; Tas darbojas tā pat kā gadījumā, kad izmantojām: background: url("") center / cover no-repeat.

// Tikai mūsu piemērā mēs domājam, lai mūsu lapas izstrādē vis būtu adaptīvs, lai pie mazākām izmaiņām mūsu lapas izstrāde būtu droša. Mainoties saturam, nekas nebruktu.

// Ja izmantosim pieeju ar background izmantošanu, tad lapas īpašniekam zūd iespēja mainīt saturu, attēlus. Tādēļ, jāizmanto pieeja, kad izstrādājam bildi iekš HTML dokumenta. 

// No semantikas viedokļa puses ir ieteicama pieeja ar bildes izvietošanu iekš HTML dokumenta. 

// Mēs nosakām bildei CSS parametru: object-fit: cover; Vēl viens CSS parametrs, kas iet kopā ar CSS parametru: object-fit ir: object-position: center; Tas nosaka, kā bilde tiks attēlota. Mēs varam noteikt vērtības: left, right, center. Pēc noklusējuma šis CSS parametrs or: object-position: center; 

// Nosakot mūsu attēlam noteiktus CSS parametrus, mē iegūstam to pašu efektu, kā tad, ja izmantotu CSS parametru: background. Bet mēs iegūstam vēl vienu priekšrocību: lapas īpašnieks izmantojot CSM sistēmu, no admin paneļa var mainīt attēlu uz jebkuru citu attēlu. Lapas attēlojums - noturība nemainīsies. Citam attēlam tiks piemēroti visi tie paši CSS parametri.

// Zinot kā pareizi izstrādāt lapas, attēla adaptīvu, mēs panākam to, ka mūsu izstrāde ir droša pret jebkurām pārmaiņām. 

// Nosakot elementam CSS parametrus, mums vienmēr jādomā soli uz priekšu: kas notiks, ja mainīsies elementa saturs, vai lapas izstrāde būs noturīga. Mēs varam eksperimentēt, liekot lielāku, mazāku saturu, mainot attēlus. Tā mēs uzreiz redzam, vai esam izdarījuši pareizi un lapa ir noturīga, vai arī, ja nē, tad kaut kas jūk. 

// Šos attēlu CSS parametrus mēs varam noteikt visiem attēliem, kas ir mūsu lapā, atbilstoši maketam. Lai mums nevajadzētu katru reizi katram attēlam šo visu rakstīt, mēs varam izmantot tehnisko klasi: _ibg, kas ir saīsinājums no image background. Mēs atsevišķi savā starta šablonā - CSS dokumentā varam noteikt: _ibg un pievienot attiecīgos CSS parametrus. 

// Atgriežamies pie mūsu piemēra, izmantojot tehnisko klasi: _ibg; Mums jāizmanto tieši tāda sintakse kā piemērā. Mēs rakstam CSS parametrus kopējam: _ibg {} un rakstām tieši attēla parametrus, izmantojot: _ibg img {};

// Pārnesam visus CSS parametrus, izņemot: padding, jo tas katram attēlam var būt citāds.

// Mēs jau runājām par tehnisko klašu izmantošanu. Arī šeit mēs varam vērsties pie sarežģītā selektora izmantošanas, liekot piemērot attiecīgos CSS stilus, visur, kur ir konkrēts selektora nosaukums. Bet daudz ērtāk ir vienkārši izmantot tehnisko klasi.

// Izmantojot šos CSS parametrus attēliem mēs iegūstam to, ka attēli kļūst atsaucīgi. Mainoties viewport izmēram, attēls pielāgojas, kļūst atsaucīgs. Mēs iegūstam atsaucīgo, adaptīvo lapas izstrādi.

// Atgriežamies pie mūsu piemēra, ar kartītes izstrādi un pievienojam CSS parametrus. Pierakstām CSS parametru vērtības, ņemam tās no maketa.

// Svarīgi, kad izstrādājam kartītes, mums jāatceras, ka tās saturs var mainīties, var mainīties virsraksts, teksts. Mums ir jānodrošinās, ka kartītes saite - poga ir piesista pie pašas apakšas. Lai to panāktu, mums ir jāizmanto Flex moduļa parametrs: flex: 1 1 auto;

// Mēs iegūstam, ka mūsu izstrādātās kartītes ir ieguvušas adaptīvo atsaucīgo izstrādi. Lai vēl vairāk nodrošinātos, pievienojam vēl dažus CSS parametrus, pievienojam: min-width: 290px; 

// Esam izskatījuši papildus piemēru vēl no iepriekšējās lekcijas par lapas adaptīva izstrādi, un tagad varam pāriet pie šīs lekcijas tēmas: pre-procesora izmantošanu mūsu darbā. Mēs izmantosim SAAS, SCSS sintaksē.

// Jaunā lekcijas tēma

// Kas tad ir pre-procesors un kā tas tiek izmantots? Tas ir proces, kas notiek pirms tiek izstrādāti CSS parametri - stili. Kāpēc mums ir jāizmanto pre-procesors? Tas nav obligāts, tā nav labākas kvalitātes garantija, taču tas uzlabo izstrādes ātrumu un palielina ērtību. Tas uzlabo koda uzturēšanu nākotnē. To ir vieglāk saprast, vieglāk uzturēt.

// Kādēļ mēs nesākām uzreiz mācīties rakstīt stilus SCSS sintaksē. Tādēļ, ka sākot mācīties ko jaunu: CSS, mēs iemācāmies pašu būtību, iemācāmies parametrus, selektorus, mācamies domāt kā tos pareizi izmantot.

// Mācoties tālāk, mēs mācāmies jaunas tehnoloģijas, kas padara mūsu lapu izstrādi ātrāku un ērtāku.

// Turpmāk mēs strādāsim tikai ar pre-procesora SCSS izmantošanu. Pārnesam visus stilus uz style.scss. Šeit tos dzēšam.

// Pārnesam arī reset faila stilus uz jauno reset.scss failu. Pārnesam arī visus pierakstus uz jauno style.scss failu, lai varam vecos css failus dzēst.

// Turpinām rakstīt konspektu šeit. Ievērojot jauno scss komentāru sintaksi, visi mūsu komentāri - konspekts būs redzams tikai šeit scss failā, tas neparādīsies kompilētajā css failā. Šādi mūsu kompilētais css fails ir īsāks, mazāk kodu rindas.

// HTML dokumentam ir pieslēgts jau kompilētais css fails, kur tagad ir mazāk kodu rindas, un, līdz ar to, jo īsāks fails, jo ātrāk ielādējās lapa.

// Mēs izmantojam papildinājumu live saas compiler, uzrakstam tam json settings failā attiecīgos iestatijumus. Redzam, ka mums parādās mapīte: css, un tajā ir kompilēti abi scss faili, tie ir pārveidoti par parastajiem css failiem.

// Atceramies, ka pie katra projekta mums ir jāmaina live saas compiler iestatījumi JSON failā, jo citādi kompilētie css faili tiks izveidoti saknes mapē, kas šinī gadījumā mums neder.

// SCSS ir pre-procesoram ir daudz priekšrocības. Netiek pārnesti komentāri, netiek pārnesti tukšie selektori. Vēl viena būtiska priekšrocība ir tā, ka mēs varam izmantot mainīgos. Mēs varam izveidot mainīgos, kas saturēs atkārtotus CSS parametrus.

// Mēs izveidojam mainīgos, lai mums nebūtu jāraksta atkārtoti CSS parametri. Mēs izveidojam mainīgos, kurus varam izmantot visur, kur ir nepieciešams. Mēs tos varam izmantot visā mūsu konkrētā projektā neierobežotas reizes.

// Šī iespēja ir arī parastajā CSS failā, bet iekš pre-procesora SCSS to var izdarīt daudz ērtāk.

// Mēs SCSS faila sākumā nosakām mainīgos, izmantojot zīmi: $ - dolārs. Aiz tā rakstām nosaukumu, piemēram mēs gribam noteikt galveno lapas krāsu. Rakstām: $main-color: #252525; Ši noteiktie mainīgie faila sākumā, arī netiek pārnesti kompilētajā CSS failā.

// Tādi noteikti mainīgi mums var būt neierobežotā daudzumā. Tālāk, lai piemēram mums nebūtu jāraksta, jāatceras krāsu heks kodi, mēs rakstām: color: $main-color;

// Mēs iekš SCSS faila izmantojam mainīgo vērtības, nosaukumus, bet iekš kompilētā CSS faila mēs redzam vērtības ierastajā formā. Kā šinī piemērā, mēs redzam krāsas heks kodu.

// Mēs izmantojam mainīgos, lai mums būtu iespēja ātri mainīt lapas krāsu, fontu, izmēru, bez nepieciešamības mainīt katru CSS parametru atsevišķi.

// Mazos projektos, mazās vienas lapas izstrādes projektos reti tiek izmantoti mainīgi, bet, ja projekts ir liels, tad mainīgo izmantošana ir ļoti noderīga. Lai kaut ko mainītu, piemēram lapas krāsu, mums vairs nevajag iet cauri visam kodam, meklēt selektorus, kam mums vajag mainīt krāsu. Mums pietiek ar to, ka dodamies uz SCSS faila sākumu un mainām mainīgo vērtību. Rezultātā krāsa mainās visur, kur ir ierakstīts šis mainīgā nosaukums.

// kad strādāsim ar starta šablonu, tad tur arī tiks izmantoti jau gatavi mainīgie, kur katram projektam mēs varēsim ierakstīt nepieciešamo vērtību. Šādi mūsu lapu izstrāde kļūst ar vien ērtāka, ātrāka.

// Ir vēl viena iespēja, kā mēs varam visā failā aizstāt kādu vērtību. Mēs izmantojam explorer funkciju: find, ierakstām tur vajadzīgo vērtību, to, kuru vēlamies atrast un aizstāt. Ierakstām jauno vērtību,nospiežam replace un tas tiks aizstāts visā failā. Bet ērtāk to ir izdarīt nosakot mainīgos.

// Mūsu VSCode programma ir gudra. Brīdī, kad mēs kādā parametrā kā vērtību vēlamies izmantot mainīgo, mums pietiek uzrakstīt tikai dolāra zīmi: $, VSCode mums pasaka priekšā - ieteikumos kādas ir pieejamās vērtības. Mēs izvēlamies vajadzīgo, un tas tiek automātiski ierakstīts. Mēs pat varam redzēt, ko satur dotais mainīgais.

// Pārlūkā, kur atveram lapu, netiek izmantoti SCSS faili, tie netiek atpazīti. Pārlūkā tiek atpazīti tikai kompilētie CSS faili. Mēs neredzam to, ko esam rakstījuši SCSS failā. Mēs redzam gala rezultātu, mums ierastajā CSS faila sintaksē.

// Tagad izskatīsim pašu labāko pre-procesora īpašību: iekšējo selektoru izmantošana. Mēs nosakām selektoru, pierakstām tam ierastos CSS parametrus. Iekš tā mēs varam vērsties pie citiem selektoriem, bet tikai pie tiem, kas atrodas galvenajā selektorā. Lai labāk saprastu kā tas darbojas un kāda ir pieraksta sintakse, izskatām to ar piemēru:

// Lai mums netraucētu piemērs, izslēdzam iepriekš aktīvo kodu konkrētajiem selektoriem.

// Mēs pierakstām selektora nosaukumu, nosakām tam vajadzīgos stilus. iekš tā vēršamies pie visiem konkrētiem selektoriem, kas atrodas galvenajā selektorā un pievienojam vajadzīgos CSS stilus. Rezultātā: mums ir mazāk kodu rindas un kods ir saprotamāks, labāk lasāms. Bet gala kompilētajā CSS failā nekas nemainās. Mēs redzam divus selektorus, tā kā mums ir jau pierasts.

// Kā mums rīkoties, ja mēs gribam iekš vecāka selektora - klases nosaukuma vērsties pie citiem selektoriem - klašu selektoriem, kas atrodas iekš konkrētā - vecāka selektora. Lai labāk saprastu kā tas darbojas un kāda ir pieraksta sintakse, izskatām to ar piemēru:

// Atgriežamies HTML dokumentā un pievienojam mūsu kartīšu pogai vēl vienu klasi: button. Izslēdzam iepriekš aktīvo kodu.

// Mēs vēršamies pie konkrētas klases, iekš vecāka klases liekot zīmi: & - un liekam punktu un rakstām tās klases nosaukumu pie kuras vēlamies vērsties, bet, kas atrodas iekš galvenās klases. Pievienojam tos parametrus, kurus vēlamies izmantot šai ieliktajā klasē. Gala rezultātā, kompilētajā CSS failā mēs redzam jau pierastu lietu: mēs vēršamies pie konkrētas klases un pie klases, kas ir iekš tās.

// Ja mēs vēlamies vērsties pie klases, kas ir iekš vecāka klases, mēs liekam punktu un rakstām klases nosaukumu. Mēs varam vērsties pie jebkuras klases, kas atrodas iekš vecāka klases. Kompilētajā CSS failā mēs redzam, ka mēs vēršamies pie konkrētas klases, kas ir iekš vecāka klases.

// Lai labāk saprastu kā darbojas vēršanās pie iekšējiem selektoriem, izskatām to ar piemēru. Izslēdzam iepriekšējo aktīvo kodu. Atgriežamies HTML dokumentā, kur pievienojam iekšējo klasi: button.

// Izveidojām iekš mūsu saites teg: <span>, pievienojām tam klases nosaukumu. Teg: <span> atrodas iekš teg: <a>. Mēs vēršamies pie iekšējās klases, liekot punktu. Iekš CSS faila redzam pierasto lietu: mēs vēršamies pie konkrētas klases, kas atrodas iekš vecāka klases. Starp klašu nosaukumiem ir atstarpe.

// Svarīgi: Ja mēs vēršamies vienlaicīgi pie vairākām klasēm mēs liekam zīmi: & - un, bet, ja pie klases, kas ir iekš vecāka klases, mēs liekam punktu.

// Atgriežam kartītes pogu: button HTML dokumentā ierastajā stāvoklī.

// Mums ir paplašinājums priekš VSCode: ecsstractor ar kura palīdzību mēs varam pārnest klases, gan uz CSS failu, gan SCSS pre-procesora failu. Katrā failā tiek izmantota attiecīgā faila sintakse.

// Atveram VSCode shortcuts un nosakām mūsu paplašinājumam: ecsstractor saīsinājuma taustiņus ātrai klašu pārnešanai uz CSS failu un uz SCSS failu. paskatamies kā tas darbojas. Nokopējam no HTML dokumenta visu bloku un pārnesam uz SCSS failu.

// Lai klases tiktu pārnestas uz SCSS failu mums vēlamajā SCSS pre-procesora sintaksē, atceramies, ka mums jāizmanto īsinājumu taustiņu kombinācija: alt + b b - iekš HTML faila. Bet iekš SCSS faila mēs izmantojam paste komandu.

/* 
.block {
		// .block__container
		&__container {
		}
		// .block__items
		&__items {
			display: flex;
	    flex-wrap: wrap;
	    row-gap: 30px;
	    margin: 0px -15px;
		}
		// .block__item
		&__item {
			padding: 0px 15px;
	    flex: 1 1 33.333%;
	    min-width: 290px;
		}
}
.item-block {
	display: flex;
	flex-direction: column;
	height: 100%;
	@media (max-width: 1140px) {
		max-width: 350px;
	}
		// .item-block__image
		&__image {
			padding: 0px 0px 74.28% 0px;
			// @extend %ibg;
			// @include ibg();
			@extend ._ibg;
		}
		// .item-block__img
		&__img {
		}
		// .item-block__body
		&__body {
			padding: 15px;
	    background: #252525;
	    display: flex;
	    flex-direction: column;
	    flex: 1 1 auto;
			*:not(:last-child) {
			margin-bottom: 15px;
		}
		}
		// .item-block__title
		&__title {
			font-size: 30px;
	    line-height: 30px;
	    color: #d9d9d9;
	    font-family: "Helvetica Neue", sans-serif;
	    font-weight: 400;
		}
		// .item-block__text
		&__text {
			font-size: 13px;
	    line-height: 18px;
	    color: #84868c;
	    flex: 1 1 auto;
	    letter-spacing: -0.16px;
		}
		// .item-block__button
		&__button {
			padding: 10px 20px;
	    @include theme(#34c759);
	    color: #252525;
	    text-transform: uppercase;
	    font-size: 10px;
	    font-weight: 900;
	    text-align: center;
	    line-height: 30px;
	    letter-spacing: 20%;
	    border-radius: 40px;
			&::before {
				content: "";
			}
			&::after {
				content: "";
			}
			&:hover {
				background: #90ee90;
			}
			// .loading & {
				// background: #ffa500;
			// }
		}
} */

// Izpildot šo taustiņu kombināciju, mēs iegūstam visas klases no HTML dokumenta bloku, jau pierakstītas SCSS sintaksē. Mēs varam izmantot šo taustiņu kombināciju, lai pārnestu klases uz SCSS failu, lai mums nebūtu jāraksta katru klasi atsevišķi.

// Mēs iegūstam konstrukciju, kad mums ir vecāka bloks iekš kura ir tā elementi. Šeit zīme: & - un nozīmē to, ka mēs vēršamies pie konkrētiem elementiem, kas atrodas vecāka blokā.

// Šī ir viena no SCSS pre-procesora superspējām, kad mums vairs nav katru reizi jāraksta vecāka klases nosaukums, kad mēs vēršamies pie tā elementiem.

// Zīme: & - un šinī gadījumā nozīmē, vecāka bloka nosaukumu.

// Tagad, kad esam iepazinušies ar SCSS pre-procesora izmantošanu, pārrakstīsim mūsu kodu, izmantojot SCSS pre-procesora sintaksi. Pārnesam parastos CSS parametrus attiecīgajos SCSS selektoros.

// Pierodam, ka no šī brīža mēs izmantosim tikai pre-procesoru SCSS. Izdzēšam no šī faila visus vecos CSS selektorus.

// Kad mēs strādājam ar pre-procesoru, mums ir iespēja izstrādājot visu bloku izmantot saliekamo bultiņu, mēs saliekam visa bloka kodu un strādājam tālāk. Iekš CSS faila mēs varējām salikt tikai atsevišķus selektorus, bet SCSS pre-procesora gadījumā mēs varam salikt visu bloku.

// Vēl viena pre-procesora SCSS priekšrocība ir tā, ka mēs uzreiz iekš selektora varam izmantot @media iestatījumus lapas adaptīva izstrādei. Rakstam uzreiz iekš attiecīgā selektora @media iestatījumus. Ievērojam SCSS sintakses pierakstu, tā kā augstāk piemērā.

// Kā mums jāpieraksta SCSS sintaksē, ja gribam izmantot pseido klases. Mēs attiecīgajā elementā liekam zīmi: & un, rakstām ierasto struktūru: ::before {} un ::after {}. Mēs varam izmantot jebkuru pseido klasi, bet šeit piemērā izmantosim ::before {} un ::after {}. Tā kā augstāk piemērā. Tas pats attiecas uz visām pārējām pseido klasēm.

// Mums var rasties situācija, kad mums ir nepieciešams vispirms izpildīt kāda cita vecāka elementa stilus, iekš konkrēta elementa. Piemēram: mums ir situācija, kad mums vajag, lai no mūsu piemēra, mūsu poga ielādes laikā maina krāsu. Mēs ievērojot īpašu pierakstu varam noteikt, ka vispirms izpildīsies konkrētā vecāka, cita bloka parametri konkrētam elementam, bet pēc tam izpildīsies tā pārējie parametri. Kā mēs to varam panākt? Ieejam HTML dokumentā un izveidojam mūsu wrapper vēl vienu klasi: loading. Iekš SCSS faila ievērojot pieraksta sintaksi nosakām, ka mūsu poga pie ielādes: loading mainīs krāsu. Rakstām tā kā augstāk piemērā. 

// Viena no superspējām SCSS pre-procesoram ir tā, ka mēs vienā style.scss failā varam pievienot, izmantojot: @import ""; daudzus citus scss failus. Mums vairs nav nepieciešams slēgt klāt HTML dokumentam daudzus CSS failus, mums pietiek tikai ar vienu.

// SCSS pre-procesora priekšrocība ir arī tā, ka mēs SCSS faila sākumā varam noteikt mainīgos. Mēs liekam zīmi: $ - dolārs, rakstām mainīgā nosaukumu, piemēram: main-color, liekam zīmi : un rakstām vērtību. Heks krāsas kodu. Mēs varam noteikt jebkādu mainīgo. Priekšrocība ir tā, ka strādājot tālāk projektā, mums vairs nav nepieciešams paturēt galvā kādus krāsu heks kodus, vai noteiktus šrifta lielumus - font-size. Mēs vienkārši attiecīgajā vietā rakstām mainīgo nosaukumu.

// Būtiski, ka šie noteiktiem mainīgi nepāriet gatavajā kompilētajā CSS failā. Mēs redzam ierasto sintaksi ar heks kodiem un šrifta izmēriem pikseļos. Būtiski: ja mēs gribam darba gaitā mainīt kāda iepriekš noteiktā mainīgā vērtību, mēs to varam izdarīt vienu reizi, un visur, kur šis mainīgais tiek izmantots, tā vērtība tiks mainīta.

// Svarīgi: Interneta pārlūks neatpazīst, neredz SCSS failus. Tādēļ ir nepieciešams izmantot CSS faila kompilācijas programmu lai gala rezultātā, iegūto CSS failu mēs varētu pieslēgt HTML dokumentam. Gala rezultātā pārlūkā, atverot izstrādātāju rīku, mēs redzam ierasto CSS failu.

// Arī tagad, kad strādājam, mums pieslēgts ir kompilētais CSS fails, mēs redzam, ka mūsu lapā nekas nav mainījies, vis darbojas pareizi.

// Mēs jau redzam, kad izmantojam SCSS pre-procesoru, mums ir izmainījusies komentāru pieraksta sintakse, mums vairs nav pierastie CSS komentāri ar /* */ izmantošanu, mums tagad ir tāda sintakse kā visās citas programmēšanas valodās: // - divas slīpsvītras. Šie komentāri ir redzami tikai SCSS failā, tie netiek pārnesti uz kompilēto CSS failu. Mēs šeit varam rakstīt ko vien vēlamies, tas nekas netiek pārnests uz gatavo CSS failu.

// Ja mums gadās, ka izmantojot VSCode paplašinājumu: ecsstractor un mums kāds klašu selektors vai parastais selektors paliek tukšs, bez CSS parametriem, tas arī netiek pārnests uz gala rezultāta CSS failu.

// Atceramies: mainīgie jāraksta SCSS faila sākumā, jo tādejādi mums ir vieglāk tos atrast, vieglāk orientēties kodā, un mēs jebkurā brīdī jebkuru mainīgo varam mainīt.

// Mainīgie mums ir jānosaka iekš SCSS faila, faila sākumā, un mēs nevaram noteiktos mainīgos style.scss failā izmantot citos SCSS failos, jo VSCode paplašinājums: saas compiler nespēj šo lietu apstrādāt. Kaut gan faktiski būtu jābūt tā, ka mēs varam pat noteikt atsevišķu mainīgo SCSS failu, to pieslēgt pie galvenā: style.scss faila un visam būtu jādarbojas pareizi. Bet mūsu gadījumā tas tā nenotiek, tādēļ atstājam to uz vēlāku laiku, kad strādāsim starta šablonā, un, kad darbosies papildus programma: GULP.

// Mainīgo noteikšana style.scss faila sākuma ir laba izstrādātāja darbības prakse. Ja mums ir ļoti mazs projekts, tad mēs varam nenoteikt mainīgos, bet, ja projekts ir lielāks, tad laba izstrādāta piemērs ir, ka tas nosaka faila sākumā visus mainīgos. Tādus, kurus vajadzēs izmantot vairākkārt. Krāsas, šriftus, augstumus. Mēs varam iekš mainīgajiem izmantot jebkuru CSS parametru.

// kad strādāsim ar starta šablonu tur jau būs daudz noteikti mainīgie, kurus varēsim izmantot, kā arī noteikt savus attiecīgajam projektam vajadzīgos mainīgos.

// Ir vēl viens variants, ja mums ir noteikta CSS parametru vērtība daudzās vietās, mēs varam iekš VSCode explorer CSS mapē atvērt meklētāju, ierakstīt meklējamo vērtību, ierakstīt jaunu vērtību, nospiest replace, un tas tiks aizstāts visā failā. Bet ērtāk ir izmantot mainīgos, jo šāda pieeja ar explorer izmantošanu ir sarežģītāka un prasa ilgāku laiku. Kamēr izmantojot mainīgos, mēs to panākam daudz ātrāk un ērtāk.

// Pie katra mainīgā noteikšanas SCSS faila sākumā, mēs varam pierakstīt ar komentāru, kas tieši ir domāts. Tādā veidā mums pēc tam ir vieglāk atrast kodā vajadzīgo, viegli orientēties. Atceramies: komentāri ieks scss faila nav redzami gala CSS failā.

// Mums ir iespēja noteikt mainīgos arī iekš CSS faila, bet tas ir diezgan sarežģīti, un tās tiek parādītas arī pārlūkā, kas nevienmēr ir vēlams, tādēļ labāk noteikt mainīgos iekš SCSS faila.

// Būtiska SCSS pre-procesora superspēja ir tā, ka mēs iekš galvenā style.scss faila, faila sākumā varam pieslēgt vairākus citus SCSS failus. Mums iekš CSS mapes ir CSS fails: reset.css. Mēs pārnesam tā saturu uz jaunu SCSS failu: _reset.scss un mūsu saas kompilators tā saturu pievieno gala CSS failam.

// Svarīgi: Mūsu paplašinājums: saas compiler, ja rakstīsim vienkārši scss failu nosaukumus kompilēs galā mums vairākus CSS failus. Lai tas nenotiktu, lai visi SCSS faili būtu apvienoti vienā CSS failā, mums veidojot jaunus SCSS failus katra faila nosaukuma priekšā jāliek apakšsvītra: _reset.scss. Tādējādi mūsu paplašinājums sapratīs, ka šis fails ir jāpievieno galvenajam style.scss failam.

// Lai pievienotu citus failus galvenajam style.scss failam, mums faila sākumā jāraksta sekojoši: @import "_reset"; Faila paplašinājumu mēs varam nerakstīt.

// Izmantojot šādu pieeju, mēs iekš galvenā faila varam pieslēgt neskaitāmus scss failus. Ja strādājam pēc BEM metodoloģijas, tā paredz, ka mēs projektu sadalām mazos atsevišķos gabaliņos, daudzos failos, bet tik sīki gan mēs to nedarīsim. Bet mēs varam izveidot vairākus SCSS failus, kur katrs saturēs atsevišķu bloku, vai kādu lapas daļu, pagrabu vai cepuri, vai formu.

// Vēl viena CSS pre-procesora super spēja ir: moduļu izmantošana. Kas tad ir modulis? Moduļu izmantošana iekš SCSS pre-procesora parādījās samērā nesen. Ja gribam izmantot moduļus, mums jāizveido jauns SCSS fails: _modules.scss iekš kura rakstām piemēram: $fontSize: 24px; Mēs nosakām mainīgo. Iekš galvenā style.scss faila sākumā rakstām: @use "_modules"; 

// Dotais VSCode saas kompilators vēl nesaprot pieeju, kad izmantojam moduļus un mums nekas nemainās gala CSS failā, tādēļ moduļu izmantošanu atliekam uz to laiku, kad izmantosim speciālu programmu: GULP ar starta šablonu.

// Kad strādāsim ar GULP un varēsim izmantot moduļus, tad tanīs vietās, kur mēs vēlēsimies tos izmantot būs jāraksta šādi: _modules.$fontSize. Tādējādi mēs varēsim izmantot moduļus, kas saturēs atkārtotus CSS parametrus. Bet pagaidām tos neizmantojam, jo mūsu saas compiler to nesaprot.

// Mums vēl ir daudz nezināmu lietu par SCSS pre-procesoru. Viena no tām ir mixins izmantošana. Kas tad ir mixin? Mixin ir gatavs uzstādīts koda gabaliņš, ko mēs varam izmantot, lai iekš tā izmantotu vairākus mainīgos. Kā tas īsti darbojas? Izskatīsim mixin izmantošanu ar piemēru: 

// @mixin theme($color) {
	// color: $color;
	// border: 1px solid $color;
// }

// Šāda ir mixin sintakse: mēs rakstam @mixin, rakstam mixin nosaukumu, kas mūsu gadījumā ir: theme, liekam () iekavās, kurās rakstām mainīgo nosaukumus, no mūsu piemēra: $color. Liekam {} figūriekavas, kurās rakstām CSS parametrus, kuriem vēlamies izmantot kā vērtības liekam mainīgo: $color. Pēc tam attiecīgajā vietā, kur vēlamies izmantot mixin, rakstām: @include theme(#34c759); Iekš () iekavām rakstām mainīgā vērtību, mūsu gadījumā krāsas heks kodu.

// Svarīgi: Lai mēs varētu izmantot mixin, tam jābūt noteiktam pirms tā izmantošanas, augstāk kodā, jo, ja būs otrādi mums tas nedarbosies, un gala CSS failā nekas nemainīsies.

// Izslēdzam mūsu mixin un pārvietojam to augstāk kodā, lai varētu izmantot un redzēt, kas notiek gala CSS kompilētajā failā. Izpildot visu pareizi mēs redzam, ka, kad izmantojam doto mixin mūsu pogai, gala CSS kompilētajā failā parādās ierastie CSS parametri. Redzam, ka mixin darbojas tā kā mēs to noteicām.

// Mēs varam sadalīt sīkāk un izveidot atsevišķu SCSS failu: _mixins, pieslēgt to aiz faila: _reset, un tur rakstīt visus mixins, kādus vēlamies izmantot. Tādējādi mums būs ļoti ērti un ātri izmantot mixins.

// Izdarām to, izveidojam atsevišķu SCSS failu, ieliekam tur mūsu mixin, un paskatamies vai mums viss darbojas. Izpildot visu pareizi, mēs redzam, ka mums vis darbojas, un gala CSS kompilētajā failā mēs redzam mixin darbību, mums jau ierastos CSS parametrus.

// Kad strādāsim ar starta šablonu un GULP, mēs izmantosim daudz sarežģītākus mixins, kur ir daudzi mainīgie.

// Bet tagad, par cik mūsu VSCode paplašinājums: saas compiler nesaprot situāciju, kad izmantojam @use, mēs sarežģītos mixin atliksim, bet turpināsim izskatīt visas SCSS pre-procesora iespējas.

// Izmantojot SCSS pre-procesoru mums ir iespēja izmantot šablonus. Izskatīsim šablona izmantošanu ar mūsu kartīšu attēliem. Lai izmantotu šablonus, tiem jābūt pierakstītiem  - noteiktiem pirms to izmantošanas, tā pat kā ar mixins. Izskatīsim šablona izmantošanas piemēru:

// Lai izmantotu šablonu, mums mūsu tehniskais klases nosaukums attēliem: _ibg ir nedaudz jāmaina. Atgriežamies HTML dokumentā un noņemam visām sešām kartītēm šo tehnisko klasi. Atgriežamies šeit un izveidojam šablonu, pierakstot:

// %ibg {
	// position: relative;
	// img {
		// position: absolute;
		// object-position: center;
		// object-fit: cover;
		// width: 100%;
		// height: 100%;
		// top: 0;
		// left: 0;
	// }
// }

// Pārnesam šo šablonu augstāk kodā, jo mēs to varam izmantot tikai aiz tā noteikšanas. Atrodam ieks SCSS faila, kur mums ir klase: &__image un iekš parametriem rakstām: @extend %ibg; Tādejādi mēs varam izmantot jau gatavus šablonus mūsu projektā visur, kur mums tas ir vajadzīgs.

// Vienkārši nosakot šablonu izmantojot zīmi: %, tas nav redzams gala CSS kompilētajā failā. Tā parametri kļūst redzami tikai tad, kad iekš style.scss faila mēs izmantojam šo šablonu konkrētai klasei.

// Izpildot šo skatamies, kas mums notiek gala CSS kompilētajā failā. Mēs redzam, ka mums ir izveidojušas - kompilējušās divas klases, kas atbild par attēlu mūsu kartītēs, un tām ir visi nepieciešamie CSS stili, tie, ko noteicām šablonā. Redzam, ka visu esam izdarījuši pareizi un mums vis darbojas.

// Ar ko tad šablonu izmantošana atšķiras ar mixins izmantošanu? Iekš mixins mēs varam noteikt kādus datus, izmantot mainīgos, bet šabloni ir statistiski, mēs tajos nevaram noteikt mainīgos vai ko tamlīdzīgu. Mēs iekš tiem varam izmantot CSS parametrus. 

// Bet šablonu izmantošana ir noderīga, mēs vienreiz faila sākumā pierakstām mums vajadzīgos šablonus, un izmantojam tos visur kur vien mums vajag, neskaitāmas reizes. Šī arī ir liela SCSS pre-procesora priekšrocība.

// Izskatīsim kā mēs šo pašu varam panākt, ja izmantojam mixin, kur varam pievienot mainīgos un pat iekš () iekavām pievienot vērtības mainīgajiem. Izskatām to ar mūsu piemēru, pierakstām mixin iekš mūsu _mixins.scss faila.

// Atgriežamies ieks mūsu darba faila: style.scss un iekš klases: &__image pievienojam doto mixin rakstot: @include ibg(). 

// Lai mums netraucētu iepriekš noteiktais šablons: %ibg, izslēdzam šo koda rindu un aizstājam ar mixin @include rindu. Skatamies, kas mums notiek gala CSS kompilētajā failā.

// Mixins izmantošanai ir ļoti liela priekšrocība, mēs varam pievienot un mainīt datus. Kamēr šablonu izmantošana ir statistiska, tikmēr iekš mixin, kad to izmantojam kā mūsu piemērā, iekš klases: &__image {} iekavām mēs varam ierakstīt: @include ibg(left); kas nozīmē, ka mēs mainām mainīgā: $position vērtību no center uz left. Izmēģinām to ar mūsu piemēru un skatamies, kas notiek gala CSS kompilētajā failā. Mēs redzam, ka mainot mainīgā: $position vērtību uz left, kad lietojam konkrēto mixin, mūsu gala CSS failā mainās CSS parametra: object-position: vērtība no center uz left.

// Mēs redzam, ka visērtāk un ātrāk ir izmantot mixins. Mēs jebkurā brīdī varam mainīt mainīgo vērtības, kas automātiski tiek parādīts kompilētajā CSS failā.

// Ar laiku strādājot, lai katru reizi mums nebūtu jāraksta bieži izmantojami koda fragmenti, mēs varam izveidot savus snippets. Kur būs gatavi kodu gabaliņi, un mums atliek tikai uzrakstīt dažus simbolus un mēs iegūstam gatavu koda gabalu. Tas ir ļoti ērti. Mēs jau tagad daudz kur izmantojam mums iedotos gatavos snippets, bet mēs tos varam paildzināt un izveidot savus snippets.

// Laba izstrādātāja prakse ir tomēr lietot klases, arī tehniskās klases, iekš HTML dokumenta, jo tas dod iespēju lapas īpašniekam no admin paneļa noteikt, vai klase tiks pievienota vai nē. Šāds variants ir daudz elastīgāks un pareizāks no lapas izstrādes viedokļa puses.

// Ja mēs neizmantojam papildus klases, un lietojam vienu klasi, iekļaujot mixins, tad mainīt šo kodu - ietekmēt to, lapas īpašniekam jau ir daudz grūtāk.

// Atgriežamies HTML dokumentā un atliekam atpakaļ pie image tehnisko klasi: _img.

// Atgriežoties pie šablonu izmantošanas izmantojot zīmi: %, mēs tos varam izmantot, ja mums pietiek ar statistiskiem datiem, CSS parametriem. Tad mēs kā gatavu kodu to varam izmantot attiecīgās vietās mūsu projektā.

// Mums ir iespēja iekš kādas klases pieslēgt citu klasi izmantojot @extend liekot punktu un rakstot klases nosaukumu. Atgriezīsimies sākotnējā stāvoklī, kad mums iekš HTML dokumenta ir tehniskā klase: _ibg. Mēs iekš klases: &__image {} iekavām rakstām: @extend ._ibg;

// Izpildām šos nosacījumus un skatamies, kas mums notiek gala CSS failā. Redzam, ka par cik iekš SCSS faila mēs noteicām konkrētai klasei piemērojamos stilus, iekš CSS dokumenta ir izveidojies interesants klašu pieraksts, kur tiek pārskaitītas visas klases, šinī gadījumā divas klases, kurām tiek piemēroti attiecīgie stili.

// Tagad mēs zinam, ja mums nav nepieciešams iekš HTML izmantot atsevišķu klasi, tad ierastajām klasēm varam izmantot mixins, jo tie ir daudz ērtāki, un atceramies, ka iekš mixins mēs varam noteikt mainīgos, to vērtības, bet pēc tam lietojot attiecīgos mixins attiecīgajās klases, mēs varam ātri šīs vērtības mainīt.

// Mixins var salīdzināt ar BEM metodoloģijas modifikatoru izmantošanu, tikai bez HTML.

// Izskatīsim kā SCSS sintaksē darbojas modifikatoru lietošana, izmantojot HTML un BEM metodoloģiju. Atgriežamies HTML dokumentā un izveidojam klasei: block__item papildus klasi: block__item_big, kas ir jau ar modifikatoru. Izmantojot shortcut pārnesam klases uz galveno style.scss dokumentu un paskatamies kāda ir sintakse. Atceramies, ka lai nokopētu klases no HTML dokumenta pēc BEM metodoloģijas un pārnestu mums vajadzīgā SCSS faila sintaksē, mums jāizmanto karstie taustiņi: alt + ~;

.block {
		// .block__item
		&__item {
		}
		// .block__item_big
		&__item_big {
		}
}

// Mēs redzam, ka mums ir kopīga klase: block un divas apakšklases: block__item un klase ar modifikatora izmantošanu: block__item_big. Vēl viens variants kā mēs varam pierakstīt šādas klases ar modifikatora izmantošanu ir šāds:

.block {
	  // .block__item
		&__item {
			// .block__item_big
			&_big {

			}
		}
}

// Pierakstot šādi, mēs iegūstam vēl vienu veidu kā pierakstīt ieliktas klases un klases ar modifikatoru.

// Strādājam tālāk, izslēdzam HTML dokumentā visu: block, un izslēdzam šeit visus tā stilus. 

// Izmantojam CSS sintakses komentārus, lai mums visi CSS parametri paliktu arī gala kompilētajā CSS failā, jo, ja izmantosim SCSS sintakses komentārus zīmes, tie neparādīsies gala CSS failā.

// Atgriežamies HTML dokumentā un izveidojam sarakstu. Izveidojam menu konstrukciju, nokopējam klašu nosaukumus pēc BEM metodoloģijas ar komentāriem šeit SCSS failā.

// Izmantojamā funkcija, lai aprēķinātu šrifta lielumu rem mērvienībās

@function rem($fontSize) {
	$result: $fontSize / 16 + rem;
	@return $result;
}
@function em($fontSize) {
	$result: $fontSize / 16 + em;
	@return $result;
}
.list {
	padding: 30px;
	font-size: em(14);
	font-size: rem(14);
		// .list__item
		&__item {
			transform: translate(-100%, 0px);
			transition: 0.4s;
			@for $let from 1 to 5 {
				&:nth-child(#{$let}) {
					transition-delay: 0.1s * $let;
				}
			} 
			&:not(:last-child) {
				margin-bottom: 15px;
			}
		}
		// .list__link
		&__link {
			color: #fff;
		}
		&:hover {
			// .list__item
			.list__item {
				transform: translate(0px, 0px);
			}
		}
}

// Mēs izstrādājam sarakstu ar animāciju, katram punktam liekot animācijas aizturi. Šādu lietu mēs jau bijām taisījuši. Paskatīsimies kā mēs šo varam uzlabot, izstrādāt labāk - automatizēt.

// Izmantojot SCSS pre-procesoru mēs šo garo koda pierakstu varam automatizēt izmantojot @for ciklu. Izpildām to un pierakstām @for ciklu, stingri ievērojot sintaksi. Tā kā augstāk piemērā.

// Mēs pierakstām ciklu: @for un liekam tam izpildīt nosacījumus no 1 līdz 5 elementam. Kā nosacījumu nosakām, ka animācijas aizture būs 0.1s reizināts ar elementa kārtas numuru.

// Kādēļ mēs šo saraksta animāciju automatizējām? Mēs protams varējām četras reizes pierakstīt: nth-child(1), nth-child(2), nth-child(3), nth-child(4), bet tas būtu ļoti ilgi un neērti. Tādēļ mēs izmantojām @for ciklu, lai šo darbu automatizētu. Šinī piemērā mums ir četri punkti, bet mums var būt arī 20 un vairāk punktu. Šādā gadījumā mēs varam izmantot @for ciklu norādot, ka tas izpildīsies no 1 līdz 21 elementam. Mēs jebkurā brīdī varam mainīt elementu skaitu no kura līdz kram tiks izpildīts @for cikls.

// Gala CSS kompilētajā failā mēs redzam ierasto pierakstu, kur katru reizi tiek noteikta :nth-child() izmantošana.

// Darba sākumā pirmajā gadā mēs šo pieeju visticamāk neizmantosim. Bet laikam ejot, ar pieredzi, mēs varēsim daudzus stilu procesus automatizēt, tā kā mums nepieciešams katrā reizē.

// Mēs jau tagad daļēji iepazīstamies ar programmēšanas valodu: JavaScript. Mēs jau lietojam tās darbības principus.

// Šim ciklam @for mēs varam noteikt arī nosacījumus: @if kas nozīmē, ja. Ja izpildās nosacījums, tad kaut kas notiek. Šis vis nāk no JavaScript programmēšanas valodas.

// Iekš SCSS pre-procesora mēs pat varam izmantot funkcijas, kas arī ir no JavaScript programmēšanas valodas. Izskatīsim to ar piemēru:

// @function rem($fontSize) {
	// $result: $fontSize / 16 + rem;
	// @return $result;
// }

// Mēs pierakstām funkciju, kurai nosakām mainīgo: $fontSize. Mēs aprēķinām mainīgā vērtību, dalot to ar 16 un piesakot rem. Pēc tam mēs atgriežam mainīgā vērtību.

// Mēs varam izmantot šo funkciju un paskatīties kā tā darbojas, un kas notiek gala CSS kompilētajā failā.

// Redzam, ka mūsu pierakstītā funkcija nedarbojas, pārnesam to augstāk kodā pirms tās izmantošanas.

// Redzam, ka izpildās nosacījums, kas ir JavaScript programmēšanas valodā, mēs varam lietot funkciju pēc tās noteikšanas. Tikko mēs pārnesām funkciju augstāk un pēc tam to izmantojam, tā redzam, ka tā darbojas un gala kompilētajā CSS failā mēs redzam, ka mūsu noteiktais šrifta lielums ir pārvērsts rem mērvienību sistēmā.

// Mēs iegūstam to, ka tagad mēs varam šrifta lielumu šeit iekš SCSS faila pierakstīt pikseļos, priekšā rakstot: rem() iekavās rakstot pikseļus. Redzam, ka gala CSS kompilētajā failā pikseļi ir pārvērsti rem mērvienību sistēmā.

// Par mērvienību sistēmām un pareizu to izmantošanu mēs mācīsimies vēlāk.

// Mēs šo srifta aprēķināšanas funkciju varam izmantot arī lai iegūtu šrifta lielumu em mērvienību sistēmā. Pierakstām augstāk šo funkciju un izmēģinām kā tā darbojas iekš tās pašas klases: .list.

// Redzam, ka iekš šī SCSS faila mēs rakstām lielumu pikseļos iekš () iekavām, priekšā rakstot em, un gala CSS failā mēs iegūstam šrifta lielumu em mērvienības sistēmā.

// Abos gadījumos, kad izmantojam funkciju, mēs redzam, ka vis darbojas korekti. Atceramies: Lai funkcija darbotos, tai jābūt noteiktai pirms tās izmantošanas.

// Mēs izskatījām iespējas kā mēs varam izmantot SCSS pre-procesoru. Izskatījām dažādas tā priekšrocības. Izskatījām arī kā mēs varam izmantot ciklus un funkcijas, bet tas nenozīmē, ka šo visu mēs uzreiz izmantosim. Galvenokārt mēs sākumā izmantosim ielikšanas sistēmu pēc BEM metodoloģijas. Tikai ar laiku, ar pieredzi, ar jaunām zināšanām mēs sāksim izmantot SCSS pre-procesora iespējas pilnībā. Bet mums jau tagad ir svarīgi zināt par visām SCSS pre-procesora iespējām.

// No šodienas mums ir jāsaprot dažas lietas. Kas ir pre-procesors, kā tas ir jāizmanto, kā tas darbojas kā SAAS tikai SCSS sintaksē, Kā tiek pierakstīta ielikšanas sistēma, kā darbojas klašu kopēšana pēc BEM metodoloģijas kopā ar komentāriem, kā darbojas mixins, mainīgie.

// Tālākajās lekcijās mēs uzzināsim vēl par tām lietām, kas mums šodien nesanāca: moduļu izmantošanu, matemātiskām darbībām - aprēķināšanu. Par visiem tehniskajiem ierobežojumiem, kas ir saistīti ar vienkāršā VSCode paplašinājuma izmantošanu: saas compiler. Mēs to un vēl daudz ko citu izskatīsim vēlāk, kad strādāsim ar starta šablonu un GULP.

// Nākošajā lekcijā mēs iepazīsimies ar programmu: GULP. Bet, lai saprastu, kas tas vispār ir, un kas mūs sagida, sāksim ar to iepazīties jau tagad, šinī pat lekcijā. Izskatīsim GULP teoriju. 

// ==============================================

// # 2. GULP TEORIJA

// GULP ir viens no vispopulārākajiem uzdevumu vadības rīkiem, kas izmantojams web izstrādē. GULP ir rakstīts JavaScript valodā, un tas darbojas uz Node.js platformas. GULP ir izstrādāts, lai automatizētu atkārtotus uzdevumus, kas saistīti ar web izstrādi. GULP ir izstrādāts, lai palīdzētu mums web izstrādē, automatizētu - izpildītu atkārtotus rutīnas uzdevumus.

// Izmantojot GULP mēs varam konvertēt šriftu saimes, konvertēt, saspiest attēlus, konvertēt no SCSS faila uz CSS failu, saspiest visus mūsu failus, mainīt attēlu formātus, saspiest attēlus un daudz ko citu.

// Ļoti svarīgi: lai mums korekti darbotos GULP bez kļūdām, mums mūsu VSCode programmai ir iestatījumos, iekš properties jāieliek ķeksītis: atvērt kā administratoram. Lai mums katru reizi nebūtu jāspiež atvērt kā administratoram, lai tas notiktu automātiski.

// Mēs turpmāk strādāsim ar GULP tādēļ ir svarīgi ievērot katru tehnisko nosacījumu, lai mums vēlāk nerastos kļūdas un mēs neteiktu, ka mums nekas nestrādā. 

// Izejam no VSCode programmas, iestatām palaist kā administratoram. Lai mēs droši varētu strādāt ar GULP.

// Strādājot ar GULP mēs beidzot izmantosim VSCode termināli. Kas ir ļoti liela VSCode programmas izmantošanas priekšrocība. Ieteicams ir izmantot tieši: Git Bash termināli. Tas nozīmē, ka uz mūsu datora ir jābūt uzinstalētam GIT programmai. To mēs varam izdarīt no oficiālās Git mājas lapas.

// Lai iekš VSCode atvērtu termināli mēs varam izmantot dažādās iespējas. Visērtāk to ir izdarīt vienkārši pavelkot bultiņu no apakšas uz augšu. Mums atvērsies terminālis. Uzstādām kā noklusējuma termināli git bash.

// Mēs jau mazliet protams strādāt ar termināļa komandu rindu. To apguvām, kad mācījāmies par Git versiju kontroli un github izmantošanu. Bet mēs vēl atskatīsimies uz šo tēmu.

// Mums ir ļoti svarīgi prast strādāt ar git versiju kontroli, jo pat, ja mēs strādājam vienatnē pie projekta, mums ir ļoti ērti, ja kas nobrūk atgriezties pie iepriekšējās projekta versijas. Tādēļ ir svarīgi, pie katrām lielākām izmaiņām saglabāt projekta versiju, izmantojot git commit komandu.

// Pēc Git instalēšanas uz datora, svarīgi atvērt VSCode programmu, atvērt termināli un noteikt git bash termināļa izmantošanu pēc noklusējuma. Lai vienmēr tiktu izmantots tieši git bash terminālis.

// Kad strādāsim ar GULP mēs daudz izmantosim VSCode termināli. 

// Mums ir vēl viens uzdevums. Ir tāda lieta, ka vis GULP ir uz JavaScript programmēšanas valodas sistēmas. To lieliski saprot visi pārlūki, jo vis internets vairumā ir izstrādāts izmantojot JavaScript. Bet mums ir nepieciešams, lai JavaScript kods tiktu saprasts un palaists arī uz mūsu datora. Tādēļ mums kopā ar Git ir jāuzinstalē uz datora arī Node.js. To arī varam izdarīt Node.js oficiālajā mājas lapā.

// Node.js ir JavaScript valodas izpildītājs, kas darbojas uz mūsu datora. Node.js ir nepieciešams, lai mēs varētu izpildīt JavaScript kodu uz mūsu datora. Tādēļ mums ir jāuzinstalē uz datora Node.js.

// Mēs sākot lietot GULP uzinstalēsim to globāli, izmantojot git bash termināli un atsevišķi instalēsim tā paplašinājumus, papildus moduļus, kas mums būs nepieciešami, lai GULP varētu darbotos tā kā mums to vajag.

// Mēs nestrādāsim tikai ar GULP, mēs izmantosim divas programmas vienlaicīgi, kas optimizēs ikdienas rutīnas darbus. Mēs darbosimies gan ar GULP, gan ar Webpack. Webpack ir vēl viens uzdevumu vadības rīks, kas ir ļoti līdzīgs GULP, bet Webpack ir vēl sarežģītāks un spēcīgāks rīks. Mēs sākumā iepazīsimies ar GULP, jo tas ir vienkāršāks un vieglāk saprotams.

// Mēs strādāsim ar starta šablonu, kur pamatā ir GULP, bet tur būs arī šis tas no Webpack. Bet mēs nemācīsimies visu par Webpack, mēs vairāk pievērsīsimies GULP lietošanai.

// Sākot ar nākošo lekciju, mēs strādāsim jau pavisam ar citu failu struktūru. Mums nebūs vairs šis ierastais šablons. Vis būs daudz savādāk, sarežģītāk. Tagad mums liekas, ka GULP ir ļoti sarežģīts, un tā tas arī ir. Bet tas mums ir nepieciešams. Visur, arī firmās, kur notiek izstrāde tiek izmantots kāds no šiem rīkiem, vai GULP, vai Webpack, vai Vite. Un mums jāprot ar tiem strādāt.

// Mēs turpinām lapu izstrādi pēc maketiem, turpinām strādāt pēc BEM metodoloģijas, turpinam izmantot moduli flex un turpinām izstrādāt lapas adaptīvu, plus tagad mēs strādājam izmantojot SCSS pre-procesoru.






