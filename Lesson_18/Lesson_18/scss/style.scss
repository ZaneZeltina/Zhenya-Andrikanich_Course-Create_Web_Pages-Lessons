@import url("https://fonts.googleapis.com/css?family=Roboto:regular,500,700,900&display=swap");

@import "_reset";

@font-face {
	font-family: "Gilroy";
	src: url("../fonts/Gilroy-Regular.woff2") format("woff2"),
	url("../fonts/Gilroy-Regular.woff") format("woff");
	font-weight: 400;
	font-style: normal;
	font-display: swap;
}

@font-face {
	font-family: "Gilroy";
	src: url("../fonts/Gilroy-Bold.woff2") format("woff2"),
	url("../fonts/Gilroy-Bold.woff") format("woff");
	font-weight: 700;
	font-style: normal;
	font-display: swap;
} 

@font-face {
  font-family: "Helvetica Neue";
  src: url("../fonts/HelveticaNeue-CondensedBlack.woff2") format("woff2"), 
	url("../fonts/HelveticaNeue-CondensedBlack.woff2") format("woff");
  font-weight: 900;
  font-style: normal;
  font-display: swap;
}

@font-face {
  font-family: "Helvetica Neue";
  src: url("../fonts/HelveticaNeue.woff2") format("woff2"), 
	url("../fonts/HelveticaNeue.woff") format("woff");
  font-weight: 400;
  font-style: normal;
  font-display: swap;
}

// Izmantojam ierobežojošo konteineru mūsu piemērā:

[class*="__container"] {
	max-width: 1140px;
	margin: 0 auto;
	padding: 0 15px;
}

// Standarta lapas adaptīva siets

@media (max-width: 1140px) {
	[class*="__container"] {
		/* max-width: 970px; */
	}
}

@media (max-width: 991.98px) {
	[class*="__container"] {
		/* max-width: 750px; */
	}
}

@media (max-width: 767.98px) {
	[class*="__container"] {
		/* max-width: none; */
	}
} 

// Mēs izmantojam šo klasi, lai ierobežotu saturu, lai tas nebūtu pārāk plats.

//  Kādēļ mēs iekš __container mainām CSS parametru: box-sizing: content-box? Mēs to mainām, tādēļ, lai tajā netiktu ieskaitīts: padding: 15px. Lai tas neietekmētu: __container izmēru. Protams mēs varam vienkārši tos 30px pieskaitīt pie konteinera max-width un nemainīt box-sizing. Jo rezultāts būs identisks. Šeit varam izmantot jeb kuru no šiem variantiem, rezultāts nemainīsies.

// Ar content-box izmantošanu ir viena priekšrocība: mums nevajag neko rēķināt, mēs vienkārši pierakstām: box-sizing: content-box un vis, bet šie aprēķini nav tik grūti, lai tos nevarētu izdarīt. Mēs aprēķinot padding varam samazināt kodu pa vienu rindu. Tam gan nav lielas nozīmes. Šeit varam izvēlēties: darīt tā kā mums ir ērtāk.

// Šinī lekcijā mēs mācīsimies par SCSS procesora izmantošanu. Bet vēl pirms tam atgriežamies iepriekšējās lekcijas tēmā par lapas adaptīva izstrādi. Izskatām piemēru no maketa ar kartītes izveidošanu un tās adaptīva izstrādi. Atgriežamies HTML dokumentā un izveidojam kartītes struktūru.

// Kad esam izstrādājuši HTML dokumentā kartītes struktūru, atgriežamies CSS un pievienojam vajadzīgos CSS parametrus. 

// Pievienojam šeit no iepriekšējās lekcijas lapas adaptīva sietu, kas ir jau gatavs, ko varam izmantot kā šablonu.

// Kādēļ mēs attēlu liekam izmantojot HTML dokumenta teg: <img>? Tādēļ, ka domājot uz priekšu, kad mūsu lapa tiks nodota pasūtītājam, tas varēs jebkurā brīdī mainīt attēlu. Ievietot jebkuru attēlu, kas būs konkrētā izmērā, būs adaptīvs. 

// Lai attēls būtu adaptīvs, mums ir jānosaka vairāki CSS parametri. Tā, kā mūsu piemērā. Attēla izstrādē ir ieteicams izmantot CSS parametru: object-fit: cover; Tas darbojas tā pat kā gadījumā, kad izmantojām: background: url("") center / cover no-repeat.

// Tikai mūsu piemērā mēs domājam, lai mūsu lapas izstrādē vis būtu adaptīvs, lai pie mazākām izmaiņām mūsu lapas izstrāde būtu droša. Mainoties saturam, nekas nebruktu.

// Ja izmantosim pieeju ar background izmantošanu, tad lapas īpašniekam zūd iespēja mainīt saturu, attēlus. Tādēļ, jāizmanto pieeja, kad izstrādājam bildi iekš HTML dokumenta. 

// No semantikas viedokļa puses ir ieteicama pieeja ar bildes izvietošanu iekš HTML dokumenta. 

// Mēs nosakām bildei CSS parametru: object-fit: cover; Vēl viens CSS parametrs, kas iet kopā ar CSS parametru: object-fit ir: object-position: center; Tas nosaka, kā bilde tiks attēlota. Mēs varam noteikt vērtības: left, right, center. Pēc noklusējuma šis CSS parametrs or: object-position: center; 

// Nosakot mūsu attēlam noteiktus CSS parametrus, mē iegūstam to pašu efektu, kā tad, ja izmantotu CSS parametru: background. Bet mēs iegūstam vēl vienu priekšrocību: lapas īpašnieks izmantojot CSM sistēmu, no admin paneļa var mainīt attēlu uz jebkuru citu attēlu. Lapas attēlojums - noturība nemainīsies. Citam attēlam tiks piemēroti visi tie paši CSS parametri.

// Zinot kā pareizi izstrādāt lapas, attēla adaptīvu, mēs panākam to, ka mūsu izstrāde ir droša pret jebkurām pārmaiņām. 

// Nosakot elementam CSS parametrus, mums vienmēr jādomā soli uz priekšu: kas notiks, ja mainīsies elementa saturs, vai lapas izstrāde būs noturīga. Mēs varam eksperimentēt, liekot lielāku, mazāku saturu, mainot attēlus. Tā mēs uzreiz redzam, vai esam izdarījuši pareizi un lapa ir noturīga, vai arī, ja nē, tad kaut kas jūk. 

// Šos attēlu CSS parametrus mēs varam noteikt visiem attēliem, kas ir mūsu lapā, atbilstoši maketam. Lai mums nevajadzētu katru reizi katram attēlam šo visu rakstīt, mēs varam izmantot tehnisko klasi: _ibg, kas ir saīsinājums no image background. Mēs atsevišķi savā starta šablonā - CSS dokumentā varam noteikt: _ibg un pievienot attiecīgos CSS parametrus. 

// Atgriežamies pie mūsu piemēra, izmantojot tehnisko klasi: _ibg; Mums jāizmanto tieši tāda sintakse kā piemērā. Mēs rakstam CSS parametrus kopējam: _ibg {} un rakstām tieši attēla parametrus, izmantojot: _ibg img {};

// Pārnesam visus CSS parametrus, izņemot: padding, jo tas katram attēlam var būt citāds.

// Mēs jau runājām par tehnisko klašu izmantošanu. Arī šeit mēs varam vērsties pie sarežģītā selektora izmantošanas, liekot piemērot attiecīgos CSS stilus, visur, kur ir konkrēts selektora nosaukums. Bet daudz ērtāk ir vienkārši izmantot tehnisko klasi.

// Izmantojot šos CSS parametrus attēliem mēs iegūstam to, ka attēli kļūst atsaucīgi. Mainoties viewport izmēram, attēls pielāgojas, kļūst atsaucīgs. Mēs iegūstam atsaucīgo, adaptīvo lapas izstrādi.

// Atgriežamies pie mūsu piemēra, ar kartītes izstrādi un pievienojam CSS parametrus. Pierakstām CSS parametru vērtības, ņemam tās no maketa.

// Svarīgi, kad izstrādājam kartītes, mums jāatceras, ka tās saturs var mainīties, var mainīties virsraksts, teksts. Mums ir jānodrošinās, ka kartītes saite - poga ir piesista pie pašas apakšas. Lai to panāktu, mums ir jāizmanto Flex moduļa parametrs: flex: 1 1 auto;

// Mēs iegūstam, ka mūsu izstrādātās kartītes ir ieguvušas adaptīvo atsaucīgo izstrādi. Lai vēl vairāk nodrošinātos, pievienojam vēl dažus CSS parametrus, pievienojam: min-width: 290px; 

// Esam izskatījuši papildus piemēru vēl no iepriekšējās lekcijas par lapas adaptīva izstrādi, un tagad varam pāriet pie šīs lekcijas tēmas: pre-procesora izmantošanu mūsu darbā. Mēs izmantosim SAAS, SCSS sintaksē.

// Jaunā lekcijas tēma

// Kas tad ir pre-procesors un kā tas tiek izmantots? Tas ir proces, kas notiek pirms tiek izstrādāti CSS parametri - stili. Kāpēc mums ir jāizmanto pre-procesors? Tas nav obligāts, tā nav labākas kvalitātes garantija, taču tas uzlabo izstrādes ātrumu un palielina ērtību. Tas uzlabo koda uzturēšanu nākotnē. To ir vieglāk saprast, vieglāk uzturēt.

// Kādēļ mēs nesākām uzreiz mācīties rakstīt stilus SCSS sintaksē. Tādēļ, ka sākot mācīties ko jaunu: CSS, mēs iemācāmies pašu būtību, iemācāmies parametrus, selektorus, mācamies domāt kā tos pareizi izmantot.

// Mācoties tālāk, mēs mācāmies jaunas tehnoloģijas, kas padara mūsu lapu izstrādi ātrāku un ērtāku.

// Turpmāk mēs strādāsim tikai ar pre-procesora SCSS izmantošanu. Pārnesam visus stilus uz style.scss. Šeit tos dzēšam.

// Pārnesam arī reset faila stilus uz jauno reset.scss failu. Pārnesam arī visus pierakstus uz jauno style.scss failu, lai varam vecos css failus dzēst.

// Turpinām rakstīt konspektu šeit. Ievērojot jauno scss komentāru sintaksi, visi mūsu komentāri - konspekts būs redzams tikai šeit scss failā, tas neparādīsies kompilētajā css failā. Šādi mūsu kompilētais css fails ir īsāks, mazāk kodu rindas.

// HTML dokumentam ir pieslēgts jau kompilētais css fails, kur tagad ir mazāk kodu rindas, un, līdz ar to, jo īsāks fails, jo ātrāk ielādējās lapa.

// Mēs izmantojam papildinājumu live saas compiler, uzrakstam tam json settings failā attiecīgos iestatijumus. Redzam, ka mums parādās mapīte: css, un tajā ir kompilēti abi scss faili, tie ir pārveidoti par parastajiem css failiem.

// Atceramies, ka pie katra projekta mums ir jāmaina live saas compiler iestatījumi JSON failā, jo citādi kompilētie css faili tiks izveidoti saknes mapē, kas šinī gadījumā mums neder.

// SCSS ir pre-procesoram ir daudz priekšrocības. Netiek pārnesti komentāri, netiek pārnesti tukšie selektori. Vēl viena būtiska priekšrocība ir tā, ka mēs varam izmantot mainīgos. Mēs varam izveidot mainīgos, kas saturēs atkārtotus CSS parametrus.

// Mēs izveidojam mainīgos, lai mums nebūtu jāraksta atkārtoti CSS parametri. Mēs izveidojam mainīgos, kurus varam izmantot visur, kur ir nepieciešams. Mēs tos varam izmantot visā mūsu konkrētā projektā neierobežotas reizes.

// Šī iespēja ir arī parastajā CSS failā, bet iekš pre-procesora SCSS to var izdarīt daudz ērtāk.

// Mēs SCSS faila sākumā nosakām mainīgos, izmantojot zīmi: $ - dolārs. Aiz tā rakstām nosaukumu, piemēram mēs gribam noteikt galveno lapas krāsu. Rakstām: $main-color: #252525; Ši noteiktie mainīgie faila sākumā, arī netiek pārnesti kompilētajā CSS failā.

// Tādi noteikti mainīgi mums var būt neierobežotā daudzumā. Tālāk, lai piemēram mums nebūtu jāraksta, jāatceras krāsu heks kodi, mēs rakstām: color: $main-color;

// Mēs iekš SCSS faila izmantojam mainīgo vērtības, nosaukumus, bet iekš kompilētā CSS faila mēs redzam vērtības ierastajā formā. Kā šinī piemērā, mēs redzam krāsas heks kodu.

// Mēs izmantojam mainīgos, lai mums būtu iespēja ātri mainīt lapas krāsu, fontu, izmēru, bez nepieciešamības mainīt katru CSS parametru atsevišķi.

// Mazos projektos, mazās vienas lapas izstrādes projektos reti tiek izmantoti mainīgi, bet, ja projekts ir liels, tad mainīgo izmantošana ir ļoti noderīga. Lai kaut ko mainītu, piemēram lapas krāsu, mums vairs nevajag iet cauri visam kodam, meklēt selektorus, kam mums vajag mainīt krāsu. Mums pietiek ar to, ka dodamies uz SCSS faila sākumu un mainām mainīgo vērtību. Rezultātā krāsa mainās visur, kur ir ierakstīts šis mainīgā nosaukums.

// kad strādāsim ar starta šablonu, tad tur arī tiks izmantoti jau gatavi mainīgie, kur katram projektam mēs varēsim ierakstīt nepieciešamo vērtību. Šādi mūsu lapu izstrāde kļūst ar vien ērtāka, ātrāka.

// Ir vēl viena iespēja, kā mēs varam visā failā aizstāt kādu vērtību. Mēs izmantojam explorer funkciju: find, ierakstām tur vajadzīgo vērtību, to, kuru vēlamies atrast un aizstāt. Ierakstām jauno vērtību,nospiežam replace un tas tiks aizstāts visā failā. Bet ērtāk to ir izdarīt nosakot mainīgos.

// Mūsu VSCode programma ir gudra. Brīdī, kad mēs kādā parametrā kā vērtību vēlamies izmantot mainīgo, mums pietiek uzrakstīt tikai dolāra zīmi: $, VSCode mums pasaka priekšā - ieteikumos kādas ir pieejamās vērtības. Mēs izvēlamies vajadzīgo, un tas tiek automātiski ierakstīts. Mēs pat varam redzēt, ko satur dotais mainīgais.

// Pārlūkā, kur atveram lapu, netiek izmantoti SCSS faili, tie netiek atpazīti. Pārlūkā tiek atpazīti tikai kompilētie CSS faili. Mēs neredzam to, ko esam rakstījuši SCSS failā. Mēs redzam gala rezultātu, mums ierastajā CSS faila sintaksē.

// Tagad izskatīsim pašu labāko pre-procesora īpašību: iekšējo selektoru izmantošana. Mēs nosakām selektoru, pierakstām tam ierastos CSS parametrus. Iekš tā mēs varam vērsties pie citiem selektoriem, bet tikai pie tiem, kas atrodas galvenajā selektorā. Lai labāk saprastu kā tas darbojas un kāda ir pieraksta sintakse, izskatām to ar piemēru:

// Lai mums netraucētu piemērs, izslēdzam iepriekš aktīvo kodu konkrētajiem selektoriem.

// Mēs pierakstām selektora nosaukumu, nosakām tam vajadzīgos stilus. iekš tā vēršamies pie visiem konkrētiem selektoriem, kas atrodas galvenajā selektorā un pievienojam vajadzīgos CSS stilus. Rezultātā: mums ir mazāk kodu rindas un kods ir saprotamāks, labāk lasāms. Bet gala kompilētajā CSS failā nekas nemainās. Mēs redzam divus selektorus, tā kā mums ir jau pierasts.

// Kā mums rīkoties, ja mēs gribam iekš vecāka selektora - klases nosaukuma vērsties pie citiem selektoriem - klašu selektoriem, kas atrodas iekš konkrētā - vecāka selektora. Lai labāk saprastu kā tas darbojas un kāda ir pieraksta sintakse, izskatām to ar piemēru:

// Atgriežamies HTML dokumentā un pievienojam mūsu kartīšu pogai vēl vienu klasi: button. Izslēdzam iepriekš aktīvo kodu.

// Mēs vēršamies pie konkrētas klases, iekš vecāka klases liekot zīmi: & - un liekam punktu un rakstām tās klases nosaukumu pie kuras vēlamies vērsties, bet, kas atrodas iekš galvenās klases. Pievienojam tos parametrus, kurus vēlamies izmantot šai ieliktajā klasē. Gala rezultātā, kompilētajā CSS failā mēs redzam jau pierastu lietu: mēs vēršamies pie konkrētas klases un pie klases, kas ir iekš tās.

// Ja mēs vēlamies vērsties pie klases, kas ir iekš vecāka klases, mēs liekam punktu un rakstām klases nosaukumu. Mēs varam vērsties pie jebkuras klases, kas atrodas iekš vecāka klases. Kompilētajā CSS failā mēs redzam, ka mēs vēršamies pie konkrētas klases, kas ir iekš vecāka klases.

// Lai labāk saprastu kā darbojas vēršanās pie iekšējiem selektoriem, izskatām to ar piemēru. Izslēdzam iepriekšējo aktīvo kodu. Atgriežamies HTML dokumentā, kur pievienojam iekšējo klasi: button.

// Izveidojām iekš mūsu saites teg: <span>, pievienojām tam klases nosaukumu. Teg: <span> atrodas iekš teg: <a>. Mēs vēršamies pie iekšējās klases, liekot punktu. Iekš CSS faila redzam pierasto lietu: mēs vēršamies pie konkrētas klases, kas atrodas iekš vecāka klases. Starp klašu nosaukumiem ir atstarpe.

// Svarīgi: Ja mēs vēršamies vienlaicīgi pie vairākām klasēm mēs liekam zīmi: & - un, bet, ja pie klases, kas ir iekš vecāka klases, mēs liekam punktu.

// Atgriežam kartītes pogu: button HTML dokumentā ierastajā stāvoklī.

// Mums ir paplašinājums priekš VSCode: ecsstractor ar kura palīdzību mēs varam pārnest klases, gan uz CSS failu, gan SCSS pre-procesora failu. Katrā failā tiek izmantota attiecīgā faila sintakse.

// Atveram VSCode shortcuts un nosakām mūsu paplašinājumam: ecsstractor saīsinājuma taustiņus ātrai klašu pārnešanai uz CSS failu un uz SCSS failu. paskatamies kā tas darbojas. Nokopējam no HTML dokumenta visu bloku un pārnesam uz SCSS failu.

// Lai klases tiktu pārnestas uz SCSS failu mums vēlamajā SCSS pre-procesora sintaksē, atceramies, ka mums jāizmanto īsinājumu taustiņu kombinācija: alt + b b - iekš HTML faila. Bet iekš SCSS faila mēs izmantojam paste komandu.

.block {
		// .block__container
		&__container {
		}
		// .block__items
		&__items {
			display: flex;
	    flex-wrap: wrap;
	    row-gap: 30px;
	    margin: 0px -15px;
		}
		// .block__item
		&__item {
			padding: 0px 15px;
	    flex: 1 1 33.333%;
	    min-width: 290px;
		}
}
.item-block {
	display: flex;
	flex-direction: column;
	height: 100%;
	@media (max-width: 1140px) {
		max-width: 350px;
	}
		// .item-block__image
		&__image {
			padding: 0px 0px 74.28% 0px;
		}
		// .item-block__img
		&__img {
		}
		// .item-block__body
		&__body {
			padding: 15px;
	    background: #252525;
	    display: flex;
	    flex-direction: column;
	    flex: 1 1 auto;
			*:not(:last-child) {
			margin-bottom: 15px;
		}
		}
		// .item-block__title
		&__title {
			font-size: 30px;
	    line-height: 30px;
	    color: #d9d9d9;
	    font-family: "Helvetica Neue", sans-serif;
	    font-weight: 400;
		}
		// .item-block__text
		&__text {
			font-size: 13px;
	    line-height: 18px;
	    color: #84868c;
	    flex: 1 1 auto;
	    letter-spacing: -0.16px;
		}
		// .item-block__button
		&__button {
			padding: 10px 20px;
	    background: #34C759;
	    color: #252525;
	    text-transform: uppercase;
	    font-size: 10px;
	    font-weight: 900;
	    text-align: center;
	    line-height: 30px;
	    letter-spacing: 20%;
	    border-radius: 40px;
			&::before {
				content: "";
			}
			&::after {
				content: "";
			}
			&:hover {
				background:#adff2f;
			}
			.loading & {
				background: #ffa500;
			}
		}
}
._ibg {
	position: relative;
	img {
		position: absolute;
		object-position: center;
		object-fit: cover;
		width: 100%;
		height: 100%;
		top: 0;
		left: 0;
	}
}
// Izpildot šo taustiņu kombināciju, mēs iegūstam visas klases no HTML dokumenta bloku, jau pierakstītas SCSS sintaksē. Mēs varam izmantot šo taustiņu kombināciju, lai pārnestu klases uz SCSS failu, lai mums nebūtu jāraksta katru klasi atsevišķi.

// Mēs iegūstam konstrukciju, kad mums ir vecāka bloks iekš kura ir tā elementi. Šeit zīme: & - un nozīmē to, ka mēs vēršamies pie konkrētiem elementiem, kas atrodas vecāka blokā.

// Šī ir viena no SCSS pre-procesora superspējām, kad mums vairs nav katru reizi jāraksta vecāka klases nosaukums, kad mēs vēršamies pie tā elementiem.

// Zīme: & - un šinī gadījumā nozīmē, vecāka bloka nosaukumu.

// Tagad, kad esam iepazinušies ar SCSS pre-procesora izmantošanu, pārrakstīsim mūsu kodu, izmantojot SCSS pre-procesora sintaksi. Pārnesam parastos CSS parametrus attiecīgajos SCSS selektoros.

// Pierodam, ka no šī brīža mēs izmantosim tikai pre-procesoru SCSS. Izdzēšam no šī faila visus vecos CSS selektorus.

// Vēl viena pre-procesora SCSS priekšrocība ir tā, ka mēs uzreiz iekš selektora varam izmantot @media iestatījumus lapas adaptīva izstrādei. Rakstam uzreiz iekš attiecīgā selektora @media iestatījumus. Ievērojam SCSS sintakses pierakstu, tā kā augstāk piemērā.

// Kā mums jāpieraksta SCSS sintaksē, ja gribam izmantot pseido klases. Mēs attiecīgajā elementā liekam zīmi: & un, rakstām ierasto struktūru: ::before {} un ::after {}. Mēs varam izmantot jebkuru pseido klasi, bet šeit piemērā izmantosim ::before {} un ::after {}. Tā kā augstāk piemērā. Tas pats attiecas uz visām pārējām pseido klasēm.

// Mums var rasties situācija, kad mums ir nepieciešams vispirms izpildīt kāda cita vecāka elementa stilus, iekš konkrēta elementa. Piemēram: mums ir situācija, kad mums vajag, lai no mūsu piemēra, mūsu poga ielādes laikā maina krāsu. Mēs ievērojot īpašu pierakstu varam noteikt, ka vispirms izpildīsies konkrētā vecāka, cita bloka parametri konkrētam elementam, bet pēc tam izpildīsies tā pārējie parametri. Kā mēs to varam panākt? Ieejam HTML dokumentā un izveidojam mūsu wrapper vēl vienu klasi: loading. Iekš SCSS faila ievērojot pieraksta sintaksi nosakām, ka mūsu poga pie ielādes: loading mainīs krāsu. Rakstām tā kā augstāk piemērā. 

// Viena no superspējām SCSS pre-procesoram ir tā, ka mēs vienā style.scss failā varam pievienot, izmantojot: @import url("") daudzus scss failus. Mums vairs nav nepieciešams slēgt klāt HTML dokumentam daudzus CSS failus, mums pietiek ar vienu.