@import url("https://fonts.googleapis.com/css?family=Poppins:regular,700&display=swap");

@font-face {
	font-family: "Gilroy";
	src:
		url("../fonts/Gilroy-Regular.woff2") format("woff2"),
		url("../fonts/Gilroy-Regular.woff") format("woff");
	font-weight: normal;
	font-style: normal;
	font-display: swap;
}

@font-face {
	font-family: "Gilroy";
	src:
		url("../fonts/Gilroy-Bold.woff2") format("woff2"),
		url("../fonts/Gilroy-Bold.woff") format("woff");
	font-weight: bold;
	font-style: normal;
	font-display: swap;
}

/* RESET CSS STYLES: */

*,
*::before,
*::after {
	margin: 0;
	padding: 0;
	border: 0;
}
li {
	list-style: none;
}
a,
a:visited {
	text-decoration: none;
}
a:hover {
	text-decoration: none;
}
h1,
h2,
h3,
h4,
h5,
h6 {
	font-weight: inherit;
	font-size: inherit;
}
img {
	vertical-align: top;
}
html {
	font-size: 16px; /* Noklusējuma šrifta lielums */
}
body {
	font-family: "Poppins", sans-serif;
	line-height: 1;
}

/* Šeit beidzās CSS STYLES RESET */

/* -------------------------------------- */

/* Atceramies: Strādājot ar jebkuru projektu: Šriftu saimes ņemam sev līdzi!!! */

/* Divi veidi kā mēs savam projektam varam pieslēgt šriftu saimi: */

/* (1) Attālinātā pieslēgšana. Pieslēgšana izmantojot ārēju resursu (pēc saites). */
/* (2) Lokāla pieslēgšana. Pieslēgšana izmantojot lokālus failus, kas atrodas mūsu datorā. */

/* Pieslēgšanas piemērs izmantojot VS Code Plugin: Google Fonts. */

/* @import url("https://fonts.googleapis.com/css?family=Poppins:100,100italic,200,200italic,300,300italic,regular,italic,500,500italic,600,600italic,700,700italic,800,800italic,900,900italic"); */

/* Pieslēgšanas piemērs no oficiālās Google Fonts mājaslapas:  */

/* @import url("https://fonts.googleapis.com/css2?family=Poppins:wght@400;700&display=swap"); */

/* &display=swap&subset=cyrillic-ext . Ļoti svarīgi ir sekot līdzi, lai pieslēgšanas saitei būtu šis parametrs. Sīkāk par to ir paskaidrots zemāk. */

/* Ja mēs zinām, ka šrifta saime ir iekš Google Fonts, tad mēs varam izmantot plugin: Google fonts, caur kuru, izmantojam @import to CSS mēs varam pieslēgt visu mums nepieciešamo fonta saimi, ar visiem tā šrifta lielumiem, sākot no 100 un beidzot ar 900 italic. */

/* Atceramies, ka šrifta stils regular pēc tā svara atbilst: 400, bet Google Fonts pieslēgšanas saitē no oriģinālās lapas tas tiek norādīts kā parametrā wght@ , bet iekš VS Code Plugin: Google Fonts saites tas tiek norādīts aiz šrifta nosaukuma aiz : zīmes rakstot nevis: 400, bet gan: normal, aiz normal liekot komatu un norādot citus šrifta saimes stilus. */

/* Bet ir četras būtiskas atšķirības starp pieslēgšanu izmantojot Google fonts oficiālo lapu un starp pieslēgšanu izmantojot VS Code Plugin: Google fonts. */

/* Pirmā atšķirība: No Google Fonts oficiālās lapas iekš saites ir kods: Poppins:wght@400; , kas var nepatikt, turpmāk kad strādāsim ar Web Lapu Izstrādes Starta Šablonu, kur tike izmantots: Gulp, mums var rasties kļūdas, jo Gulp nepatīk tādi kodi, kur iekšā ir: @. */

/* Otrā atšķirība ir: Mēs no oficiālās Google Fonts mājas lapas varam paši izvēlēties, kādus konkrētās Šrifta saimes stilus mums vajag. Vai mums vajag tikai 400 italic, vai tikai 700 bold, bet iekš VS Code Plugin: Google fonts mēs nevaram izvēlēties, mums tiek iedoti visi izvēlētā šrifta stili. */

/* Ja mēs pieslēdzam šriftus izmantojot VS Code Plugin Google fonts, tad mums, lai nepārslogotu lapas ielādi, ir no pieslēgšanas saites jāizņem liekie fontu stili ārā. */

/* Trešā atšķirība: Šriftu pieslēgšanas saitei no oficiālās Google Fonts mājas lapas ir būtisks parametrs, kas nav iekļauts pieslēgšanas saitei no VS Code Plugin: Google Fonts. Un tas ir: &display=swap. Šis koda gabals ir ļoti svarīgs, jo tas ir domāts šrifta ielādes optimizācijai. Mūs lapa kļūs ātrāka, ja mēs iekš sriftu pieslēgšanas saites pievienosim šo parametru. */

/* Ceturtā būtiska atšķirība ir: Ka, ja mēs izmantojam oficiālo Google Fonts pieslēgšanas mājaslapu, tad mēs varam izvēlēties šrifta attēlošanas valodu. Izvēlētā valoda kā koda gabals tiks iekļauta mūsu pieslēgšanas saitē, kas izskatās šādi: &subset=cyrillic-ext . Aiz zīmes: = tiek rakstīta mūsu izvēlētā šrifta attēlošanās krievu valodā: cyrillic-ext, kas nodrošina, ka mūsu izvēlētā šrifta saime pareizi attēlos krievu burtus: cyrillic. */

/* Bet, ja mums ir nepieciešams pieslēgt kādu citu attēlojamo šrifta valodu, tad iekš oficiālās Google Fonts mājas lapas mēs varam izvēlēties sev nepieciešamo šrifta attēlošanas valodu izvēlētos iespēju: Language un izvēloties mums nepieciešamo šrifta attēlošanas valodu, bet tā ir jānorāda tikai īpašos gadījumos, piemēram: Krievu valodas izmantošanas gadījumā utt. */

/* Bet dotajai šrifta saimei: "Poppins", sans-serif nav Cyrillic šrifta valodas. Tādēļ mēs izmantojam koda gabalu: &subset=cyrillic-ext , lai atrisinātu šo problēmu. Mēs pieslēdzam Cyrillic Extended šrifta valodu, kas nozīmē, ka mūsu Krievu valodas burti tiks pareizi attēloti. */

/* Atceramies, ka lai lieki nenoslogotu mūsu lapas ielādi, mums, ja izmantojam VS Code Plugin: Google Fonts, mums liekie šrifta stili ir jānoņem, lai lieki nenoslogotu mūsu lapu. Jo katra simbola izmantošana kodā pievieno papildus slodzi pie lapas ielādes, tādēļ kaut ko pieslēdzot ir svarīgi ievērot principu: Mēs pieslēdzam tikai to, kas mums pa tiešām ir vajadzīgs, lieko izņemot no pieslēgšanas saites ārā. Tādejādi mēs optimizējam ne tikai kodu, bet arī lapas ielādes ātrumu. */

/* Krievu Poppins šrifta saimes pieslēgšanas saite izskatās šādi: 
@import url("https://fonts.googleapis.com/css2?family=Poppins:regular,700&display=swap&subset=cyrillic-ext");
 */

/* Ja mums nav vajadzīga īpaša šrifta attēlošanas valoda, tad izmantojam VS Code Plugin: Google Fonts, izvēlamies sev nepieciešamo šriftu, izņemam ārā liekos stilus un pievienojam koda gabalu: &display=swap, lai nodrošinātu šrifta ielādes ātruma optimizāciju mūsu lapā. */

/* Pilnīga pareiza konkrētā gadījuma Google Font šrifta latviešu valodas šrifta valodas pieslēgšanas saite:

@import url("https://fonts.googleapis.com/css2?family=Poppins:regular,700&display=swap") */

/* Šis vis augstāk aprakstītais ir tajos gadījumos, kad mūsu izvēlētā šrifta saime ir iekš Google Fonts, bet ko darīt tādos gadījumos, kad mūsu izvēlētā Šrifta saime nav iekš Google Fonts? mēs izmantojam otro Šrifta pieslēgšanas variantu, izveidojot un izmantojot lokālu failu. */

/* Tādos gadījumos, mums ir izvēlētā Šrifta saime pēc tās nosaukuma jāsameklē lapā Google, piemērā Šrifta saime: Gilroy. Sameklējam konkrēto Šrifta saimi Gilroy iekš Google, atveram lapu, kur ir šāda Šrifta saime. Ļoti laba lapa, lai meklētu Šriftu saimes ir: "https://webfonts.pro/". Šī arī ir liela Šriftu datu bāze. Mēs to atveram, sameklējam tur mums nepieciešamo Šrifta saimi, kas mūsu gadījumā ir: Gilroy, lejupielādējam Šrifta saimi, lejupielādējam to TTF faila formātā, saglabājam to iekš projekta mapītes: fonts. */

/* Pēc tam, kad esam lejupielādējuši nepieciešamo Šrifta saimi lejupielādējuši iekš projekta fonts mapītes, TTF faila formātā, mums ir nepieciešams šos Šrifta saimes failus no TTF faila formāta konvertēt uz Woff2 faila formātu un uz parasto Woff formātu, mums ir vajadzīgi abi failu formāti. Woff2 ir Šriftu Web formāts un Woff2 ir Šriftu web 2 versijas formāts. */

/* Lai to izdarītu mēs izmantojam servisu trans fonter, kura adrese ir: "https://transfonter.org/" . Spiežam pogu: Add Fonts, pievienojam mūsu lejupielādētos Šriftus, kas ir mapītē fonts. TTF faila formātā un spiežam uz pogas: Convert. Pēc tam, kad redzam, ka mūsu Šrifti ir konvertēti spiežam link: download, lejupielādējam atkal mūsu projekta mapītē: fonts. redzam, ka mums parādās arhīvs, kurš ir jāizpako, tur ir 6 dažādi faili, jo izvēlējāmies sākotnēji divus dažādus Šrifta stilus, kas katrs tika lejupielādēts kā atsevišķs fails. Izpakojot arhīvu, mums ir viens demo.html fails un viens stylesheet.css fails, kā arī: divi šrifta faili: Woff formātā, un divi šrifta  faili: Woff2 formātā. Iepriekšējos TTF faila formātus mēs varam izdzēst, jo tie mums vairāk nav vajadzīgi. Visi 4 šrifta faili ir saspiesti, kompresēti, tie aizņem maz atmiņas vietas, līdz ar ko šādi faili ātri ielādēsies, kad tos izmantosim savā lapā. */

/* Konvertētie šriftu faili mums ir jāpieslēdz pa pāriem, kādēļ tā? Tāpēc, ka ne visi pārlūki prot nolasīt pēdējo faila versiju: Woff2, tādēļ mums ir jāpieslēdz arī parastais Woff fails. Mums ir jāpieslēdz abi faila formāti, lai mūsu lapu varētu atvērt no jebkura pārlūka un tas spētu attēlot mums vajadzīgo šrifta saimi un stilu. Jo, lai kuru failu pārlūks pieslēgtu, tā būs šriftu optimizācija, kas ļaus mūsu sriftu failiem mūsu lapā ielādēties daudz ātrāk, jo šie jaunie konvertētie faila formāti ir daudz mazāka lieluma, tie ir daudz vieglāki.  */

/* Iekš izpakotā arhīva ir stylesheet.css fails, kuru atverot mēs redzam, ka tur jau ir gatavas koda rindas šriftu pieslēgšanai. Mums tās ir nedaudz jāmodificē un jāpārnes uz mūsu styles.css failu. Nokopējam to kodu, kas ir stylesheet.css failā, pārnesam uz mūsu style.css failu, un nedaudz mainām kodu. Mums jāizmaina fontu atrašanās ceļš un . Pēc tam, kad esam to izdarījuši mēs failu: stylesheet.css varam izdzēst, un demo.html failu mēs arī varam izdzēst. rezultātā mūsu mapītē: fonts mums paliek šinī gadījumā: 4 faili, divi: Woff formātā un divi: Woff2 formātā. */

/* Mums style.css failā ir jauna konstrukcija: @font-face, jauns CSS selektors, kas satur sevī dažādus CSS parametrus, kas ir: font-family: Gilroy; Kas nozīmē, kādu fonta saimi mēs izmantojam. Tālāk mums ir CSS parametrs: src: url("../fonts/Gilroy-Regular.woff2"), kas norāda faila atrašanās vietu, tālāk mums tajā pašā parametrā ir: format ("Woff2"), kas norāda faila formātu, pēc tam mēs atkārtojam parametra vērtības: url("../fonts/Gilroy-Regular.woff") un format ("Woff"), kur norādām otrā faila atrašanās vietu un formātu. */

/* Mums konstrukcija, CSS selektors: @font-face ir jānorāda divas reizes, jo mums ir divi dažādi Šrifta saimes stili. Tādēļ mums konstrukcija: @font-face ir jāizmanto divas reizes, mainot sākotnēji nokopētos CSS parametrus. Parametru: font-family mēs abos piemēros rakstām vienādi, bet iekš parametra src: mēs norādām otrā šrifta stila abu failu formātu atrašanās ceļus un formātus. Pirmajā piemērā mēs pieslēdzam Šrifta: "Gilroy" regular stilu, bet otrajā piemērā mēs pieslēdzam Šrifta: "Gilroy" Bold stilu, pieslēdzot katru failu, gan Woff2 formāta failu, gan Woff formāta failu. Mums jau ir vis nokopēts no stylesheet.css faila, mums tikai nedaudz jāmodificē failu atrašanās ceļi. */

/* Pirmajā piemērā parametrā: font-weight mums vērtība ir: normal, kas nozīmē, ka tiek izmantots šrifts, kas atbilst svaram: 400, bet otrajā piemērā parametrā: font-weigh: mums vērtība ir: bold, kas nozīmē, ka mēs izmantojam šriftu, kas atbilst svaram: 700. Mums ir nepieciešams mainīt tikai vienu CSS parametru: srr: failu atrašanās ceļus, pārējās CSS parametru vērtības atstājam nemainīgas. Tādas kādas mēs tās nokopējām no stylesheet.css faila. */

/* Šis šrifta saimes pieslēgšanas veids var tikt izmantots daudzas reizes. Tik reizes, cik mums ir šrifta saimes, un kādi vēl stili ir katrai pieslēdzamai šrifta saimei. Mums var būt viena šrifta saime ar 6 dažādiem stiliem, kas nozīmē, ka rezultātā mapītē: fonts mums būs 12 dažādi faili, un mums konstrukcija, CSS selektors: @font-face būs jāizmanto daudzas reizes aprakstot katru CSS selektora vērtību, kas katram stilam var mainīties, un rakstot pieslēdzamo failu nosaukumus iekš CSS parametra: src. */

/* Var gadīties, kad mums pasūtītājs pieprasa, lai mūsu lapā visas šriftu saimes un to stili būtu pieslēgti lokāli. Tādā gadījumā, mēs oficiālajā Google Fonts mājas lapā lejupielādējam uzreiz visas nepieciešamās šriftu saimes, un pieslēdzam tās, un nepieciešamos stilu veidus izmantojot konstrukciju, CSS selektoru: font-face, iekš CSS parametra: src norādot pieslēgšanas ceļu, un iekš pārējiem CSS stilu parametriem norādot nepieciešamās vērtības. */

/* Labam dizaineri  ir pienākums kopā ar maketu iedot līdzi šrifta failus, visus maketā izmantotos šriftus, stilus atsevišķos TTF formāta failos. Un mums atliek tikai tos konvertēt un pieslēgt. Bet realitātē šādi notiek reti, tādēļ mums ir jāzin kā mēs paši to varam izdarīt. */

/* Mēs no ārējiem resursiem, piemēra oficiālā Google Fonts varam pieslēgt šrifta saimes iekš HTML dokumenta, izmantojot šādu pieslēgšanas pierakstu, izmantojam tag: <link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;700&display=swap" rel="stylesheet" Šie visi dati nav jāraksta pašam. Mēs iekš Google Fonts oficiālās mājas lapas, izvēloties šriftu saimes un stilus varam izvēlēties pieslēgšanas veidu, vienu no veidiem, kas ir: izmantojot HTML dokumenta tag:  <link> vai izmantojot CSS kaskādes stilus un izmantojot selektoru: @import. Visas šīs iespējas mēs varam kopēt, nerakstot pašrocīgi. izvēlamies sev vēlamo pieslēgšanas veidu un kopējam. */

/* Tālāk mēs izmantojam citus CSS parametrus, kas atbild par teksta stilu, smagumu un fonta ielādi. Bet šos CSS parametrus mēs izskatīsim zemāk piemēros: */

/* Visi CSS parametri, kas skar tekstu ir sadalīti divās daļās: parametri, kas atbild par darbu ar šriftiem, un parametri, kas atbild par darbu ar tekstu. */

/* CSS parametri, kas atbild par darbu ar šriftiem: */

/* font-family: "Šrifta nosaukums", "Šrifta nosaukums", ..., šrifta tips */

/* Piemērs: */

/* .text {
	font-family: Arial, "Helvetica Neue", Helvetica, sans-serif;
} */

/* Atceramies: Iekš fonta lokālās pieslēgšanas mēs nenorādām vairākus šrifta nosaukumus, mēs norādām tikai vienu šrifta nosaukumu. Bet iekš šrifta izsaukšanas - lietošanas mēs rakstām šrifta nosaukumu un šrifta veidu. Tā kā parādīts augstāk piemērā. */

/* font-family - Instalē fontu saimi. Font-family: Vērtība var saturēt vairākus šrifta nosaukumus, tie var atkārtoties vairākas reizes. Tas ir domāts tādēļ, ka, ja dators neatrod šrifta saimi pēc pirmā nosaukuma, tas meklē pēc otrā nosaukuma utt, kamēr nonāk pie pēdējā, kas apzīmē šrifta tipu, kas tiek piemērots kā pēdējais variants, kad visi iepriekš minētie nosaukumi nav atrasti. Kā pirmo šrifta nosaukumu mēs vienmēr norādām to, kuru gribētu izmantot kā pirmo - labākajā gadījumā, un tikai aiz tā norādām šrifta nosaukumus, kurus piemērojam gadījumā, ja netiek atrasts šrifts pēc pirmā nosaukuma. */

/* Svarīgs nosacījums: Ja šrifta nosaukums sastāv no viena vārda, tad mēs varam to neliekt iekš pēdiņām "", bet, ja šrifta nosaukumā ir vairāk kā viens vārds, tad mums obligāti tas ir jāliek iekš pēdiņām: "" . Katru šrifta nosaukumu mēs atdalām ar komatu. */

/* Kā pēdējais pie šrifta nosaukumiem tiek norādīts šrifta tips. Tie mēdz būt dažādi. Pavisam kopā tie ir 5 tipi. Šrifta tips tiek izmantots gadījumā, ja dators neatrod visus iepriekš minētos šrifta nosaukumus. Tādā gadījumā dators piemēro jebkuru šriftu, kurš atbilst norādītajam šrifta tipam. */

/* Bet katru reizi ielāgot un atcerēties vai mums ir jāliek nosaukum iekš pēdiņām vai nav, ir grūti, tādēļ ērtāk ir: Vienmēr šrifta nosaukumus rakstīt iekš pēdiņām: "", jo tā mēs nekad nekļūdīsimies. */

/* Rakstot šriftu nosaukumus, mums beigās vienmēr jānorāda srifta tips. Kapēc? Tāpēc, ka, ja dators neatradīs vēlamo attēlojamā šrifta tipa, tad tas piemēros noklusēto šriftu, kas windows datoros ir: Times New Roman. Un tas ne vienmēr ir tas, ko mēs gribam, tādēļ svarīgi ir norādīt šrifta tipu, lai izbēgtu no šādām problēmām. Jo šādā veidā mēs kļūmes gadījumā, ja šrifti netiek atrasti pēc to nosaukuma jeb atrašanās vietas, mums tiks piemērots vismaz kaut cik līdzīgs šrifts, kas nesalauzīs visu mūsu lapas dizainu. Šāds pieraksts būs daudz drošāks nekā pieraksts, kur ir tikai viens vai divi šrifta nosaukumi. */

/* Visi CSS parametri, ko mēs mācāmies šinī lekcijā ir mantojamie CSS parametri. Ko nozīmē mantojamie parametri. tas ir: tad, kad kāds mūsu HTML dokumenta tag iekš sevis satur vēl dažādus tag, saucamā - ielikšanas sistēma. Tas nozīmē, ka ieliktie tags, piemēram visi tags iekš tag: <body></body> var kādus noteiktus CSS parametrus mantot no sava galvenā - vecāka parametriem. Šinī gadījumā tas nozīmē, ka tag: <h1></h1> mantos CSS parametru: font-family no sava vecāka tag: <body></body> */

/* Mantoti CSS parametri ir tie, kuru noteiktās vērtības ietekmē gan vecāku tag HTML dokumentā, gan ieliktos tag iekš kopējā vecāka tag. Mūsu piemērā tas nozīmē, ka noteiktie CSS parametri CSS selektoram: (HTML tag: <body></body>) body {} tiks pārmantoti tiem tags, kas ir iekš tag: <body></body, tag: <h1></h1> un tag: <p></p>.  */

/* Šodien mēs izskatām visus tos CSS parametrus, kas tiek mantoti no sava vecāka, bet tālāk mēs izskatīsim tādus CSS parametrus, kas netiek mantoti no sava vecāka, kas nozīmē, ka katram konkrētam HTML tag, kuram mēs gribam norādīt noteiktus CSS parametrus, mums tie ir jānorāda pa jaunu, jo tie netiek mantoti. */

/* Bet mantošanas princips darbojas tikai tad, ja mēs konkrētam CSS selektoram neesam to pārrakstījuši, piešķīruši tam citu parametra vērtību. Tādā gadījumā mantošanas princips nedarbosies. */

/* Ir noteikti CSS parametri, kuriem mēs kā vērtību varam norādīt: inherit, kas no Angļu valodas tulkojumā nozīmē: mantojams. Mēs tādā veidā varam noteikt, lai konkrēts CSS selektors manto kādu CSS parametru, kas ir jau noteikts vecākam, kopējam HTML tag, vecākam CSS selektoram. Mēs varam likt ieliktajam HTML tag mantot noteiktus cSS parametrus no sava vecāka. */

/* Katrs šrifts pieder pie noteikta šriftu tipa. pa visam tie ir 5 veidi, un tie ir:

 - serif: Fonti ar spraudeņiem (antīkie fonti), piemēram, šrifts: Times New Roman;
 - sans-serif: sasmalcināti, sadalīti šrifti (Fonti bez spraudeņiem vai groteska), piemēram, šrifts: Arial;
 - cursive: itāliskā (italic) tipa fonti, kad šrifts tiek attēlots slīprakstā;
 - fantasy: dekoratīvie šrifti;
 - monospace: Monoshirin fonti, tie ir mašīnrakstīšanas šrifti, kur katra simbola platums šādā saimē ir vienāds, piemēram šrifts: Courier.
*/

/* .text {
	font-family: "Poppins", sans-serif;
} */

/* Atceramies, ka CSS parametrs un tā vērtība: font-family ir mantojama, kas nozīmē, ka visi HTML elementi, kas ir iekš klases: text, mantos klases: text noteikto CSS parametru: font-family, jo tas ir mantojams CSS parametrs. Piemēram iekš klases: text esošais tag: <span></span> mantos CSS parametra: font-family vērtību. Lai labāk saprastu kā tas darbojās izveidojam mūsu HTML dokumentā tag: <span></span> iekš tag: <p></p>, kam ir klase: text. */

/* Neliels ieteikums. Lai mēs ātri varētu pievienot kādam tag noteiktu CSS parametru: font-family: "Poppins", sans-serif;, mums pietiek izveidot tehnisku CSS selektoru, tam pievienot konkrēto parametru un parametra vērtību. Un, gadījumos, kad mēs gribēsim, lai tas tiktu lietots iekš kāda HTML dokumenta elementa, mums iekš HTML dokumenta elementa klases nosaukuma jānorāda izveidotais tehniskais CSS selektora nosaukums. Piemērs: */

._poppins {
	font-family: "Poppins", sans-serif;
}

/* Lai saprastu kā šis piemērs darbojās, skatīt arī hTML dokumenta izveidoto klasi: text. Šādu pieeju mēs varam izmantot, lai ātri kādai klasei, kādam HTML dokumenta elementam ātri pievienotu noteiktus CSS parametrus. */

/* CSS parametrs: 
font-size: šrifta izmērs (px, %, em, rem). 
Nosaka šrifta izmēru konkrētam elementam, to var noteikt: pikseļos, procentos utt. Noklusētā CSS parametra vērtība ir: 16px. Šis ir noklusētais šrifta izmērs visam, kas atrodas iekš HTML tag: <html></html>, un tas arī tiek pārmantots uz visiem tags, kas ir iekš tag: <html></html>. Tas tiek uzstādīts pašam galvenajam HTML elementam, HTML root elementam: tag: <html></html>. Bet mēs katram elementam varam mainīt font-size parametra vērtību. Šis CSS parametrs arī tiek mantots visiem tag, kas ir iekš tag: <html></html>. */

/* Kādēļ ir tik svarīgi CSS parametru: font-size norādīt tieši iekš tag: <html></html>? Tādēļ, ka tālāk, kad sāksim strādāt mēs izmantosim CSS parametra vērtību mērvienībā: rem. 1 rem ir vienāds ar norādīto font-size vērtību tieši iekš tag: <html></html>. Tādēļ ir tik ļoti svarīgi to norādīt jau pašā sākumā nosakot iekš tag selektora body { font-size: 12px }. Mēs izmantosim kā pamata mērvienību tieši: rem, jo tas ir ļoti ērti, piemēram, lai mainītu visai lapai šrifta izmēru, mums pietiks nomainīt CSS parametra: font-size vērtību iekš selektora tag: body {}, un mums , ja izmantosim mērvienību: rem nomainīsies šrifta lielums visā mūsu lapā, attiecīgi norādītajai CSS parametra vērtībai. Tas tiks mainīts tikai tiem elementiem, kam būsim norādījuši CSS parametrā: font-size: ... toRem(). Atceramies, ka CSS parametrs: font-size ir mantojams, kas nozīmē, ka visi tags, kas ir iekš tag: <body></body> šo parametru manto, tas pāriet no vecāka uz visiem ieliktajiem elementiem. Un mums, ja gribam kādam no HTML dokumenta elementiem to mainīt, tad tas ir jānorāda style.css failā, bet to visu sīkāk mēs mācīsimies vēlāk. */

/* Labs lapu izstrādātājs strādā tieši ar mērvienībām: em, rem utt, bet mums kā iesācējiem ir jāiemācās profesionāļa līmenī strādāt ar mērvienību: px, ar pikseļiem, un tikai ar laiku mēs varam pāriet uz mērvienības: rem izmantošanu. Bet mēs varam izmantot pikseļus, rakstot tos iekš () iekavām, un priekšā rakstot toRem. Šāds pieraksts izskatās šādi: font-size; toRem(12);. Tāda pieraksta izmantošana ir laba darbības prakse. */

/* Visbiežāk mēs saskarsimies ar tādiem maketiem, kur šrifta lielums, tā pamatā izmantotā vērtība būs: 14px, tādēļ ir svarīgi CSS parametra: font-size noklusēto vērtību no 16px nomainīt uz 14px, lai atbilstu maketā norādītajai vērtībai. */

/*
Piemērs:
*/

h1 {
	font-size: 50px;
	font-family: "Gilroy", sans-serif;
}

.text {
	font-size: 20px;
}

/* Par cik mēs esam nodzēsuši visus pārlūka noklusētos CSS parametrus, mums tagad ir liela priekšrocība. Mēs varam katru elementu ietekmēt kā vien mēs vēlamies, stilizēt to pēc savas nepieciešamības, ievērojot to, kas ir maketā, mēs varam iespaidot katra elementa izskatu. */

/* CSS parametrs: font-style: nosaka šrifta stilu — parasts, kursīvais vai  slīpraksta šrifts. Šrifta stili pa visam ir 3 veidi. tie ir: */

/*
normal - Parasts šrifta stila attēlojums.
italic - Kursīvais šrifta stila attēlojums. 
oblique - Slīpraksta šrifta stila attēlojums. 
*/

/* Kursīvais un slīpraksta šrifta stils, lai cik tie būtu līdzīgi, tas nav viens un tas pats. Kursīvais - tas ir speciāls šrifta stils, kas imitē ar roku rakstītu tekstu, kas ir jālejupielādē jeb jāpieslēdz lokāli kā atsevišķs fails, bet slīpraksta šrifta stils ir, vienkārši jau esošs pieslēgts šrifts, kas ir nedaudz slīps pa labi un tiek izmantots tiem pašiem mērķiem kā kursīvais šrifts. Tomēr atšķirībā no kursīvā šrifta stila tas neizmanto dažādas groteska formas, kamēr kursīvais šrifts izmanto dažādas groteska formas, jo tas tiek veidots - zīmēts izmantojot dizainerus, un tas tiek veidots kā atsevišķs šrifta stils, un tas tiek apzīmēts pie šrifta nosaukuma pieliekot vārdu: italic. Bet slīprakstu mēs varam izveidot no jebkura šrifta veida vienkārši norādot: font-style: oblique; Bet, lai mēs varētu izmantot CSS parametra: font-style: italic; vērtību, mums ir jāpieslēdz kursīvais šrifts, izmantojot Google Fonts oriģinālo lapu jeb VS Code plugin: Google Fonts, jeb pieslēdzot to kā atsevišķu failu tā kā mācījāmies iepriekš. */

/* CSS parametra: font-style izmantošanas piemērs: */

.text {
	/* font-style: italic; */
}

/*
font-weight: nosaka šrifta biezumu, svaru. Šim CSS parametram var būt šādas vērtības, un tās ir:

100 - thin: - Tiek izmantots ļoti reti;
200 - extra light: - Tiek izmantots ļoti reti;
300 - lite: - Tiek izmantots vēl retāk;
400 - normal: - Tiek ļoti bieži izmantots;
500 - medium: - Tiek izmantots retāk;
600 - semibold: - Tiek izmantots retāk;
700 - bold: - Tiek ļoti bieži izmantots;
800 - extra bold: - Tiek izmantots vēl retāk;
900 - black: - iek izmantots ļoti reti;
950 - extra black: - Tiek izmantots ļoti reti;
*/

/* Noklusējuma CSS parametra: font-weight vērtība ir: 400 - normal. */

/* Piemērs: */

.text {
	/* font-weight: 700; */
}

/* Šie visi iepriekš izskatītie CSS parametri bija atbildīgi par darbu ar šriftu. Bet tagad paskatīsimies uz CSS parametriem, kas ir atbildīgi par darbu tieši ar tekstu. */

/* Strādājot ar projektu, ar maketu no figma, mums ir jācenšas maksimāli ievērot to, aks tur ir noteikts. ja tur ir noteikts kāds CSS parametrs, tā vērtība, tad mēs stingri to ievērojam, rakstot tieši tā kā maketā. bet, ja mums kāds CSS parametrs nav norādīts maketā, bet mēs skaidri zinām, ka tas konkrētā gadījum'ir jāizmanto, tad mēs to izmantojam. Ja mums maketā nav norādīts kādam jāizskatās lapas adaptīvam, lapas mobilajai un planšetes versijai, tad mēs izmantojam savas zināšanas un savu pieeju, un domājam paši, kā pēc iespējas labāk uztaisīt konkrētajai lapai adaptīva versiju. bet vairākums gadījumos dizainā jau ir uzzīmēts kādai ir jāizskatās lapas adaptīvajai versijai uz planšetes un mobilā telefona. Un mums atliek tikai to realizēt. */

/* Tālāk mēs strādāsim ar CSS parametriem, kas atbild par darbu ar tekstu: */

/*
CSS parametrs: color ir visizplatītākais veids, kā norādīt krāsas CSS, ir izmantot to heksadecimālās vērtības. Hex vērtības faktiski ir tikai atšķirīgs veids, kā attēlot RGB vērtības. Tā vietā, lai izmantotu trīs skaitļus no 0 līdz 255, izmantojiet sešus heksadecimālos skaitļus. Hex skaitļi var būt 0-9 un A-F. 
*/

/* Mūsu gadījumā color: #A2A6B0; ir dotās krāsas heksadecimālais skaitlis. Kad strādāsim ar projektiem, mums būs maketi, kur visas krāsas būs norādītas, mums atliek tikai no figma maketa nokopēt doto skaitli. Neaizmirstam, ka pirms krāsas heksadecimālā skaitļa jābūt restes zīme: #. */

/* CSS parametrs: color arī tiek mantots. Visi ieliktie elementi, tags manto parametru color no sava vecāka, no tag: <body></body> jeb arī no kāda cita tag, kam mēs esam noteikuši krāsu, un kur ielikti iekšā citi tag. Ieliktie tags mantos vecāka krāsu. Bet mēs jau zinām, ka mēs varam vajadzīgajam elementam, tag rakstot to caur CSS selektoru mainīt krāsu. */

/* Iekš VS Code redaktora ir lieliska iespēja: ja mēs uzrakstām kādas krāsas heksadecimālo skaitli, neaizmirstam priekšā likt: #, tad uzvedot ar peli uz tās, mums parādās krāsas paletes lodziņš, kur varam izvēlēties jeb kuru sev nepieciešamo krāsu. Un uzklikšķinot krāsu lodziņa augšējā daļā uz krāsas heksadecimālā skaitļa, mēs redzam, pilnu krāsas RGB kodu, bet noklikšķinot otro reizi mēs redzam krāsas heksadecimālo skaitli. Klikšķinot vairākas reizes lodziņa augšpusē mums parādās vairākas iespējas, kā mēs varam attēlot krāsas skaitli. Mēs varam izmantot parasto heksadecimālo skaitli, mēs varam izmantot krāsas rgb koda pierakstu, mēs varam izmantot krāsas hsl koda pierakstu, mēs varam izmantot krāsas hwb koda pierakstu. */

/* Pēdējās divas iespējas: hsl un hwb krāsas koda pieraksti tiek izmantoti ļoti reti. Mēs visbiežāk saskarsimies ar parasto - heksadecimālo krāsas koda pierakstu, rgb krāsas koda pierakstu, un rgba krāsas kodu pierakstu. kad izmantojam rgb jeb rgba krāsas kodu, mums krāsas skaitļi ir jāliek () iekavās, atdalot tos ar komatu, un pirms iekavām jāraksta rgb jeb rgba. */

/* kas ir Color RGB? CSS sistēmā krāsu var norādīt kā RGB vērtību, izmantojot šo formulu: rgb(sarkans, zaļš, zils) Katrs parametrs (sarkans, zaļš un zils) nosaka krāsas intensitāti no 0 līdz 255. */

/* Kas ir Color RGBA? RGBA krāsu vērtības ir RGB krāsu vērtību paplašinājums ar alfa kanālu, kas norāda krāsas necaurredzamību. RGBA krāsas vērtība tiek norādīta ar: rgba(sarkans, zaļš, zils, alfa). Alfa parametrs ir skaitlis no 0.0 (pilnībā caurspīdīgs) līdz 1.0 (pilnīgi necaurspīdīgs). Piemērs: rgba(255, 0, 0, 0.2); */

/* Krāsu attēlošanas variants: rgb nozīmē trīs krāsu kanālu sajaukšanos: rgb(red, green, blue), bet krāsu attēlošanas variants rgba nozīmē to pašu tikai tam vēl klāt nāk alfa kanāls, kas nosaka krāsas caurspīdīgumu: rgba(162, 166, 176, 0.4). */

/* Noklusētā krāsa, ko attēlo pārlūks atverot mūsu lapu ir: color: #000; Mums tiek attēlots vis teksts, kas ir lapā melnā krāsā. */

/* Kad mums kādas krāsas heksadecimālie skaitļi visi sakrīt, ir vienādi, tad mēs varam izmantot krāsas saīsinātu pierakstu, rakstot 3 simbolus aiz restes zīmes, piemēram: color: #fff; color: #000; */

/* Mēs varam no figma maketa nokopēt krāsas heksadecimālo skaitli, pārvērst to, izmantojot VS Code krāsu paleti, par krāsi rgba sistēmā, un pievienot tam caurspīdīgumu cik mums nepieciešams. */

/* Zemāk piemērā ir norādīti visi 5 iespējamie krāsu norādīšanas veidi, bet mēs visbiežāk izmantosim trīs veidus: krāsu pierakstu izmantojot heksadecimālo skaitli, krāsu pierakstu izmantojot rgb un rgba. */

.text {
	/* color: #a1a5b0; */
	/* color: rgb(162, 166, 176); */
	/* color: rgba(162, 166, 176, 0.4); */

	/* Šie krāsu noteikšanas veidi tiek reti pielietoti: */

	/* color: hsl(224, 9%, 66%); */
	/* color: hwb(224 63% 31%); */
}

/* CSS krāsu pielietošanas parametrs darbojas uz visiem elementiem, kas kaut kādā ziņā ir saistīti ar krāsas: color izmantošanu. */

/*
text-align: 
Teksta līdzināšanas CSS parametrs tiek izmantots, lai noteiktu teksta jeb rindas tipa elementa horizontālo līdzinājumu, izmantojot visu konkrētā elementa platumu. Tekstu var līdzināt pa kreisi vai pa labi, centrēt vai taisnot. Iespējamās CSS parametra: text-align: vērtības:
center - Teksta izlīdzināšana, izmantojot visu konkrētā elementa platumu, uz centru; 
justify - Teksta izlīdzināšana, izmantojot visu konkrētā elementa platumu, gan no tā kreisās puses, gan no tā labās puses. Lai pārlūks varētu izpildīt ši CSS parametru, tas starp vārdiem palielina atstarpes;
left - Teksta izlīdzināšana, izmantojot visu konkrētā elementa platumu, uz kreiso pusi; 
right - Teksta izlīdzināšana, izmantojot visu konkrētā elementa platumu, uz labo pusi; 
*/

/* Atceramies, ka elements tiek līdzināts izmantojot visu tā noklusēto jeb tam noteikto platumu. Ja bloka elementam nav noteikts platums, tad tas izmantos noklusēto pārlūka noteiktu platumu un stiepsies pa visu lapu. */

/* Mēs varam izmantot CSS parametru: text-align lai līdzinātu tekstu un visus rindas tipa objektus, kas var būt gan bloka elementi, gan vienas rindas elementi, piemēram HTML tag: <p></p>, kas ir bloka elements un hTML tag: <span></span>, kas ir rindas tipa elements. */

/* Mūsu piemērā elements, HTML dokumenta tag: <p></p> ir bloka elements un mēs tam neesam noteikuši konkrētu platumu, tādēļ, tas aizņem visu lapas platumu. Un, kad mēs izmantojam CSS parametru: text-align: center, mēs redzam, ka mūsu elements, kas ir bloka elements un aizņem visu lapas platumu, ir izpleties, no lapas centra uz kreiso un labo pusi. Līdz ar to mēs varam teikt, ka mūsu elements ir centrēts. */
.text {
	/* text-align: center; */
}

/* Noklusētā CSS parametra: text-align vērtība ir: left; jo mēs rakstām no kreisās puses uz labo pusi. */

/* Bet atceramies: Mēs nevaram ņemt bloka elementu un censties to nolikt centrā, jo tam ir jau noteikta platība, un mēs gribēsim to nolikt centrā, tad mums nekas nesanāks, ja mēs izmantosim CSS parametru: text-align: center bloka elementam. */

.image {
	/* text-align: center */
}

/* Šis ir nepareizs CSS parametra pielietojums, jo tag: <img> ir bloka elements un mēs to nevaram nolikt centrā izmantojot CSS parametru: text-align: center. Lai panāktu, ka bloka elements nostājās centrā, mum sir jāizmanto citi CSS parametri, ko mēs mācīsimies vēlāk. */

/* Šis CSS parametrs arī ir pārmantojams, kas nozīmē, ja vecākam ir noteikts šis CSS parametrs, tad arī visiem elementiem, kas ir iekš vecāka elementa tiks piemērots šis CSS parametrs. */

/* CSS parametrs līdzina kaut ko, kas ir iekšā, teksts, saite, virsraksts, bet mēs nevaram līdzināt attēlu, jo tam nav iekšēja satura. */

/* Bet mēs varam ļoti vienkārši iziet no šīs situācijas ieliekot tag: <img> iekš tag: <p></p>, un visam tag: <p></p> pielietot CSS parametru: text-align: center. Lia to panāktu konkrēti mūsu piemērā, mums ir nedaudz jākoriģē HTML dokumenta tag: <p></p> saturs, teksts. Piemērs:  */

.text {
	/* text-align: center; */
}

/* Atceramies, ka tag: <img> ir bloka rindas elements, un tieši tādēļ mēs tai, ja tā atrodas iekš vecāka tag, varam pielietot CSS parametru: text-align: center; */

/* Web lapu izstrādē ir fundamentālas zināšanas, kas mums ir jāzin obligāti, un ir ieteicamās zināšanas, kas pēc mūsu izvēles mums var būt, bet var arī nebūt. */

/* Līdz šim visi izskatītie CSS parametri bija pieskaitāmi pie fundamentālām - pamatzināšanām, kam ir jābūt, ja gribam strādāt par Web Pages Developer, bet ir arī ieteicamās zināšanas. Nākošais CSS parametrs, ko mēs izskatīsim pieder pie ieteicamajām zināšanām. Tās zināšanas, kas ir ieteicamas, mēs varam nepaturēt galvā, jo jebkurā brīdī mēs varam tās atrast internetā. Bet fundamentālās - pamata zināšanas mums ir jāzin no galvas. Mums tās ir vienkārši jāzin */

/* Ieteicamās zināšanas neprasa no mums dziļu iedziļināšanos konkrētā lietā, jo mēs tās vienmēr varam atsvaidzināt, bet fundamentālās - pamatu zināšanas prasa dziļu iedziļināšanos tēmā. */

/* Apgūstot fundamentālas - pamata zināšanas mums tām ir jāvelta daudz laika, un pamatīgi jāiedziļinās un daudz jāpraktizējas, bet ieteicamās zināšanas mums ir jāsaprot tikai virspusīgi, jo jebkurā brīdī mēs varēsim tās atsvaidzināt, un tās neprasa daudz laika ieguldījumu, dziļu iedziļināšanos un ilgu praktizēšanos. */

/* Fundamentālās - pamata zināšanas ir ļoti svarīgas, jo bez tām mēs nevaram strādāt, bet bez ieteicamajām zināšanām mēs varam strādāt, jo tās nav tik svarīgas kā fundamentālās zināšanas. */

/* Ieteicamās zināšanas mums ir nepieciešams zināt tikai virspusējā līmenī, jo, ja mums būs 10 reizes tās jāpielieto, tad mēs tās pielietojot, jau automātiski 11 reizē zināsim no galvas, atcerēsimies kapēc un kad tās bija jāpielieto, kā piemēram, CSS parametra izmantošana: text-decoration: Mēs, kad būsim to 10 reizes izmantojuši, zināsim jau no galvas kādas tam ir vērtības, un kuros gadījumos mums tās ir jāpielieto. */

/* Bet nākošajos mājas darbos mēs pielietosim gan fundamentālās zināšanas, gan ieteicamās zināšanas, tādēļ mums ir virspusēji jāpārzina arī tās lietas, kas ir pieskaitāmas pie ieteicamām zināšanām. */

/* Mums iegūstot jaunas zināšanas vienmēr ir jāizvērtē to prioritātes - cik svarīgi ir katru no tām zināt. Vai kādas zināšanas ir ļoti svarīgas - fundamentālas, vai mazāk svarīgas - ieteicamās zināšanas. */

/* Piemēram: CSS parametra: text-align zināšanas ir daudz svarīgākas, nekā CSS parametra: text-decoration zināšanas. */

/* Līdz šim mēs izskatījām CSS parametrus, kas pieder pie fundamentālām - pamata zināšanām, bet tagad izskatīsim CSS parametrus, kas pieder pie ieteicamajām zināšanām, kurus nav tik svarīgi zināt. */

/*
text-decoration
Pievieno teksta līnijas noformējumu pasvītrotas teksta veidā, nostrīpota teksta veidā, pievieno augšējo līniju tekstam, pievieno tekstam mirgošanas efektu.
Šo CSS parametru mēs varam izmantot vienam elementam vairākas reizes, nosakot dažādas CSS parametra: text-decoration vērtības,atdalot tās vienu no otras ar atstarpi. Mums nav katru reizi jāraksta CSS parametra nosaukums, mēs pievienojam tikai vērtības. Šis CSS parametrs arī ir mantojams. Tas var saturēt šādas vērtības: 
line-through - Iegūstam nostrīpotu tekstu.
overline - iegūstam tekstu ar augšējo līniju.
underline - iegūstam pastrīpotu tekstu. 
none - Atceļ visus teksta efektus, tai skaitā arī atceļ saites, tag: <a></a> pastrīpojumu, kas tiek izmantots, izmantojot pārlūka noklusētos CSS parametrus. Piemērs: 
*/

.text {
	text-decoration: none;
}

a.link {
	text-decoration: underline;
}

.text span {
	text-decoration: underline;
}

.text span ~ span {
	text-decoration: line-through;
}

/* Kur mēs varam pielietot CSS parametru: text-decoration: line-thought? Kā piemēru, mēs to bieži varam redzēt interneta veikalu mājas lapās, kur piemēram izmantojot HTML tag: <span></span> tiek jauna cena, un mums ir vajadzīgs veco cenu nostrīpot. Tieši šādos gadījumos mēs izmantojam CSS parametru: text-decoration: line-through; */

/*
text-shadow: Uzbūve:
text-shadow: horizontālais izvietojums vertikālais izvietojums izmērs krāsa;
text-shadow - Pievieno ēnu, bet TIKAI tekstam.
Piemērs:
text-shadow: 1px 1px 1px #000;
*/
h1 {
	text-shadow: 4px 4px 7px #000;
}

.text {
	text-shadow: 3px 3px 5px #555;
	/* text-shadow: -5px -5px 1px #000; */
}
/* Vienam tekstam var būt vairākas ēnas. Mēs tās pierakstām atdalot ar komatu, piemērs: 
text-shadow: 3px 3px 5px #555, 3px 3px 5px #000; */

/* Krāsas pierakstu veidi izmantojot heksadecimālo skaitli vai izmantojot rgb() ir viens un tas pats, tikai mums ir divi kā mēs varam pierakstīt kādu krāsu. Bet to nozīme ir pilnīgi vienāda. Bet pēc nerakstīta likuma ir pieņemts izmantot tieši heksadecimālo krāsas pieraksta veidu. */

/* Krāsu pierakstus un variantus mēs varam izmantot šeit un visos citos ar krāsu saistītos CSS parametros neierobežoti. Mēs varam izmantot rgb krāsas, rgba - krāsas, kam ir alfa kanāls - caurspīdīgums. Šeit mūsu fantāzijai nav robežu. */

/*
text-transform
УTeksta pārveidošanas CSS parametrs norāda, kā elementa tekstā lietot lielos burtus. To var izmantot, lai teksts būtu rakstīts ar lielajiem vai mazajiem burtiem, vai lai katrs teksta vārds būtu ar lielo burtu.
capitalize  - Katra vārda pirmais simbols tiks attēlots ar lielo burtu, bet atlikušie vārda simboli netiks mainīti;
lowercase - Visi teksta simboli tiek attēloti ar mazajiem burtiem (apakšējā reģistrā); 
uppercase - Visi teksta simboli tiek attēloti ar lielajiem burtiem (augšējā reģistrā); 
none - Vārda simboli netiek mainīti. Arī to reģistrs netiek mainīts;
Piemēri: 
*/

.text {
	text-transform: none;
}

/* Mums var gadīties situācija, kad dizaineri maketā uzreiz raksta ar lielajiem burtiem. Iztēlosimies to mūsu piemērā, pievienojot HTML dokumentam nelielu konstrukciju, atkārtojot trīs reizes konstrukciju: <li></li>, izmantojot šādus tags: 
<nav>
<ul>
<li>
<a href="#">ES ESMU PUNKTS</a>
</li>
</ul>
</nav>
*/

/* Šādā gadījumā mēs ņemsim no figma maketa un nokopēsim tekstu, kas būs rakstīts ar lielajiem burtiem. bet ĻOTI svarīga rekomendācija: Kad strādājam ar CSS stiliem, tekstam, kas rakstīts augšējā reģistrā norādīt CSS parametru: text-transform: uppercase;, jo var gadīties, ka kāds, kas strādās tālāk ar mūsu izstrādātu lapu tekstu var mainīt, pierakstot to apakšējā reģistrā - ar mazajiem burtiem. Un lai izbēgtu no iespējamā lapas izstrādes bojājuma, mēs tekstam, kam vienmēr jābūt ar lielajiem burtiem norādām CSS parametru: text-transform: uppercase; */

/* Piemērs: */
.menu a {
	text-transform: uppercase;
}

/* Un ATCERAMIES: Ka tieši šādi lapas izstrādes itkā sīkumiņi, arī atšķir profesionālu Web Pages Developer no parasta jeb iesācēja Web Pages Developer. Šo sīkumu zināšana un izmantošana savā darbā, piešķir mums profesionāļa statusu. Profesionālis izstrādā lapu tā, ka mainot lapas saturu, TIEK saglabāta izstrādes struktūra, un tiek saglabāts lapas dizains. */

/* Šiem itkā sīkumiņiem ir jāpievērš īpaša uzmanība, jo tieši to zināšana un izmantošana atšķir profesionāli no neprofesionāļa. Jo tieši šie sīkumiņi ietekmē mūsu darba samaksu. Zinot un izmantojot visus sīkumiņus, kas nodrošina lapas struktūras saglabāšanu un lapas dizaina saglabāšanu, ja mainās lapas saturs, nodrošina to, ka mēs par savu darbu varam prasīt lielu samaksu. Ja neprofesionālis par savu darbu saņem 100$, tad mēs būdami profesionāļi par savu darbu varam prasīt jau 400$. */

/* Iemācīties un pielietot šīs prasmes neprasa lielas pūles un liela laika ieguldījumu, bet nodrošina mums labu peļņu. */

/*
line-height: iestata teksta līnijas augstumu. To parasti izmanto, lai iestatītu attālumu starp teksta rindiņām. Bloka līmeņa elementiem tas norāda minimālo līniju augstumu elementā. 
Piemērs:
*/

.text {
	line-height: 1.5;
}

/* CSS parametrs: line-height var tikt norādīts dažādās CSS mērvienībās: pikseļos - px, procentos - %, utt, bet ieteicam ir to norādīt tieši izmantojot procentus: %. Mēs varam vienkārši iekš parametra: line-height: 1.2 norādīt skaitli bez procentu zīmes. Jo, ja nav norādīta cita mērvienība, tad dators pēc noklusējuma nolasīs uzrakstīto skaitli tieši procentos. Skaitlis: 1.2 nozīmē: 120%. */

/* Kādēļ tieši CSS parametra: line-height ir ieteicams norādīt tieši procentos? Tādēļ, ka tieši ar procentu izmantošanu ir viegli saprast kāds teksta līnijas augstums tiks izmantots, jo tas tiek automātiski noteikts balstoties uz CSS parametra: font-size noteikto vērtību, aks mūsu gadījumā ir: 16px. Tas nozīmē, ka teksta līnijas augstums mūsu gadījumā būs 150% no 16px. */

/* ATCERAMIES, ka jebkuru CSS parametru mēs izmantojam tikai konkrētam mērķim. Ja tas ir paredzēts rindas elementu un teksta līnijas atstarpes noteikšanai, tad mēs to izmantojam tieši tam un nekam citam. Tas attiecas uz visiem CSS parametriem, principā uz VISU, kas ir saistīts ar programmēšanu, datoru saziņas valodām. Aī HTML tags izmantošanu un JavaScript koda pielietošanu un funkciju rakstīšanu. */

/* Katram uzdevumam, lai to realizētu ir speciāli tieši Tam paredzētas metodes, kuras mums ir jāizmanto, lai izpildītu konkrētu uzdevumu. Jo tieši šāda principa ievērošana nosaka to, ka mēs esam profesionāļi. */

/* Atceramies, ka programmēšanā skaitļus mēs neatdalām ar komatu, bet gan ar PUNKTU, jo dators neprot nolasīt 1,2; Tādēļ mums ir jāpieraksta šādi: line-height: 1.2; */
/* CSS parametrs: line-height tiek izmantots ļoti bieži, tādēļ mums ir jāzin kā to pielietot savā darbā. */

/* Kad mēs rakstām Style RESET mums iekš selektora: body {} ir jānorāda: line-height: 1, kas nozīmē, ka mēs nosakām, ka teksta līnijas augstums tiek atstatīts uz šrifta noklusēto līnijas augstumu. Un vēlāk strādājot ar tekstu varam mainīt teksta līnijas augstumu. */

/* CSS parametra: line-height: 1;, vērtība: 1 nozīmē 100% no šrifta izmēra, ja mums šrifta izmērs ir: font-size: 16px, tad attiecīgi, ja mēs norādām: line-height: 1, tad, tas nozīmē tieši to pašu līnijas platumu kāds izmērs ir šriftam. */

/* Bet ne vienmēr līnijas augstums ir vienāds ar šrifta augstumu. Mums var būt maketā norādīts cits līnijas augstums. Un mums tas ir jāievēro, jāpielieto savā projektā, jo mums vienmēr jācenšas cik vien iespējams, ievērot visu, kas ir lapas dizaina maketā. */

/* Bet mēs nevaram vienmēr uzticēties tiem CSS parametriem, kas ir norādīti maketā iekš katra elementa inspect sadaļas. Mums izstrādājot lapu ir jāsalīdzina arī ar acīm iegūtais rezultāts, jo vienmēr pastāv iespēja, ka dizaineris ir kļūdījies, gribējis savādāk. */

/*
letter-spacing: Nosaka atstarpes intervālu starp simboliem (starp burtiem). 
Piemērs: 
*/

.text {
	letter-spacing: 1px;
}

/*
word-spacing: Nosaka atstarpes intervālu starp simboliem (starp vārdiem). 
Piemērs: 
*/

.text {
	word-spacing: 10px;
}

/* Mums ir jāzin par tādiem CSS parametriem: letter-spacing un word-spacing, jo reizēm dizaineri, izstrādājot maketus, tos izmanto, tādēļ mums ir jāprot tos pielietot savā darbā. */

/* Šīe abi CSS parametri tiek izmantoti reti, sevišķi CSS parametrs: word-spacing, bet tomēr - šad un tad tie ir jāizmanto, jo dizaineris zīmējot mums maketu ir tos izmantojis. */

/* Svarīgi ir: NEJAUKT CSS parametru text-align: justify ar word-spacing, jo word-spacing izmanto katram vārdam vienādu, mūsu noteikto atstarpi, bet: text-align: justify katram vārdam izmanto dažādas atstarpes. */

/*
text-indent: CSS teksta atkāpes parametrs, kas iestata teksta bloka pirmās rindas atkāpi. To var definēt ar pozitīvām vai negatīvām vērtībām. Ja vērtība ir pozitīva, pirmā teksta bloka rinda tiks novirzīta pa labi. 
Piemērs:
*/

.text {
	text-indent: 50px;
}

/* Lai labāk saprastu kā šis CSS parametrs darbojās, mums ir jāizslēdz CSS parametrs: text-align: center; */

/* Nosakot šo CSS parametru: text-ident: 50px; mēs redzam, ka mūsu pirmā teksta bloka rinda tiek novirzīta uz labo pusi pa 50px. */

/* Šo CSS parametru: text-ident vēl sauc par: Grāmatas rindkopas atstarpi (Sarkanā līnija), jo tas mums sniedz iespēju tekstu attēlot tieši tā, kā tas tiek darīts grāmatās, katru rindkopu sākot, ievērojot noteiktu pirmās rindas nobīdi pa labi. */

/* Microsoft Word tiek izmantots šāds teksta formatēšanas veids, kad pirmā teksta bloka rinda tiek attēlot ievērojot noteiktu nobīdi pa labi. */

/* Šis CSS parametrs tiek izmantots ļoti reti, bet reizēm dizaineri to izmanto, tādēļ mums par tā esamību un pielietošanas iespējām ir jāzina. */

/* Tālāk seko CSS parametrs, kas pieder pie fundamentālām zināšanām, ko ir ļoti svarīgi zināt un prast pielietot. Tas tiek izmantots ļoti bieži. */

/*
white-space
CSS atstarpes parametrs, kas palīdz kontrolēt, kā elementa tekstā uzvedās atstarpes un rindiņu pārtraukumi. Tas kontrolē atstarpes uzvedību starp vārdiem. Pārsvarā tam tiek izmantotas vērtības: 
nowrap; kas nozīmē, ka mēs aizliedzam pārnest tekstu jaunā rindā. Tādā veidā vis teksts tiek attēlots vienā rindā, tam nav iespējas tikt lauztam. Arī, tad, ja mēs mainām ekrāna platumu. Mūsu teksts vienalga paliek vienā rindā, mums lapā izveidojas horizontāls scroll, un tā jau ir nopietna problēma. Tādēļ ar CSS parametra white-space: nowrap izmantošanu jābūt ļoti uzmanīgam. Jo mēs, kad strādāsim ar lapas adaptīvu, un vēlāk ar dažādām ierīcēm, šis CSS parametrs var būtiski apgrūtināt mums darbu, jo teksta apjoms var mainīties. Bet dažreiz, retās situācijās mums var rasties vajadzība iecementēt teksta atstarpes, un ar laiku, kad mums jau būs pieredze mēs jau zināsim kuros gadījumos tomēr var tikt izmantots CSS parametrs: white-space: nowrap. 
Šī CSS parametra noklusētā vērtība ir: 
normal; kas nozīmē, ka teksts laužas, kad tas neietilpst ekrānā, pie atstarpes palielināšanas jeb samazināšanās, gadījumā, kad mainās ekrāna lielums. 
*/

.text {
	/* white-space: nowrap; */
}

/* Šis ir minimālais CSS parametru klāsts, kas mums ir jāzina, lai mēs varētu strādāt ar šriftiem un tekstu. */
