
/* Šinī lekcijā mēs izskatīsim jaunu tēmu: pseido elementi un pseido klases. */
/* Sākumā atceramies kā pieslēgt šriftus: */

@import url("https://fonts.googleapis.com/css?family=Poppins:regular,700&display=swap");


@font-face {
	font-family: "Gilroy";
	src:
		url("../fonts/Gilroy-Regular.woff2") format("woff2"),
		url("../fonts/Gilroy-Regular.woff") format("woff");
	font-weight: normal;
	font-style: normal;
	font-display: swap;
}

@font-face {
	font-family: "Gilroy";
	src:
		url("../fonts/Gilroy-Bold.woff2") format("woff2"),
		url("../fonts/Gilroy-Bold.woff") format("woff");
	font-weight: bold;
	font-style: normal;
	font-display: swap;
}

body {
	font-family: "Gilroy", sans-serif;
	font-size: 16px;
	font-weight: 400;
}

/*
.main {
	padding: 30px 0px 0px 0px;
} */

/* Atceramies no iepriekšējās lekcijas par BEM metodoloģiju, ka mēs nedrīkstam klases nosaukumos veidot hiarhiju. Lai novērstu šādas situācijas, mēs varam vienkārši apgriezt bloka klases nosaukumu otrādi, un turpināt strādāt tālāk pirmajā klases nosaukuma daļā lietojot bloka nosaukumu. */

/* Lai labāk saprastu kā tieši tas izskatās un kā mums ir jārīkojas, izveidojam HTML dokumentā pareizu piemēra pierakstu. */

/* Mēs izmantojam pa visam vienkāršu risinājumu apgriežot bloka klases nosaukumu otrādi. */

/* BEM metodoloģija paredz, ka mēs katram HTML dokumenta tegam dodam klases nosaukumu. Kā arī iekš CSS stiliem mēs neizmantojam kas kaskādes stilus, bet vēršamies tieši pie klašu selektoru nosaukumiem un tiem rakstam stilus. */

/* Atceramies, kas ir kaskādes stili, pierakstām piemēru: */

/* .block a {

} */

/* Šādu pieeju BEM metodoloģijā nerekomendē izmantot. Mums jācenšas no šādām situācijām izvairīties dodot katram tegam klases nosaukumu. */

/* Pareizais risinājums, kas jāievēro strādājot pēc BEM metodoloģijas: */

/* .list {
}

.list__item {
}

.list__link {
} */

/* Mums jau tagad sākumā ir jāpierod katram elementam rakstīt nosaukumus pēc BEM metodoloģijas. */

/* Pēc BEM metodoloģijas nav ieteicams izmantot atsevišķus CSS failus ar stilu atiestatīšanu, tādus kā normalize un null. Tieši kādēļ tā nav zināms. Bet mēs varam izmantot savu, šinī kursā ar rokām rakstīto CSS style reset. Tas nav nepareizi. */

/* Atceramies: Ārējās atstarpes mēs nevaram izmantot blokam, bet varam izmantot bloka elementam. Atceramies kapēc? Jo bloks ir neatkarīgs, un mums jādara vis, lai tas paliktu neatkarīgs, tādēļ mēs tam nedrīkstam izmantot ārējo atstarpi: margin: 0 0 30px 0. */

/* Atceramies, ka izveidojot kādu bloku HTML dokumentā, strādājot ar to tālāk mums jāievēro, lai nosaukuma pirmā daļa tiktu mantota no bloka nosaukuma. Piemērām: Bloks: about; about__title; about__text. Atceramies, ka mēs varam izmantot arī Mix nosaukumus, BEM elementiem pievienojot blokus vai tehniskās klases. Atceramies, ka tehniskās klases nosaukuma priekšā ir jāliek zīme: _; Piemēram: _container. */

/* Mums var gadīties tāda situācija, kad mums nav ieteicams rakstīt klases nosaukumu. Piemēram, ja mums ir kastīte - bloks ar klasi "text", iekš tā mums ir 2-3 paragrāfi, kuriem esam iedevuši klasi: "text__item". Nākošais, kas aiz mums strādās caur lapas admin, php, kādā wordpress būs neapmierināts, jo viņš mainīs lapas saturu, un šinī gadījumā viņam būs jāveido paragrāfi rakstot klašu nosaukumus. Un to neviens negribēs darīt. Tādēļ, ja mums ir jau izveidota kastīte, kur būs teksts - paragrāfi, tad mēs nerakstam tiem klases. */

/* Šeit mums rodas viedokļu - likumu nesakarība, jo kā zinām no BEM metodoloģijas mums ir visiem elementiem jādod klašu nosaukumi, bet no praktiskā viedokļa ir situācijas, kad to nav vēlams darīt. */

/* Šādai situācijai ir ļoti vienkāršs risinājums. Mēs kastītei rakstām klasi, bet paragrāfiem nerakstām. Izmantojam CSS kaskādes stilus. Kas itkā no BEM metodoloģijas puses nav ieteicams, bet šādās situācijās mēs to varam darīt. */

/* Ar laiku, kad mums būs jau pieredze, mums būs jāprot atdalīt kontentu, kas noteikti tiks mainīts, nedot tam klašu nosaukumus. Bet pārējam lapas saturam, kas paliks nemainīgs rakstam klašu nosaukumus. Tagad šo saprast mums ir grūti, bet ar laiku strādājot praktiski, uzreiz būs skaidrs, kam rakstīt klašu nosaukumus, un kam labāk ne. */

/* Bet šī saprašana ir sarežģīta un tas jau ir eksperta līmenis. Tagad mēs varam tikai minēt, kurā vietā lapā saturs tiks mainīts un, kur netiks mainīts. Ja mēs strādājam komandā, kur ir arī backend speciālists, tad ir daudz vieglāk, jo mēs no klienta - pasūtītāja varam visu smalki uzzināt, apspriest ar backend speciālistu un realizēt savā darbā. */

/* Lai mēs šobrīd pārāk nesaspringtu, mēs rīkojamies tā kā mums māca BEM metodoloģija, dodam katram elementam klases nosaukumu. Kad notiks lapas integrācija realitātē, tad mēs varēsim saprast kur un ko nedaudz pamainīt, lai backend speciālistam būtu vieglāk. */

/* Ja mums gadīsies izveidot kādu klasi, kas netiks izmantota, tas nekas, jo vēlāk mēs rakstīsim stilus SCSS formātā, strādāsim ar Gulp un tie nodrošinās, ka nekas lieks mūsu lapā nepaliek. */

/* Mums var rasties situācija, kad mums jāizmanto BEM klašu nosaukumi - Mix. lai uzskatāmāk saprastu, kāda ir situācija, pierakstam piemēru iekš HTML dokumenta. izmantojam BEM metodoloģijas Mix: main__container container; Šeit vēršamies tieši pie container, piemērs: */

/* .container {
	max-width: 1170px;
} */

/* Turpinām piemēru iekš HTML dokumenta ievērojot BEM metodoloģiju, pareizi rakstot klašu nosaukumus. Izveidojam vienkārši jaunu bloku. Par cik mēs atvērām jaunu bloku iekš HTML dokumenta, nākošajiem tanī esošajiem bloka elementiem ir jāmanto bloka nosaukums. Skatamies HTML dokumentā. */

/* Bet ir viena būtiska lieta. Mēs itkā atrisinājām situāciju, bet atceramies, ka bloks ir neatkarīgs un mēs tam nevaram izmantot, piemēram: margin; bet ja piemēram mums vajag pielietot citus CSS parametrus, piemēram: color jeb font-size, tad šādi mēs varam rīkoties. */

/* Lai mēs varētu atrisināt problēmu, kad gribam izmantot ārējo atstarpi, mums ir jāizveido bloka modifikators. Lai labāk saprastu, skatamies HTML dokumentu. Mēs pievienojam blokam modifikatoru ierakstot: container-margin. Tagad mēs no CSS faila varam pie tā vērsties un dot tam CSS parametrus kādus mums vajag. Tā kā piemērā: */

/* .container_margin {
	margin: 0 auto;
} */

/* Redzam pēc šiem piemēriem, ka problēmu mēs esam atrisinājuši, bet trūkums ir tāds, ka mums katru reizi, kad gribēsim kur izmantot šīs klases, blokus mums tās katru reizi jāpievieno un tas nav ļoti ērti. Bet kamēr mēs esam iesācēji, mēs daram tieši šādi. */

/* Tieši tādēļ, ka šādi nav ērti strādāt tiek izmantotas tehniskās klases, piemēram: _container. Izskatām piemēru, kur ir sakārtotas visas BEM metodoloģijas klases tā, lai mums būtu ērti, un arī, lai citiem būtu saprotams mūsu kods. */

/* Atstājam arī iepriekšējo BEM metodoloģijas klašu nosaukumu veidošanas piemēru, lai, ja mums radīsies šāda situācija, mēs zinātu kā varam to atrisināt. */

/* Šo konstrukciju mēs varam izmantot visur, kur mums lapā nepieciešams. Izveidojam HTML dokumentā bloku about un iekš tā vienkārši iekopējam iepriekšējā piemēra rindu. */

/* Sākam jauno lekcijas tēmu: pozicionēšanu. Izslēdzam visu aktīvo kodu HTML dokumentā, lai mēs uzskatāmāk saprastu tēmu. Izslēdzam aktīvo kodu arī iekš CSS. */

/* Izveidojam iekš HTML dokumenta bloku un bloku ar elementu, un trīs elementus ar modifikatoriem. Mācamies jau tagad pareizi rakstīt klašu nosaukumus, pēc BEM metodoloģijas. */

.block {
	/* Noklusējuma vērtība */
	/* position: static; */
	/* nevaram izmantot:
	top
	right
	bottom
	left
	z-index */
}

/* .block__item {
	padding: 15px;
	color: #fff;
	font-size: 20px;
	text-align: center;
	margin: -20px 0 0 0;
}

.block__item_color-brown {
	background-color: #794f45;
	position: relative;
	z-index: 2;
}

.block__item_color-purple {
	background-color: #77608d;
}

.block__item_color-green {
	background-color: #7a956b;
} */

/* Kas tad ir pozicionēšana? Pozicionēšana ievērojami paplašina mūsu iespējas strādājot ar lapas elementiem. Mēs iegūstam jaunu rīku, kā mēs varam darboties ar lapas elementiem, bet tas nenozīmē, ka tagad mums tas jāizmanto visur, jo atceramies par pamatlikumu, kas jāievēro kad izstrādājam lapas, lapai jābūt noturīgai - uzticamai. Atceramies - lapas saturs var mainīties. */

/* Pozicionēšana ir ļoti jaudīgs instruments ar plašām izmantošanas iespējām, bet tam ir liels trūkums: Tas padara mūsu lapu nenoturīgu - neuzticamu veicot izmaiņas, tādēļ to lietojot jābūt ļoti piesardzīgam. */

/* Mēs iegūstam jaunu CSS parametru: position, kas maina pozicionēšanas tipu. Rakstam to iekš mūsu piemēra. Šis parametrs ir kaut kur līdzīgs parametram: display, kur mēs strādājam ar elementu tipiem. */

/* CSS parametrs: position arī ir sava veida pārslēdzējs, tā pat kā: display, tikai tas pārslēdz elementa pozīciju. Elementam jeb tā vecākam, iekš kā konkrēti ir šis elements. */

/* Atšķirībā no CSS parametra: display, parametrs: position darbojas ar visa tipa elementiem, gan rindas tipa, gan bloka-rindas tipa, gan bloka elementiem. */

/* CSS pozicionēšanas parametrs: position: relative nav mantojams, tas nepārmantojas uz citiem lapas elementiem - objektiem. */

/* Izskatīsim kādas vērtības ir CSS parametram: position. Pirmā ir static, kas ir noklusējuma vērtība. Šis parametrs ir katram lapas objektam, mēs vienkārši to nerakstam, neredzam, jo tas jau iet pēc noklusējuma. Mēs nevaram pie šādas vērtības neko darīt ar objektu. Mēs nevaram izmantot: right, left, top, bottom un z-index. */

/* CSS parametram: position static ir sešas vērtības, kas uzskaitītas augstāk piemērā. Z-index arī ir pozicionēšanas CSS parametrs. */

/* Kur mums var noderēts CSS parametrs: position: static. Tas mums var noderēt, ja mums kādam objektam sākotnēji ir cita position vērtība un kādā brīdī, piemēram: pie lapas adaptīva mēs gribam mainīt CSS parametru no cita uz position: static. */

/* Izskatām nākošo CSS parametra: position vērtību, rakstām to mūsu piemērā. Position: relative maina elementa atrašanās vietu no tā sākotnējā stāvokļa kodā. Sākotnējās atrašanās vietas. Šeit mēs varam izmantot CSS parametrus: left, right, top, bottom, z-index. Mūsu objekts tiek nobīdīts uz vienu vai otru pusi, tā kā mēs esam norādījuši. Atceramies, ka tas nobīdās atkarībā no sava sākotnējā atrašanās vietas stāvokļa. */

/* Izmantojot CSS parametru: position: relative mēs mainām pozicionēšanas tipu. Mēs varam jau brīvi rīkoties ar objektu norādot citus pozicionēšanas parametrus. */

/* Pozicionēšanas parametrs: z-index pēc noklusējuma ir ar vērtību: auto. Bet mēs to varam mainīt, atkarībā, kuru elementu gribam paslēpt, kuru parādīt. Iekš pozicionēšanas parametra: z-index vērtībām mēs varam likt skaitļus no 1 un cik vien mums vajag tālāk, ja mums ir daudzi objekti, kam jāizmanto šis pozicionēšanas parametrs. */

/* Lai mēs uzskatāmāk saprastu kā darbojās CSS parametrs: position: relative, veicam nelielas izmaiņas mūsu kodā, pievienojot negatīvu ārējo atstarpi. Bez šī parametra mēs redzam, ka mūsu augšējie bloki nedaudz uzbīdās viens otram virsū, bet izmantojot CSS parametru: position: relative mūsu bloks, kam mēs to izmantojam kļūst svarīgāks, redzamāks. */

/* Kādēļ bez CSS parametra: position: relative mūsu bloki tieši uzbrauc tādā secībā viens uz otra. Tādēļ, ka tieši tā tie mums ir pierakstīti kodā, gan HTML dokumentā. Mēs redzam, ka katrs nākošais bloks ir nedaudz virsū iepriekšējam blokam, un tas ir tikai tāpēc, ka tieši tā mēs tos esam pierakstījuši HTML dokumentā. */

/* kad mēs mūsu blokam izmantojam CSS parametru: position: relative, mēs redzam, ka tas kļūst svarīgāks, tas parādās pārējiem blokiem kā nedaudz pa virsu. */

/* Ja mēs visiem blokiem uzliksim CSS parametru: position: relative mēs redzēsim, ka bloki uzbīdās viens otram virsū, bet teksts paliek savā vietā, jo position: relative tagad skar arī tekstu. Bet, kad nelietojām CSS parametru: position: relative, tad teksts mums parādījās tā kā pa virsu, bet tagad tas ir tā kā apakšā, jo darbojās: position: relative. Bloki nedaudz aizsedz tekstu, jo tam pēc noklusējuma redzamības indekss: z-index ir: auto, bet mēs to varam mainīt. */

/* CSS pozicionēšanas parametrs: z-index ļauj mums vadīt lapas elementus, liekot tiem atrasties augstāk jeb zemāk. Mainīt to redzamību pa z asi. CSS pozicionēšanas parametrs: z-index darbojas tikai tad, ja objektam nav izmantot CSS pozicionēšanas parametrs: position: static. Ar visām pārējām CSS pozicionēšanas parametra: position vērtībām tas darbojās. */

/* CSS pozicionēšanas parametrs: z-indeks: 1 ļauj mums pacelt kādu objektu augstāk vai zemāk pa asi: z. paskatāmies kā tas izskatās piemērā. Redzam, ka brūnais bloks tagad mums ir augstāk, ka tas ir pa virsu violetam blokam. Jo mazāka z-indeks vērtība, jo zemāk ir bloks, jo augstāka, jo augstāk ir bloks. CSS pozicionēšanas parametram: z-index mēs varam izmantot arī negatīvas vērtības, tādejādi liekot kādam objektam atrasties pa visam zemu pa z asi, bet CSS pozicionēšanas parametrs z-index ar negatīvu vērtību slikti darbojās dažos interneta pārlūkos, tādēļ cenšamies tās neizmantot. */

/* Izskatām citu situāciju. Izveidojam HTML dokumentā <span></span> ieliekam tanī tekstu un šeit piemērā mēģinām piemērot CSS pozicionēšanas parametrus: */

/* .block__item_color-purple span {
	position: relative;
	display: inline-block;
	background-color: #ffff00;
	color: #000;
	padding: 10px;
	z-index: 3;
} */

/* Atceramies, ka tegs span ir rindas tipa elements. */

/* Redzam, ka pat tad, ja izmantojam CSS pozicionēšanas parametrs mūsu violetais bloks, rindas tipa span elements ir apakšā. Mēs redzam, ka šādi brūnais bloks un zaļais bloks ir visaugstāk. Tie ir vienā līmenī, bet violetais bloks ir viszemāk, jo tam pēc noklusējuma ir CSS parametrs: position: static. Bet, kad vēršamies pie teg: <span> mēs paaugstinām teksta redzamību izmantojot CSS pozicionēšanas parametru: z-index: 3. Mūsu teksts, kas ir iekš teg span ir līmeni augstāk, tā redzamība ir augstāka, jo iekš CSS parametra: z-index: kā vērtība ir: 3. */

/* Tādēļ šādās situācijās mums ir ļoti jāseko līdzi, kuram objektam ko mēs rakstām, un kurš objekts atrodas iekš cita objekta vecāka. Jo CSS pozicionēšanas parametrs: position ir mantojams, to var izmantot kopīgam blokam - objektam. Kā mūsu piemērā: .block__item {}; */

/* Ja mēs nevēlamies kopīgam vecākam dot CSS pozicionēšanas parametru: position, tad mums katram objektam - elementam ir jāmaina position parametrs, jo atceramies, ka pēc noklusējuma tas ir: position: static, un mēs tādā gadījumā neko nevaram izmantot. Mēs nevaram izmantot CSS pozicionēšanas parametrus. */

/* Situācijā, kad kāds objekts ir zemāk, bet objektam kas ir iekš tā iekšā redzamība ir augstāka, tā kā mūsu gadījumā tegam span, mēs redzam, ka tikai teksts ir augstāks. Teksts iet itkā pa virsu, bet pats bloks ir pēc noklusējuma zemāk. */

/* Ja mums ir situācija, kad diviem objektiem - HTML elementiem ir vienādi CSS parametri: position: relative un z-index: 2, tad darbojās HTML dokumenta hiarhija. Mēs redzam, ka teg: span ir visaugstāk. Pierakstām to ar piemēru, lai labāk saprastu kā tas izskatās realitātē. Piemērs augstāk: */

/* Pievienojot vairākus CSS parametrus iekš CSS selektora: .block__item_color-purple span mēs labi redzam, ka visaugstāk blokā: purple atrodas tegs: <span>, jo tā darbojas HTML hiarhija. */

/* Atceramies kā darbojas HTML dokumenta hiarhija. Jo zemāk pēc koda ir elements - objekts, jo tas būs svarīgāks. Tas ir labi redzams, kad mēs izmantojam vienādus CSS pozicionēšanas parametrus: position: relative un z-index: 2; */

/* Lai labāk saprastu tālākās tēmas izslēdzam nevajadzīgos CSS parametrus augstākajiem piemēriem. Atgriežam visu sākotnējā stāvoklī. Pierakstam vajadzīgās CSS selektorus un parametrus: */

/*
.block__item {
	padding: 15px;
	color: #fff;
	font-size: 20px;
	text-align: center;
} */

/*
.block__item_color-brown {
	background-color: #794f45;
}

.block__item_color-purple {
	background-color: #77608d;
}

.block__item_color-purple span {
	position: relative;
	left: 100px;
	background-color: #ffff00;
	color: #000;
	padding: 10px;
}

.block__item_color-green {
	background-color: #7a956b;
	position: relative;
	top: -20px;
} */

/* Paskatīsimies kā darbojas CSS pozicionēšanas parametri: top, left, right, bottom. Atceramies, ka, lai tie darbotos mums ir jāizmanto CSS pozicionēšanas parametrs: position: relative. Izskatām šo situāciju augstāk piemērā: */

/* Mēs redzam, ka mūsu tag <span> ir nobīdījies no sākotnējās atrašanās vietas pa 100px no kreisās puses. */

/* Iekš CSS pozicionēšanas parametriem: left, right, top, bottom, mēs varam izmantot arī negatīvas vērtības. Tad objekts bīdīsies uz pretējo pusi no tā sākotnējā stāvokļa. */

/* Mēs iekš CSS pozicionēšanas parametriem: top, left, right, bottom varam arī norādīt vērtības procentos: %, bet tad mums jāņem vērā, ka tas tiks ņemts - aprēķināts no vecāka objekta, no tā iekš kura ir dotais objekts - elements. */

/* Būtiski: CSS pozicionēšanas parametru vērtības % procentos nestrādās pa lapas vertikāli. Ja izmantosim CSS pozicionēšanas parametru: position: relative. Tālāk pie citiem CSS pozicionēšanas parametriem strādās % procentu vērtības arī pa lapas vertikāli. */

/* Atceramies, ka mēs nevaram vienlaicīgi izmantot CSS pozicionēšanas parametrus: left un right vai top un bottom, jo tas nestrādās, jo tas ir neloģiski. */

/* Atceramies, ka CSS  pozicionēšanas parametrs: position: relative pārvieto objektu - elementu no tā esošā stāvokļa - no tā pašreizējās atrašanās vietas. ja mēs izmantojot citus CSS parametrus esam elementu - objektu kur pārvietojuši, vēlāk izmantojam CSS parametru: position: relative, tad elements - objekts tiks pārvietots no tās vietas, kur tas tika novietots iepriekš. */

/* Mēs varam panākt, lai CSS pozicionēšanas parametros: top, left, bottom, right mēs varētu izmantot vērtības %, arī pa vertikāli. Vienkārši norādot CSS parametru: height. Un tad mēs varam izmantot procentu vērtības arī pa vertikāli, bet ar nosacījumu, ka vecāka objekts ir augstāks nekā pozicionējamais elements. */

/* Izskatām piemēru ar CSS pozicionēšanas parametru: position: relative abiem mūsu blokiem, tā, lai brunais bloks un zaļais bloks uzbrauktu virsū violetajam blokam. Lai to redzētu izslēdzam iepriekšējo aktīvo kodu, izņemot .block__item. */

/*
.block__item_color-brown {
	background-color: #794f45;
	position: relative;
	top: 20px;
}

.block__item_color-purple {
	background-color: #77608d;
}

.block__item_color-green {
	background-color: #7a956b;
	position: relative;
	top: -20px;
	left: 50px;
} */

/* Mēs redzam, ka abi bloki, kuriem tiek izmantots CSS pozicionēšanas parametrs: position: relative ir gandrīz aizklājis violeto bloku, jo tam pēc noklusējuma ir: position: static. CSS parametrs: z-index visiem trīs blokiem ir pēc noklusējuma: auto. */

/* Ja mēs pievienosim CSS parametru: position: relative arī violetajam blokam, tad tie visi izskatīsies vienādi, katrs nākošais zem iepriekšējā, jo darbosies HTML dokumenta hiarhija. */

/* Paskatīsimies kāda ir atšķirība starp pozicionēšanas parametru un ārējās atstarpes ar negatīvu vērtību izmantošanu. Lai to redzētu izslēdzam iepriekšējo aktīvo kodu. Izskatām situāciju izmantojot violeto bloku. */

/*
.block__item_color-brown {
	background-color: #794f45;
}

.block__item_color-purple {
	background-color: #77608d;
	margin: -30px 0 0 0;
	position: relative;
	top: -30px;
}

.block__item_color-green {
	background-color: #7a956b;
} */

/* Šādā situācijā mēs redzam, ka mums ir notikušas trīs lietas. Violetais bloks ir uzbraucis virsū brūnajam blokam, brūnā bloka teksts peld pa virsu un zaļais bloks pavelkas augšup kopā ar violeto bloku. */

/* Paskatīsimies uz šo pašu situāciju, bet jau izmantojot CSS pozicionēšanas parametrus. Izslēdzam CSS parametru: margin violetajam blokam un pierakstām CSS pozicionēšanas parametrus. */

/* Un mēs atkal redzam, ka mums ir notikušas trīs lietas: Violetais bloks ir uzbraucis uz brūnā bloka, brūnā bloka teksts praktiski nav redzams, tas ir gandrīz aizsegts un zaļais bloks nav nekur pakustējies, tas ir palicis savā vietā, mēs redzam atstarpi. */

/* Izmantojot pieeju ar CSS pozicionēšanas parametru izmantošanu mēs redzam, ka, ja to pielietojam kādam elementam, mēs nekādi neiespaidojam apkārtni, tas neietekmē citus objektus - elementus lapā. Šī ir galvenā atšķirība starp CSS parametra: margin un position izmantošanu. Atceramies: CSS pozicionēšanas parametrs: position: relative neietekmē objekta - elementa apkārti, bet margin ietekmē, gan pašu objektu, gan arī tā apkārtni. */

/* Šādi, kad mums ir uzdevums, un mums ir jau divi zināmi rīki, viena uzdevuma veikšanai, zinot to atšķirības mēs varam izvēlēties kuru, kurā situācijā tieši lietot. */

/* Kāda ir atšķirība starp CSS pozicionēšanas parametru: z-index: 0 un z-index: auto? ja vērtība ir auto, tad tiks ievērota HTML dokumenta secība - hiarhija, bet, ja vērtība būs: 0, tad mēs stingri nosakām, ka kādam elementam - objektam z-index ir: 0. */

/* ja mēs izmantosim kādam elementam negatīvu apakšējo ārējo atstarpi, tad visi pārējie elementi - objekti arī pavilksies uz augšu */

/* Ja mēs gribam izmantot ārējo atstarpi ar negatīvu vērtību, un mēs gribam, lai teksts iepriekšējā objekta teksts nebūtu redzams, tad mēs pievienojam konkrētajam elementam - objektam CSS parametru: position: relative. Līdz ar to tas kļūst spēcīgāks un iepriekšējā elementa teksts vairs nelien virsū konkrētajam elementam. Vēl lielākam spēkam mēs varam pielietot CSS parametru: z-index: 3. Norādot lielāku vērtību. */

/* Ja mēs izmantojam CSS pozicionēšanas parametrus: position: relative un left, right, top, bottom, mēs ievērojam BEM metodoloģiju, jo, pat tad, ja izmantojam tos BEM blokam, tie nekādi neietekmē objektu - elementu apkārtni. Atceramies, ka BEM blokiem mēs nedrīkstam izmantot CSS parametru: margin, jo tad tiek ietekmēti visi lapas elementi - objekti, un netiek ievērota BEM metodoloģija. */

/* Ja izmantojam CSS pozicionēšanas parametrus ar negatīvām vērtībām, tad faktiski elementi tiek nobīdīti uz pretējo pusi. Piemēram left: -20px būs tas pats, kas right: 20px. Tas pats arī notiek ar top un bottom. */

/* CSS pozicionēšanas parametrs: position: relative kopā ar pseido elementiem atver mums milzīgas iespējas, bet to mēs izskatīsim vēlāk. */

/* Nākošais CSS pozicionēšanas parametrs, kuru mēs apgūsim ir: position: absolute, kas it kā izgriež elementu no koda un tas paliek karājoties gaisā. tas vairs neietekmē blakus esošos elementus - objektus. Izmantojot CSS pozicionēšanas parametrus: top, bottom, left un right: elementam mainās tā pozīcija un tas tiek nobīdīts uz vienu vai otru pusi atkarībā no tā vecāka, kam ir norādīts CSS pozicionēšanas parametrs: position: relative. */

/* Ar šo CSS parametru: position: absolute mēs itkā izraujam elementu no HTML dokumenta un tas paliek karājoties gaisā. Bet, lai šis CSS parametrs darbotos tā vecākam ir jābūt norādītam CSS parametram: position: relative. Izskatām to ar piemēru, izslēdzam iepriekšējo aktīvo kodu. */

/*
.block__item_color-brown {
	background-color: #794f45;
}

.block__item_color-purple {
	background-color: #77608d;
	position: absolute;
}

.block__item_color-green {
	background-color: #7a956b;
} */

/* Atceramies, ka CSS pozicionēšanas parametrs: position: absolute pozicionējās attiecībā no sava pirmā vecāka, kuram ir jau CSS pozicionēšanas parametrs: position: relative. Otra būtiska lieta, kas notiek ar elementu - objektu, kam mēs pierakstam: position: absolute ir tas, ka tas kļūst par rindas tipa elementu. */

/* Kādēļ izmantojot CSS pozicionēšanas parametru: position: absolute elements - objekts kļūst par rindas tipa elementu - objektu, pat, ja tas sākotnēji ir bloka tipa elements. tādēļ, ka tas zaudē savu platumu pie position: absolute izmantošanas. Tas kļūst tik liels, cik tajā ir saturs. Tieši tā, kā ar rindas tipa elementiem. */

/* Kādēļ mēs sakām, ka pie CSS parametra: position: absolute elements paliek gaisā karājoties. tādēļ, ka tas zaudē savu atrašanās vietu. Tā vietu aizņem citi objekti - elementi. */

/* Atceramies: pie CSS parametra: position: absolute jāievēro piecas lietas. 1) objekts - elements zaudē savu ķermeni, un paliek itkā karājoties gaisā. 2) citi elementi - objekti aizņem tā vietu. 3) objekts - elements kļūst par rindas tipa elementu, jo tā izmērs ir atkarīgs no tā, cik tajā ir satura. 4) objekts - elements pozicionējās - novietojas atkarībā no sava pirmā vecāka, kuram ir norādīts CSS parametrs: position: relative. 4) CSS pozicionēšanas parametrs: position: absolute ir jāizmanto kopā ar CSS pozicionēšanas parametriem: left, top, right, bottom. */

/* Mēs redzam, ka mūsu piemērā violetais bloks, kuram ir izmantots CSS pozicionēšanas parametrs: position: absolute ir savā vietā, bet šādi tas nav noturīgs, ja mainīsies tā saturs. Otrkārt katrs interneta pārlūks var attēlot elementu savādāk, un mūsu lapa zaudē noturību. */

/* Tādēļ, tad, kad izmantojam CSS pozicionēšanas parametru: position: absolute, mums ir obligāti jānorāda vēl divi CSS pozicionēšanas parametri: objekta - elementa atrašanās vietu pa lapas vertikāli un horizontāli. */

/* Izmēģinām to šos piecus nosacījumus mūsu piemērā. Izmantojam violeto bloku. Izslēdzam aktīvo kodu un pierakstām: */

/*
.block {
	position: relative;
}

.block__item_color-brown {
	background-color: #794f45;
}

.block__item_color-purple {
	background-color: #77608d;
	position: absolute;
	top: 0;
	left: 0;
}

.block__item_color-green {
	background-color: #7a956b;
} */

/* Ko mēs redzam? Mēs redzam, ka mūsu violetais bloks HTML dokumentā iziet cauri visiem augstāk esošajiem blokiem - objektiem un tiem nevienam nav CSS pozicionēšanas parametra: position: relative. Tādēļ, tas atdurās pie paša augstāk esošā tega: <body> un tiek pozicionēts atkarībā no tā. Atceramies, ka elementi - objekti novietojas lapas kreisajā augšējā stūrī. Bet mēs varam to mainīt. Mūsu piemērā mēs ierakstām pozicionēšanas parametrus: top un left ar vērtībām: 0, kas nozīmē, ka mūsu violetais bloks novietojas lapas augšējā kreisajā stūrī. */

/* Ja mēs izmantojam CSS pozicionēšanas parametru: position: absolute, mēs varam vērtībās izmantot % procentus. Tad objekts - elements tiks pozicionēts atkarībā no lapas augstuma un platuma. */

/* Objekta novietošanās tiks aprēķināta no tega: <body>, jo tas neatrod nevienu citu augstāk stāvošu objektu, kam būtu CSS pozicionēšanas parametrs: position: relative. */

/* Izskatām situāciju, kad mūsu trīs blokiem, tā vecākam: .block {} ir norādīts CSS pozicionēšanas parametrs: position: relative. Mēs redzam, ka mūsu violetais bloks atrod vecāku ar klasi: .block, kam ir norādīts: position: relative, tas apstājās un pozicionējās atkarībā no vecāka bloka. */

/* Mēs tagad varam pozicionēt violeto bloku, kā vien mums vajag, izmantojot dažādas vērtību sistēmas, jo tagad tā vecākam ir CSS parametrs: position: relative. */

/* Ja mēs norādīsim CSS pozicionēšanas parametrus: top: 0, vai bottom: 0, tad mūsu violetais bloks tiks piestiprināts pie lapas augšas vai apakšas. Ja mēs norādīsim negatīvas vērtības, tad mūsu elements - violetais bloks pāries pāri malām. uz augšu vai uz leju, atkarībā kādu vērtību mēs būsim norādījuši. */

/* Ja mums HTML dokumentā ir daudz bloku - elementu, liels saturs, tad mums parādās ritināšana - scroll. Mēs redzam, ka tādā gadījumā violetais bloks paliek augšā, tas aizritinās, arī pārējie bloki aizritinās. */

/* CSS pozicionēšanas parametram: position: absolute ir viens liels trūkums: mēs nekādi nevaram ietekmēt tā satura maiņu, jo, ja mainīsies saturs, nekas tālāk nenotiks, piemēram: saturs mainās, kļūst vairāk, bet tas nekādi neietekmē lapas apkārtni, citus lapas elementus - objektus. */

/* No šī izriet, ka mums nevajag izmantot CSS pozicionēšanas parametru: position: absolute tiem lapas elementiem - objektiem, kas ietekmē lapas saturu, citus lapas elementus - objektus. Ar šī rīka izmantošanu mums jābūt ļoti uzmanīgiem. Mums ir jāzin, kad mēs varam tos izmantot, un, kad labāk to neizmantot, bet tas nāks ar laiku, jo pagaidām mums nav tādas pieredzes, lai uzreiz noteiktu, vai varam to izmantot, vai nevaram. */

/* Izmantojot CSS pozicionēšanas parametru: position: absolute mēs izraujam elementu no lapas, to novietojam kur mums vajag, un paredzam, ka tā saturs nemainīsies. */

/* Izmantojot citus CSS pozicionēšanas parametrus mēs nosakām objekta - elementu atrašanas vietu, un tas ietekmē lapas apkārtni - saturu, jo bloki pārvietojas, paplašinās, saraujas, viens ar otru mijiedarbojas, bet pie: position: absolute mēs paredzam, ka lapas saturs netiks ietekmēts, un tur šāda loģika nedarbojas. */

/* Izskatīsim nākošo CSS pozicionēšanas parametru: position: fixed. Elements tiek itkā izrauts no koda, tas karājās gaisā. Tas fiksējās - pozicionējās, tas neritinās kopā ar pārējo lapas saturu, tas pārtrauc ietekmēt citus lapas elementus - objektus. Pievienojot CSS pozicionēšanas parametrus: left, right, top un bottom, tas maina savu pozīciju, atrašanās vietu. Tam arī var izmantot CSS pozicionēšanas parametru: z-index. */

/* Šis CSS parametrs: position: fixed ir ļoti līdzīgs parametram: position: absolute, bet tomēr ir divas būtiskas atšķirības: 1) objekts - elements pozicionējās atkarībā no pārlūka ekrāna platuma un augstuma. Tas nozīmē, ka elements nebūs ritināms kopā ar pārējo lapas saturu, tam nebūs scroll. Tas tiek fiksēts. Scroll ir visiem pārējiem lapas objektiem - elementiem, tie tiek ritināti, bet tie kam ir: position: fixed nav ritināmi. 2) Tas vienmēr fiksēsies atkarībā no pārlūka ekrāna, neskatoties uz to, ka tā vecākam ir CSS pozicionēšanas parametrs: position: relative. */

/* Vēl viens CSS pozicionēšanas parametrs, kas mums ir jāapgūst ir: position: sticky. Tas ir hibrīds diviem CSS pozicionēšanas parametriem: position: fixed un position: static. Sākotnēji elements darbojās itkā tam būtu: position: static, bet tikko ritināšana - scroll aiziet līdz šim elementam, tas kļūst tāds itkā tam būtu noteikts CSS pozicionēšanas parametrs: position: fixed, tas ieņem pozīciju, ko norādām izmantojot CSS pozicionēšanas parametrus: top un bottom. */

/* CSS pozicionēšanas parametrs: position: sticky sākumā izskatās tieši tā kā parametrs: position: static, bet tiklīdz mēs līdz tam nonākam, tas itkā pielīp norādītajā vietā. Bet ir ļoti būtiski, lai CSS failā nebūtu CSS parametrs: overflow: hidden, kas noņem ritināšanas iespēju lapai, jo šādā gadījumā CSS parametrs: position: sticky nedarbosies. */

/* Izslēdzot CSS parametru: overflow: hidden mēs redzam, ka elements, kuram ir CSS parametrs: position: sticky pielīp pie lapas augšas, kad mēs līdz tam nonākam, bet, kad ritinām tālāk, tas aizritinās un nav vairs redzams. */

/* Izskatīsim šo visu ar praktiskiem piemēriem. izslēdzam augstāk esošo aktīvo kodu. */

/*
.block__item_color-brown {
	background-color: #794f45;
}

.block__item_color-purple {
	background-color: #77608d;
	position: sticky;
	top: 0;
}

.block__item_color-green {
	background-color: #7a956b;
} */

/* Izslēdzam iekš CSS reset faila CSS parametru: overflow: hidden. Pievienojam HTML dokumentā daudzus teg: <br>, lai redzētu, kā tieši strādā CSS pozicionēšanas parametrs: position: sticky. */

/* Mēs redzam, ka mums vis darbojās, ka violetais bloks uz brīdi pielīp lapas augšā, bet, kad ritinām tālāk, tas aizritinās. */

/* Šinī situācijā, kad mums ir jāizslēdz CSS reset failā CSS parametrs: overflow: hidden nav īsti laba, jo faktiski tā skaitās kļūda, jo mums iekš: wrapper nepieciešams CSS parametrs: overflow: hidden, bet tad mums nedarbojas CSS pozicionēšanas parametrs: position: sticky. Šo nepilnību mēs vēlāk centīsimies novērst. */

/* Reālajā darbā vajadzība izmantot CSS pozicionēšanas parametru: position: sticky gadās reti, bet tomēr reizēm tas ir ļoti ērti un pat nepieciešams. Lai vēl labāk, uzskatāmāk redzētu tā darbību, iekš HTML dokumenta sakopējam vairākus blokus. Mēs redzam, kā katrs violetais bloks uz brīdi pielīp lapas augšai. Šī arī ir tā situācija, kad mums var noderēt CSS pozicionēšanas parametrs: position: sticky. */

/* Mums var būt situācija, kad izmantojam kādam lapas elementam - objektam CSS pozicionēšanas parametru: position: sticky, kad mums iekš tā ir daudz satura, tad mums īsti nav iespēja tikt līdz tā beigām. Šādā situācijā mums īsti neder šis CSS parametrs. Piemēram mums būs situācija, kad lapā vajadzēs izveidot kādu izpeldošo sarakstu. Mums nederēs CSS parametrs: position: sticky, bet mēs šo situāciju atrisināsim izmantojot JavaScript. Tur vis mums darbosies, tieši tā, kā mums vajag. */

/* Mēs varam CSS pozicionēšanas parametru: position: sticky izmantot kopā ar JavaScript, tad, kad mums vajag izpeldošos elementus. */

/* Šobrīd mēs īsti nezinām, kā mums izmantot CSS pozicionēšanas parametru: position: sticky kopā ar CSS parametru: overflow: hidden. Mēs ieliekam CSS parametru: overflow-x: hidden iekš CSS reset faila, iekš tega: <body>. Šādi mēs uz brīdi atvieglojam šī brīža darbu. Vēlāk tiksim skaidrībā, kā mēs šo nebūšanu varam normāli atrisināt, neliekot šādus kruķus, jo tas nav īsti pareizi. */

/* Tagad ķersimies klāt praktiskajai lekcijas daļai, izskatīsim dažādus piemērus. Izslēdzam HTML dokumentā daudzos, sakopētos blokus,  un izslēdzam CSS failā iepriekšējos aktīvos kodus. */

/*
.list {
}

.list__item {
	position: relative;
	padding-left: 25px;
}

.list__item::before {
	content: "";
	position: absolute;
	top: -6px;
	left: 0;
	width: 25px;
	height: 25px;
	background: url("../img/repair_page/icons/icon.png") 0 0 no-repeat;
	transition: all 0.3s ease 0s;
}

.list__item:hover::before {
	transform: rotate(360deg);
}

.list__item:hover::before {
	transform: scale(1.5);
}

.list__item:not(:last-child) {
	margin-bottom: 10px;
} */

/* Atceramies: CSS parametrs: padding neietekmē lapas objektus, jo tas skar tikai esošo objektu, tas tiek iekļauts iekš tā atrašanās vietas. Atceramies, ka CSS parametrs: padding ir iekšējā atstarpe, kas nekādi neietekmē citus lapas elementus. */

/* Izmantot CSS parametru: margin mēs nevaram, jo tā ir ārējā atstarpe un tā ietekmē citus lapā esošos objektus. */

/* Mēs varam panākt vajadzīgo rezultātu mainot CSS pozicionēšanas parametrus: top un left, dodot tiem negatīvas vērtības. Bet tas mums šinī gadījumā nav vajadzīgs, jo mēs norādām, ka visiem saraksta elementiem ir iekšējā atstarpe pa kreisi. */

/* CSS pozicionēšanas parametri: position: absolute un position: fixed ietekmē citus lapas elementus, apkārtni, tādēļ pēc BEM metodoloģijas mēs nevaram šos CSS pozicionēšanas parametrus izmantot BEM blokiem. Mēs tos varam izmantot BEM elementiem un modifikatoriem. */

/* Pēc BEM metodoloģijas BEM blokiem mēs varam izmantot CSS pozicionēšanas parametru: position: relative, jo tas neietekmē citus lapas elementus - objektus. */

/* Paskatīsimies vēl uz praktiskiem piemēriem. Atgriežamies HTML dokumentā iekš tega <header>. */

/*
.header {
	background-color: #7a956b;
	padding: 15px;
	position: fixed;
	width: 100%;
	top: 0;
	left: 0;
	z-index: 100;
} */

/* Mēs pievienojām lapai galveni, un daudzus teg: <br>, mēs redzam, ka lapas galvene tagad ir fiksēta. Kad mēs ritinām lapu uz leju, lapas galvene nekur nepazūd, tā vienmēr iet augšā līdzi. */

/* Lapas galvenei mēs izmantojam CSS pozicionēšanas parametru: z-index: 100; Tādēļ, lai vienmēr lapas galvene būtu pa virsu visam pārējam lapas saturam. */

/* Mēs redzam, ka mūsu situācijā, kad izmantojam CSS parametru: position: fixed mūsu elements zaudē ķermeni, pārējais lapas saturs ir aizgājis galvenei apakšā. Šādā situācijā mums kopējam tegam <main> lapas vecākam ir jāpievieno iekšējā augšējā atstarpe, lai pārējie lapas elementi būtu redzami. */

/* Izskatīsim vēl pozicionēšanas piemērus. Atgriežamies HTML dokumentā. */

/*
.image {
	position: relative;
	display: inline-block;
}

.image::before {
	content: "";
	position: absolute;
	width: 100%;
	height: 100%;
	top: 0;
	left: 0;
	background-color: rgba(0, 0, 0, 0.4);
	z-index: 2;
}

.image:hover::before {
	opacity: 0;
}

.image__item {
	width: 200px;
} */

/* Šinī piemērā mēs redzam kā mēs varam izmantojot CSS pozicionēšanas parametrus attēlam pievienot caurspīdīgumu. Redzam, ka kopējam, elementa vecākam mēs izmantojam CSS parametru: position: relative. Tad izmantojot pseido elementu::before un CSS parametru: position: absolute mēs uz attēla varam pievienot ko vien vēlamies. Šinī piemērā melno krāsu ar caurspīdīguma efektu. */

/* Mēs mūsu piemērā varam izmantot hover efektu. Kad uzvedam ar peli uz attēla tā caurspīdīgā melnā krāsa pazūd. Pievienojot saitei, kas mums ir attēls pseido klases mēs panākam mums vēlamo rezultātu. Šī pieeja tiek daudz pielietota lapu izstrādē, kad mums vajag lai pie uzvešanas ar peli elements mainās. */

/* Mēs izmantojot pozicionēšanu kopā pseido elementiem varam panākt interesantus efektus. Mums tagad ir jau daudz stipru rīku, ko varam pielietot attiecīgajos gadījumos. */

/* Lapas galvenē parasti nav daudz satura, jo tas būtu neloģiski. Mēs varam izmantot šos divus spēcīgos CSS rīkus: pozicionēšanu ar pseido klasēm, ja ir paredzēts, ka konkrētais lapas saturs netiks mainīts. Mums vienmēr jāpatur prātā, kuros gadījumos lapas saturs tiks mainīts, jo mūsu galvenais uzdevums ir nodrošināt, lai mūsu lapa būtu noturīga pret satura maiņu. */

/* Šie divi CSS rīki ievērojami paplašina mūsu iespējas. Situācijās, kad mums vajag kādu elementu pārvietot, griezt utt, mēs to nevaram panākt piemēram izmantojot: background. Bet tagad, kad mums ir šie divi jaudīgie rīki mēs varam jau daudz vairāk. Tālāk kursā mēs apgūsim vēl citus CSS rīkus un varēsim izdarīt visu ko vien var iedomāties. */

/* CSS pozicionēšanas parametri ir jāizmanto piesardzīgi. Nevajag tos grūst visiem elementiem, jo atceramies, vairāk vai mazāk lapas saturs mainīsies. Ja mums ir citas metodes, kā mēs varam izvietot objektus -elementus, tad izmantojam tās, bet, ja mums to nav, tad izmantojam CSS pozicionēšanas parametrus. */

/* Tagad mēs izmantojot CSS pozicionēšanas parametrus varam viegli priekš saraksta vai teksta pievienot ikonas. Izskatām to mūsu: list piemērā. Sarkanā punkta vietā pievienojot ikonu. */

/* Šī pieeja, kad mums vajag tikai ikonu, nev īsti pareiza, jo mēs to pašu varam panākt izmantojot CSS parametru: background. Būtu jāraksta daudz īsāks kods. Bet mums var būt situācija, kad mums vajag, lai pie uzvešanas ar peli uz ikonas tā grieztos vai paliktu lielāka, un to mēs varam panākt tikai ar šādu pieeju pozicionēšanas izmantošanu. Paskatamies kā tas darbojas mūsu piemērā. */

/* Lai panāktu šādus efektus mēs pielietojam CSS parametrus, kurus vēl neesam apguvuši. Tie ir: transform un transition. Mēs tos vienkārši pierakstam, lai paskatītos kā ar CSS pozicionēšanas un pseido elementu izmantošanu mēs varam paveikt interesantas lietas. */

/* izmantojot CSS parametru: background mēs nevaram panākt tieši šādus efektus, mēs varam to panākt tikai daļēji, bet, ja izmantojam pseido klases kopā ar pozicionēšanu un dažiem mums vēl nezināmiem CSS parametriem, mēs redzam, ka pirmajā gadījumā ikona pirms saraksta rindas griežas ap savu asi, bet otrajā gadījumā palielinās. */

/* Kas attiecās par attēlu formātiem mums tagad nevajag īpaši uztraukties, jo tālāk mēs apgūsim rīku, kas automātiski visus attēlus saspiedīs un konvertēs mums vajadzīgajos formātos. */

/* Paskatīsimies uz vēl vienu piemēru. izslēdzam visus aktīvos kodus HTML dokumentā un šeit CSS failā. Izskatīsim piemēru no maketa, kad mums vajag pievienot lapā dekora līniju. Atgriežamies hTML dokumentā un izveidojam tur kastīti. */

.test {
	background: #f5f5f5;
	padding: 110px 30px;
	position: relative;
}

.test::before {
	content: "";
	position: absolute;
	background: url('../img/dog_page/promices/blob.png') 0 0 no-repeat;
	top: -489px;
	right: 0;
	width: 623px;
	height: 1437px;
}

.test__content {
	position: relative;
}

/* Izpildot šo piemēru izmantojot pozicionēšanu un pseido elementus mēs panākam mums vēlamo rezultātu, dekors ir aiz teksta, apakšā. Teksts ir pa virsu. Šo pašu uzdevumu mēs varējam realizēt vienkārši izmantojot CSS parametru: background: url() un mainot pozīcijas - atrašanās vietas vērtības. Bet mēs izpildījām šo uzdevumu tieši šādi, lai labāk redzētu kā darbojas pozicionēšana. */

/* Šādi mēs varējām realizēt šo piemēru izmantojot CSS parametru: background: */

.test {
	background: #f5f5f5 url('../img/dog_page/promices/blob.png') no-repeat right 
	-489px;
	padding: 110px 30px;
	position: relative;
}






