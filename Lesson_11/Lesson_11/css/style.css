
/* Šinī lekcijā mēs izskatīsim jaunu tēmu: pseido elementi un pseido klases. */
/* Sākumā atceramies kā pieslēgt šriftus: */

@import url("https://fonts.googleapis.com/css?family=Poppins:regular,700&display=swap");


@font-face {
	font-family: "Gilroy";
	src:
		url("../fonts/Gilroy-Regular.woff2") format("woff2"),
		url("../fonts/Gilroy-Regular.woff") format("woff");
	font-weight: normal;
	font-style: normal;
	font-display: swap;
}

@font-face {
	font-family: "Gilroy";
	src:
		url("../fonts/Gilroy-Bold.woff2") format("woff2"),
		url("../fonts/Gilroy-Bold.woff") format("woff");
	font-weight: bold;
	font-style: normal;
	font-display: swap;
}

body {
	font-family: "Gilroy", sans-serif;
	font-size: 16px;
	font-weight: 400;
}

/* Atceramies no iepriekšējās lekcijas par BEM metodoloģiju, ka mēs nedrīkstam klases nosaukumos veidot hiarhiju. Lai novērstu šādas situācijas, mēs varam vienkārši apgriezt bloka klases nosaukumu otrādi, un turpināt strādāt tālāk pirmajā klases nosaukuma daļā lietojot bloka nosaukumu. */

/* Lai labāk saprastu kā tieši tas izskatās un kā mums ir jārīkojas, izveidojam HTML dokumentā pareizu piemēra pierakstu. */

/* Mēs izmantojam pa visam vienkāršu risinājumu apgriežot bloka klases nosaukumu otrādi. */

/* BEM metodoloģija paredz, ka mēs katram HTML dokumenta tegam dodam klases nosaukumu. Kā arī iekš CSS stiliem mēs neizmantojam kas kaskādes stilus, bet vēršamies tieši pie klašu selektoru nosaukumiem un tiem rakstam stilus. */

/* Atceramies, kas ir kaskādes stili, pierakstām piemēru: */

/* .block a {

} */

/* Šādu pieeju BEM metodoloģijā nerekomendē izmantot. Mums jācenšas no šādām situācijām izvairīties dodot katram tegam klases nosaukumu. */

/* Pareizais risinājums, kas jāievēro strādājot pēc BEM metodoloģijas: */

/* .list {
}

.list__item {
}

.list__link {
} */

/* Mums jau tagad sākumā ir jāpierod katram elementam rakstīt nosaukumus pēc BEM metodoloģijas. */

/* Pēc BEM metodoloģijas nav ieteicams izmantot atsevišķus CSS failus ar stilu atiestatīšanu, tādus kā normalize un null. Tieši kādēļ tā nav zināms. Bet mēs varam izmantot savu, šinī kursā ar rokām rakstīto CSS style reset. Tas nav nepareizi. */

/* Atceramies: Ārējās atstarpes mēs nevaram izmantot blokam, bet varam izmantot bloka elementam. Atceramies kapēc? Jo bloks ir neatkarīgs, un mums jādara vis, lai tas paliktu neatkarīgs, tādēļ mēs tam nedrīkstam izmantot ārējo atstarpi: margin: 0 0 30px 0. */

/* Atceramies, ka izveidojot kādu bloku HTML dokumentā, strādājot ar to tālāk mums jāievēro, lai nosaukuma pirmā daļa tiktu mantota no bloka nosaukuma. Piemērām: Bloks: about; about__title; about__text. Atceramies, ka mēs varam izmantot arī Mix nosaukumus, BEM elementiem pievienojot blokus vai tehniskās klases. Atceramies, ka tehniskās klases nosaukuma priekšā ir jāliek zīme: _; Piemēram: _container. */

/* Mums var gadīties tāda situācija, kad mums nav ieteicams rakstīt klases nosaukumu. Piemēram, ja mums ir kastīte - bloks ar klasi "text", iekš tā mums ir 2-3 paragrāfi, kuriem esam iedevuši klasi: "text__item". Nākošais, kas aiz mums strādās caur lapas admin, php, kādā wordpress būs neapmierināts, jo viņš mainīs lapas saturu, un šinī gadījumā viņam būs jāveido paragrāfi rakstot klašu nosaukumus. Un to neviens negribēs darīt. Tādēļ, ja mums ir jau izveidota kastīte, kur būs teksts - paragrāfi, tad mēs nerakstam tiem klases. */

/* Šeit mums rodas viedokļu - likumu nesakarība, jo kā zinām no BEM metodoloģijas mums ir visiem elementiem jādod klašu nosaukumi, bet no praktiskā viedokļa ir situācijas, kad to nav vēlams darīt. */

/* Šādai situācijai ir ļoti vienkāršs risinājums. Mēs kastītei rakstām klasi, bet paragrāfiem nerakstām. Izmantojam CSS kaskādes stilus. Kas itkā no BEM metodoloģijas puses nav ieteicams, bet šādās situācijās mēs to varam darīt. */

/* Ar laiku, kad mums būs jau pieredze, mums būs jāprot atdalīt kontentu, kas noteikti tiks mainīts, nedot tam klašu nosaukumus. Bet pārējam lapas saturam, kas paliks nemainīgs rakstam klašu nosaukumus. Tagad šo saprast mums ir grūti, bet ar laiku strādājot praktiski, uzreiz būs skaidrs, kam rakstīt klašu nosaukumus, un kam labāk ne. */

/* Bet šī saprašana ir sarežģīta un tas jau ir eksperta līmenis. Tagad mēs varam tikai minēt, kurā vietā lapā saturs tiks mainīts un, kur netiks mainīts. Ja mēs strādājam komandā, kur ir arī backend speciālists, tad ir daudz vieglāk, jo mēs no klienta - pasūtītāja varam visu smalki uzzināt, apspriest ar backend speciālistu un realizēt savā darbā. */

/* Lai mēs šobrīd pārāk nesaspringtu, mēs rīkojamies tā kā mums māca BEM metodoloģija, dodam katram elementam klases nosaukumu. Kad notiks lapas integrācija realitātē, tad mēs varēsim saprast kur un ko nedaudz pamainīt, lai backend speciālistam būtu vieglāk. */

/* Ja mums gadīsies izveidot kādu klasi, kas netiks izmantota, tas nekas, jo vēlāk mēs rakstīsim stilus SCSS formātā, strādāsim ar Gulp un tie nodrošinās, ka nekas lieks mūsu lapā nepaliek. */

/* Mums var rasties situācija, kad mums jāizmanto BEM klašu nosaukumi - Mix. lai uzskatāmāk saprastu, kāda ir situācija, pierakstam piemēru iekš HTML dokumenta. izmantojam BEM metodoloģijas Mix: main__container container; Šeit vēršamies tieši pie container, piemērs: */

/* .container {
	max-width: 1170px;
} */

/* Turpinām piemēru iekš HTML dokumenta ievērojot BEM metodoloģiju, pareizi rakstot klašu nosaukumus. Izveidojam vienkārši jaunu bloku. Par cik mēs atvērām jaunu bloku iekš HTML dokumenta, nākošajiem tanī esošajiem bloka elementiem ir jāmanto bloka nosaukums. Skatamies HTML dokumentā. */

/* Bet ir viena būtiska lieta. Mēs itkā atrisinājām situāciju, bet atceramies, ka bloks ir neatkarīgs un mēs tam nevaram izmantot, piemēram: margin; bet ja piemēram mums vajag pielietot citus CSS parametrus, piemēram: color jeb font-size, tad šādi mēs varam rīkoties. */

/* Lai mēs varētu atrisināt problēmu, kad gribam izmantot ārējo atstarpi, mums ir jāizveido bloka modifikators. Lai labāk saprastu, skatamies HTML dokumentu. Mēs pievienojam blokam modifikatoru ierakstot: container-margin. Tagad mēs no CSS faila varam pie tā vērsties un dot tam CSS parametrus kādus mums vajag. Tā kā piemērā: */

/* .container_margin {
	margin: 0 auto;
} */

/* Redzam pēc šiem piemēriem, ka problēmu mēs esam atrisinājuši, bet trūkums ir tāds, ka mums katru reizi, kad gribēsim kur izmantot šīs klases, blokus mums tās katru reizi jāpievieno un tas nav ļoti ērti. Bet kamēr mēs esam iesācēji, mēs daram tieši šādi. */

/* Tieši tādēļ, ka šādi nav ērti strādāt tiek izmantotas tehniskās klases, piemēram: _container. Izskatām piemēru, kur ir sakārtotas visas BEM metodoloģijas klases tā, lai mums būtu ērti, un arī, lai citiem būtu saprotams mūsu kods. */

/* Atstājam arī iepriekšējo BEM metodoloģijas klašu nosaukumu veidošanas piemēru, lai, ja mums radīsies šāda situācija, mēs zinātu kā varam to atrisināt. */

/* Šo konstrukciju mēs varam izmantot visur, kur mums lapā nepieciešams. Izveidojam HTML dokumentā bloku about un iekš tā vienkārši iekopējam iepriekšējā piemēra rindu. */

/* Sākam jauno lekcijas tēmu: pozicionēšanu. Izslēdzam visu aktīvo kodu HTML dokumentā, lai mēs uzskatāmāk saprastu tēmu. Izslēdzam aktīvo kodu arī iekš CSS. */

/* Izveidojam iekš HTML dokumenta bloku un bloku ar elementu, un trīs elementus ar modifikatoriem. Mācamies jau tagad pareizi rakstīt klašu nosaukumus, pēc BEM metodoloģijas. */

.block {
	/* Noklusējuma vērtība */
	position: static;
	/* nevaram izmantot:
	top
	right
	bottom
	left
	z-index */
}

/* .block__item {
	padding: 15px;
	color: #fff;
	font-size: 20px;
	text-align: center;
	margin: -20px 0 0 0;
}

.block__item_color-brown {
	background-color: #794f45;
	position: relative;
	z-index: 2;
}

.block__item_color-purple {
	background-color: #77608d;
}

.block__item_color-green {
	background-color: #7a956b;
} */

/* Kas tad ir pozicionēšana? Pozicionēšana ievērojami paplašina mūsu iespējas strādājot ar lapas elementiem. Mēs iegūstam jaunu rīku, kā mēs varam darboties ar lapas elementiem, bet tas nenozīmē, ka tagad mums tas jāizmanto visur, jo atceramies par pamatlikumu, kas jāievēro kad izstrādājam lapas, lapai jābūt noturīgai - uzticamai. Atceramies - lapas saturs var mainīties. */

/* Pozicionēšana ir ļoti jaudīgs instruments ar plašām izmantošanas iespējām, bet tam ir liels trūkums: Tas padara mūsu lapu nenoturīgu - neuzticamu veicot izmaiņas, tādēļ to lietojot jābūt ļoti piesardzīgam. */

/* Mēs iegūstam jaunu CSS parametru: position, kas maina pozicionēšanas tipu. Rakstam to iekš mūsu piemēra. Šis parametrs ir kaut kur līdzīgs parametram: display, kur mēs strādājam ar elementu tipiem. */

/* CSS parametrs: position arī ir sava veida pārslēdzējs, tā pat kā: display, tikai tas pārslēdz elementa pozīciju. Elementam jeb tā vecākam, iekš kā konkrēti ir šis elements. */

/* Atšķirībā no CSS parametra: display, parametrs: position darbojas ar visa tipa elementiem, gan rindas tipa, gan bloka-rindas tipa, gan bloka elementiem. */

/* CSS pozicionēšanas parametrs: position: relative nav mantojams, tas nepārmantojas uz citiem lapas elementiem - objektiem. */

/* Izskatīsim kādas vērtības ir CSS parametram: position. Pirmā ir static, kas ir noklusējuma vērtība. Šis parametrs ir katram lapas objektam, mēs vienkārši to nerakstam, neredzam, jo tas jau iet pēc noklusējuma. Mēs nevaram pie šādas vērtības neko darīt ar objektu. Mēs nevaram izmantot: right, left, top, bottom un z-index. */

/* CSS parametram: position static ir sešas vērtības, kas uzskaitītas augstāk piemērā. Z-index arī ir pozicionēšanas CSS parametrs. */

/* Kur mums var noderēts CSS parametrs: position: static. Tas mums var noderēt, ja mums kādam objektam sākotnēji ir cita position vērtība un kādā brīdī, piemēram: pie lapas adaptīva mēs gribam mainīt CSS parametru no cita uz position: static. */

/* Izskatām nākošo CSS parametra: position vērtību, rakstām to mūsu piemērā. Position: relative maina elementa atrašanās vietu no tā sākotnējā stāvokļa kodā. Sākotnējās atrašanās vietas. Šeit mēs varam izmantot CSS parametrus: left, right, top, bottom, z-index. Mūsu objekts tiek nobīdīts uz vienu vai otru pusi, tā kā mēs esam norādījuši. Atceramies, ka tas nobīdās atkarībā no sava sākotnējā atrašanās vietas stāvokļa. */

/* Izmantojot CSS parametru: position: relative mēs mainām pozicionēšanas tipu. Mēs varam jau brīvi rīkoties ar objektu norādot citus pozicionēšanas parametrus. */

/* Pozicionēšanas parametrs: z-index pēc noklusējuma ir ar vērtību: auto. Bet mēs to varam mainīt, atkarībā, kuru elementu gribam paslēpt, kuru parādīt. Iekš pozicionēšanas parametra: z-index vērtībām mēs varam likt skaitļus no 1 un cik vien mums vajag tālāk, ja mums ir daudzi objekti, kam jāizmanto šis pozicionēšanas parametrs. */

/* Lai mēs uzskatāmāk saprastu kā darbojās CSS parametrs: position: relative, veicam nelielas izmaiņas mūsu kodā, pievienojot negatīvu ārējo atstarpi. Bez šī parametra mēs redzam, ka mūsu augšējie bloki nedaudz uzbīdās viens otram virsū, bet izmantojot CSS parametru: position: relative mūsu bloks, kam mēs to izmantojam kļūst svarīgāks, redzamāks. */

/* Kādēļ bez CSS parametra: position: relative mūsu bloki tieši uzbrauc tādā secībā viens uz otra. Tādēļ, ka tieši tā tie mums ir pierakstīti kodā, gan HTML dokumentā. Mēs redzam, ka katrs nākošais bloks ir nedaudz virsū iepriekšējam blokam, un tas ir tikai tāpēc, ka tieši tā mēs tos esam pierakstījuši HTML dokumentā. */

/* kad mēs mūsu blokam izmantojam CSS parametru: position: relative, mēs redzam, ka tas kļūst svarīgāks, tas parādās pārējiem blokiem kā nedaudz pa virsu. */

/* Ja mēs visiem blokiem uzliksim CSS parametru: position: relative mēs redzēsim, ka bloki uzbīdās viens otram virsū, bet teksts paliek savā vietā, jo position: relative tagad skar arī tekstu. Bet, kad nelietojām CSS parametru: position: relative, tad teksts mums parādījās tā kā pa virsu, bet tagad tas ir tā kā apakšā, jo darbojās: position: relative. Bloki nedaudz aizsedz tekstu, jo tam pēc noklusējuma redzamības indekss: z-index ir: auto, bet mēs to varam mainīt. */

/* CSS pozicionēšanas parametrs: z-index ļauj mums vadīt lapas elementus, liekot tiem atrasties augstāk jeb zemāk. Mainīt to redzamību pa z asi. CSS pozicionēšanas parametrs: z-index darbojas tikai tad, ja objektam nav izmantot CSS pozicionēšanas parametrs: position: static. Ar visām pārējām CSS pozicionēšanas parametra: position vērtībām tas darbojās. */

/* CSS pozicionēšanas parametrs: z-indeks: 1 ļauj mums pacelt kādu objektu augstāk vai zemāk pa asi: z. paskatāmies kā tas izskatās piemērā. Redzam, ka brūnais bloks tagad mums ir augstāk, ka tas ir pa virsu violetam blokam. Jo mazāka z-indeks vērtība, jo zemāk ir bloks, jo augstāka, jo augstāk ir bloks. CSS pozicionēšanas parametram: z-index mēs varam izmantot arī negatīvas vērtības, tādejādi liekot kādam objektam atrasties pa visam zemu pa z asi, bet CSS pozicionēšanas parametrs z-index ar negatīvu vērtību slikti darbojās dažos interneta pārlūkos, tādēļ cenšamies tās neizmantot. */

/* Izskatām citu situāciju. Izveidojam HTML dokumentā <span></span> ieliekam tanī tekstu un šeit piemērā mēģinām piemērot CSS pozicionēšanas parametrus: */

/* .block__item_color-purple span {
	position: relative;
	display: inline-block;
	background-color: #ffff00;
	color: #000;
	padding: 10px;
	z-index: 3;
} */

/* Atceramies, ka tegs span ir rindas tipa elements. */

/* Redzam, ka pat tad, ja izmantojam CSS pozicionēšanas parametrs mūsu violetais bloks, rindas tipa span elements ir apakšā. Mēs redzam, ka šādi brūnais bloks un zaļais bloks ir visaugstāk. Tie ir vienā līmenī, bet violetais bloks ir viszemāk, jo tam pēc noklusējuma ir CSS parametrs: position: static. Bet, kad vēršamies pie teg: <span> mēs paaugstinām teksta redzamību izmantojot CSS pozicionēšanas parametru: z-index: 3. Mūsu teksts, kas ir iekš teg span ir līmeni augstāk, tā redzamība ir augstāka, jo iekš CSS parametra: z-index: kā vērtība ir: 3. */

/* Tādēļ šādās situācijās mums ir ļoti jāseko līdzi, kuram objektam ko mēs rakstām, un kurš objekts atrodas iekš cita objekta vecāka. Jo CSS pozicionēšanas parametrs: position ir mantojams, to var izmantot kopīgam blokam - objektam. Kā mūsu piemērā: .block__item {}; */

/* Ja mēs nevēlamies kopīgam vecākam dot CSS pozicionēšanas parametru: position, tad mums katram objektam - elementam ir jāmaina position parametrs, jo atceramies, ka pēc noklusējuma tas ir: position: static, un mēs tādā gadījumā neko nevaram izmantot. Mēs nevaram izmantot CSS pozicionēšanas parametrus. */

/* Situācijā, kad kāds objekts ir zemāk, bet objektam kas ir iekš tā iekšā redzamība ir augstāka, tā kā mūsu gadījumā tegam span, mēs redzam, ka tikai teksts ir augstāks. Teksts iet itkā pa virsu, bet pats bloks ir pēc noklusējuma zemāk. */

/* Ja mums ir situācija, kad diviem objektiem - HTML elementiem ir vienādi CSS parametri: position: relative un z-index: 2, tad darbojās HTML dokumenta hiarhija. Mēs redzam, ka teg: span ir visaugstāk. Pierakstām to ar piemēru, lai labāk saprastu kā tas izskatās realitātē. Piemērs augstāk: */

/* Pievienojot vairākus CSS parametrus iekš CSS selektora: .block__item_color-purple span mēs labi redzam, ka visaugstāk blokā: purple atrodas tegs: <span>, jo tā darbojas HTML hiarhija. */

/* Atceramies kā darbojas HTML dokumenta hiarhija. Jo zemāk pēc koda ir elements - objekts, jo tas būs svarīgāks. Tas ir labi redzams, kad mēs izmantojam vienādus CSS pozicionēšanas parametrus: position: relative un z-index: 2; */

/* Lai labāk saprastu tālākās tēmas izslēdzam nevajadzīgos CSS parametrus augstākajiem piemēriem. Atgriežam visu sākotnējā stāvoklī. Pierakstam vajadzīgās CSS selektorus un parametrus: */

.block__item {
	padding: 15px;
	color: #fff;
	font-size: 20px;
	text-align: center;
}
/*
.block__item_color-brown {
	background-color: #794f45;
}

.block__item_color-purple {
	background-color: #77608d;
}

.block__item_color-purple span {
	position: relative;
	left: 100px;
	background-color: #ffff00;
	color: #000;
	padding: 10px;
}

.block__item_color-green {
	background-color: #7a956b;
	position: relative;
	top: -20px;
} */

/* Paskatīsimies kā darbojas CSS pozicionēšanas parametri: top, left, right, bottom. Atceramies, ka, lai tie darbotos mums ir jāizmanto CSS pozicionēšanas parametrs: position: relative. Izskatām šo situāciju augstāk piemērā: */

/* Mēs redzam, ka mūsu tag <span> ir nobīdījies no sākotnējās atrašanās vietas pa 100px no kreisās puses. */

/* Iekš CSS pozicionēšanas parametriem: left, right, top, bottom, mēs varam izmantot arī negatīvas vērtības. Tad objekts bīdīsies uz pretējo pusi no tā sākotnējā stāvokļa. */

/* Mēs iekš CSS pozicionēšanas parametriem: top, left, right, bottom varam arī norādīt vērtības procentos: %, bet tad mums jāņem vērā, ka tas tiks ņemts - aprēķināts no vecāka objekta, no tā iekš kura ir dotais objekts - elements. */

/* Būtiski: CSS pozicionēšanas parametru vērtības % procentos nestrādās pa lapas vertikāli. Ja izmantosim CSS pozicionēšanas parametru: position: relative. Tālāk pie citiem CSS pozicionēšanas parametriem strādās % procentu vērtības arī pa lapas vertikāli. */

/* Atceramies, ka mēs nevaram vienlaicīgi izmantot CSS pozicionēšanas parametrus: left un right vai top un bottom, jo tas nestrādās, jo tas ir neloģiski. */

/* Atceramies, ka CSS  pozicionēšanas parametrs: position: relative pārvieto objektu - elementu no tā esošā stāvokļa - no tā pašreizējās atrašanās vietas. ja mēs izmantojot citus CSS parametrus esam elementu - objektu kur pārvietojuši, vēlāk izmantojam CSS parametru: position: relative, tad elements - objekts tiks pārvietots no tās vietas, kur tas tika novietots iepriekš. */

/* Mēs varam panākt, lai CSS pozicionēšanas parametros: top, left, bottom, right mēs varētu izmantot vērtības %, arī pa vertikāli. Vienkārši norādot CSS parametru: height. Un tad mēs varam izmantot procentu vērtības arī pa vertikāli, bet ar nosacījumu, ka vecāka objekts ir augstāks nekā pozicionējamais elements. */

/* Izskatām piemēru ar CSS pozicionēšanas parametru: position: relative abiem mūsu blokiem, tā, lai brunais bloks un zaļais bloks uzbrauktu virsū violetajam blokam. Lai to redzētu izslēdzam iepriekšējo aktīvo kodu, izņemot .block__item. */

/*
.block__item_color-brown {
	background-color: #794f45;
	position: relative;
	top: 20px;
}

.block__item_color-purple {
	background-color: #77608d;
}

.block__item_color-green {
	background-color: #7a956b;
	position: relative;
	top: -20px;
	left: 50px;
} */

/* Mēs redzam, ka abi bloki, kuriem tiek izmantots CSS pozicionēšanas parametrs: position: relative ir gandrīz aizklājis violeto bloku, jo tam pēc noklusējuma ir: position: static. CSS parametrs: z-index visiem trīs blokiem ir pēc noklusējuma: auto. */

/* Ja mēs pievienosim CSS parametru: position: relative arī violetajam blokam, tad tie visi izskatīsies vienādi, katrs nākošais zem iepriekšējā, jo darbosies HTML dokumenta hiarhija. */

/* Paskatīsimies kāda ir atšķirība starp pozicionēšanas parametru un ārējās atstarpes ar negatīvu vērtību izmantošanu. Lai to redzētu izslēdzam iepriekšējo aktīvo kodu. Izskatām situāciju izmantojot violeto bloku. */

.block__item_color-brown {
	background-color: #794f45;
}

.block__item_color-purple {
	background-color: #77608d;
	/* margin: -30px 0 0 0; */
	position: relative;
	top: -30px;
}

.block__item_color-green {
	background-color: #7a956b;
}

/* Šādā situācijā mēs redzam, ka mums ir notikušas trīs lietas. Violetais bloks ir uzbraucis virsū brūnajam blokam, brūnā bloka teksts peld pa virsu un zaļais bloks pavelkas augšup kopā ar violeto bloku. */

/* Paskatīsimies uz šo pašu situāciju, bet jau izmantojot CSS pozicionēšanas parametrus. Izslēdzam CSS parametru: margin violetajam blokam un pierakstām CSS pozicionēšanas parametrus. */

/* Un mēs atkal redzam, ka mums ir notikušas trīs lietas: Violetais bloks ir uzbraucis uz brūnā bloka, brūnā bloka teksts praktiski nav redzams, tas ir gandrīz aizsegts un zaļais bloks nav nekur pakustējies, tas ir palicis savā vietā, mēs redzam atstarpi. */

/* Izmantojot pieeju ar CSS pozicionēšanas parametru izmantošanu mēs redzam, ka, ja to pielietojam kādam elementam, mēs nekādi neiespaidojam apkārtni, tas neietekmē citus objektus - elementus lapā. Šī ir galvenā atšķirība starp CSS parametra: margin un position izmantošanu. Atceramies: CSS pozicionēšanas parametrs: position: relative neietekmē objekta - elementa apkārti, bet margin ietekmē, gan pašu objektu, gan arī tā apkārtni. */

/* Šādi, kad mums ir uzdevums, un mums ir jau divi zināmi rīki, viena uzdevuma veikšanai, zinot to atšķirības mēs varam izvēlēties kuru, kurā situācijā tieši lietot. */

/* Kāda ir atšķirība starp CSS pozicionēšanas parametru: z-index: 0 un z-index: auto? ja vērtība ir auto, tad tiks ievērota HTML dokumenta secība - hiarhija, bet, ja vērtība būs: 0, tad mēs stingri nosakām, ka kādam elementam - objektam z-index ir: 0. */

/* ja mēs izmantosim kādam elementam negatīvu apakšējo ārējo atstarpi, tad visi pārējie elementi - objekti arī pavilksies uz augšu */

/* Ja mēs gribam izmantot ārējo atstarpi ar negatīvu vērtību, un mēs gribam, lai teksts iepriekšējā objekta teksts nebūtu redzams, tad mēs pievienojam konkrētajam elementam - objektam CSS parametru: position: relative. Līdz ar to tas kļūst spēcīgāks un iepriekšējā elementa teksts vairs nelien virsū konkrētajam elementam. Vēl lielākam spēkam mēs varam pielietot CSS parametru: z-index: 3. Norādot lielāku vērtību. */

/* Ja mēs izmantojam CSS pozicionēšanas parametrus: position: relative un left, right, top, bottom, mēs ievērojam BEM metodoloģiju, jo, pat tad, ja izmantojam tos BEM blokam, tie nekādi neietekmē objektu - elementu apkārtni. Atceramies, ka BEM blokiem mēs nedrīkstam izmantot CSS parametru: margin, jo tad tiek ietekmēti visi lapas elementi - objekti, un netiek ievērota BEM metodoloģija. */

/* Ja izmantojam CSS pozicionēšanas parametrus ar negatīvām vērtībām, tad faktiski elementi tiek nobīdīti uz pretējo pusi. Piemēram left: -20px būs tas pats, kas right: 20px. Tas pats arī notiek ar top un bottom. */

/* CSS pozicionēšanas parametrs: position: relative kopā ar pseido elementiem atver mums milzīgas iespējas, bet to mēs izskatīsim vēlāk. */

/* Nākošais CSS pozicionēšanas parametrs, kuru mēs apgūsim ir: position: absolute, kas it kā izgriež elementu no koda un tas paliek karājoties gaisā. tas vairs neietekmē blakus esošos elementus - objektus. Izmantojot CSS pozicionēšanas parametrus: top, bottom, left un right: elementam mainās tā pozīcija un tas tiek nobīdīts uz vienu vai otru pusi atkarībā no tā vecāka, kam ir norādīts CSS pozicionēšanas parametrs: position: relative. */

