
/* Sākumā atceramies kā pieslēgt šriftus: */

@import url("https://fonts.googleapis.com/css?family=Poppins:regular,700&display=swap");


@font-face {
	font-family: "Gilroy";
	src:
		url("../fonts/Gilroy-Regular.woff2") format("woff2"),
		url("../fonts/Gilroy-Regular.woff") format("woff");
	font-weight: normal;
	font-style: normal;
	font-display: swap;
}

@font-face {
	font-family: "Gilroy";
	src:
		url("../fonts/Gilroy-Bold.woff2") format("woff2"),
		url("../fonts/Gilroy-Bold.woff") format("woff");
	font-weight: bold;
	font-style: normal;
	font-display: swap;
}

body {
	font-family: "Gilroy", sans-serif;
	font-size: 16px;
	font-weight: 400;
}

/* Šodien, šinī lekcijā mēs mācīsimies jaunu moduli: flex. Flex modulis ir domāts, lai veidotu konstrukcijas. */

/* Līdz šim mēs veidojām konstrukcijas ar tām zināšanas, kas mums jau ir. Bet tagad sākot ar šodienu, mēs tās atstājam aiz muguras, pagātnē, jo turpmāk mēs strādāsim ar jaunu instrumentu: flex moduli. Strādāsim ar iepriekšējiem maketiem uzdevumiem, izmantojot: flex. */

/* Vēlāk, kursa beigās mēs apgūsim moduli: grid, bet tagad mums ir labi jāsaprot modulis: flex, lai beigās labāk saprastu: grid. */

/* Pierakstām HTML dokumentā dažus elementus, lai mēs uzskatāmāk saprastu jauno tēmu. Izveidojam bloku ar trīs elementiem, pievienojam tiem CSS parametrus. */

.block {
	border: 10px solid #8b0000;
}

.block__element {
	border: 10px solid #008000;
	padding: 20px;
	font-size: 30px;
	color: #fff;
}

/* Izmantojot dažus CSS parametrus, mēs padarām mūsu bloku un tā trīs elementus redzamus. Mēs to darām, lai labāk saprastu lekcijas tēmu. */

/* Mums HTML dokumentā: .block ir flex kastīte, konteineris, bet katrs: block__item ir flex elements. Iekš katra flex elementa ir flex saturs. */

/* Mēs redzam, ka iekš mūsu kastītes flex ir pirmā līmeņa ielikti trīs flex elementi, kam katram ir savs saturs. */

/* Kas tad īsti ir modulis: flex? Flexbox ir vesels modulis, kas sevī satur parametrus, kuru vērtības, kas tiek piemērotas vecākam: flex blokam: block, flex kastītei, kā arī flex elementiem. Galvenā flex priekšrocība ir: tā, ka tam ir  īpaša pielāgojamība lapas izstrādē, kad mēs varam pielāgot augstumu, platumu, apkārtējo laukumu un tā elementu: block__element atrašanās kārtību, lai izmantojot labāko pieeju aizpildītu pieejamo flex kastītes: block laukumu. Mēs varam mainīt flex elementu: block__element atrašanās kārtību, secību, nemainot neko iekš HTML dokumenta. */

/* Sākumā flex modulis mums liekas sarežģīts, bet ar laiku, ar pieredzi, mēs sapratīsim kā tieši tas darbojas un kādēļ mums tas ir jāizmanto. Jo mūsdienās, lapu izstrāde nav iedomājama bez moduļa flex. */

/* Mums ir vienmēr jāatceras, kad mēs ieslēdzam flex moduli, jo pagaidām mums ir vienkāršas <div></div> kastītes iekš HTML dokumenta. Jo pagaidām mums ir vienkārši bloks ar trīs elementiem, kas arī ir bloka tipa elementi, kuru īpašības mēs jau zinam. */

/* Ja mēs gribam ieslēgt flex moduli, mums ir jāvēršas pie tā bloka, kuram mēs gribam to ieslēgt. Mēs vēršamies pie vecāka, kas mūsu gadījumā ir: block. Mēs vēršamies pie galvenā objekta, kuru iekšienē mēs gribam ko mainīt. Izskatām to ar piemēru: */

/* Flex block. */

.block {
	/* Flex moduļa ieslēgšana: */
	display: flex;
}

/* Flex elementi. */

.block__element {

}

/* Mēs vēršamies pie galvenā bloka, kura struktūru mēs vēlamies mainīt. Kad mēs gribam veidot kādu konstrukciju. Mēs no flex elementiem: block__element vēlamies uzbūvēt kādu konstrukciju. */

/* Atzīmējam piemērā, kurš ir flex bloks un, kur ir flex elementi. */

/* Vispirms mums būsu flex blokam ir jāieslēdz flex konstrukcija. Tā kā piemērā augstāk: */

/* Mums jau ir zināms CSS parametrs: display, kura vērtības ir: block, inline, inline-block un none. Tas nozīmē, ka mēs varam globāli mainīt elementu struktūru. Tagad mums nāk klāt jauna CSS parametra: display: vērtība: flex; */

/* Mēs redzam, ka tad, kad izmantojam CSS parametru: display: flex, mums visi flex elementi: block__element ir sastājušies vienā rindā. Sākotnēji tie bija viens zem otra, bet tagad tie ir iekš vecāka: block sastājušies vienā rindā. */

/* Kas tad tieši notika, brīdī, kad ieslēdzām flex moduli mūsu blokam. Notika divas lietas: 1) flex elementi sarindojās vienā rindā pa asi X. Mūsu elementi kļūst itkā par bloka-rindas tipa elementiem. 2) Flex moduļa elementi: block__element katrs aizņem tik platības - laukumu, cik ir tā saturs. */

/* Mēs redzam, ka mūsu flex elementi ir kļuvuši par itkā bloka rindas tipa elementiem, jo to platums ir atkarīgs no to satura un uz tiem darbojās daudzi CSS parametri, bet tā tas nav. */

/* Mēs redzam, ka atšķirībā no inline - rindas tipa elementiem, uz flex elementiem darbojās CSS parametri, kas nedarbojās uz rindas tipa elementiem, piemēram: padding. */

/* Jo ir viena būtiska atšķirība - tie no bloka rindas tipa elementiem atšķiras ar to darbību - uzvedību. Pirmā būtiska darbības atšķirība ir tā, ka mūsu flex elementi, samazinoties ekrāna platumam nepāriet jaunā rindā. Otrkārt pie flex izmantošanas tiek citādi izlīdzināti elementi. */

/* Agrāk, lai izlīdzinātu elementus mēs izmantojām CSS parametru: vertical-align, lai kaut kā izlīdzinātu bloka rindas tipa elementus. Bet šeit arī tas strādā citādāk. Šeit arī vis itkā notiek tā pat, kā ar bloka rindas tipa elementiem, bet, kad izmantojam flex moduli, tad elementi tiek izlīdzināti no lapas kreisās puses uz labo, pa asi X. */

/* Ievērojam sīkumu, ka kad izmantojam moduli flex, mums zūd arī elementu fantomu atstarpes. Atceramies sākuma lekcijas, kad mācījāmies par attēliem, mums bija veids kā noņemt šuvju atstarpes. Tagad, kad izmantojam flex moduli, mums tās vairs neveidojas. */

/* Būtiski, kas mums ir jāatceras ir tas, ka: nav svarīgi kāda tipa elementi ir iekš flex moduļa, tie var būt jeb kāda tipa elementi, arī rindas tipa elementi, Flex modulis strādā pilnīgi vienādi. Par to pārliecināties mēs varam iekš HTML dokumenta izveidojot no konteinera kastītes tegu: <span></span>. Un mēs redzam, ka, ja izslēdzam flex moduli, tam nedarbojas daudzi CSS parametri, bet, kad ieslēdzam moduli: flex, mēs redzam, ka tas strādā tieši tā pat, kad mums ir konteinera kastīte - atvilkne. */

/* Jo brīdī, kad mēs vecākam ieslēdzam: flex moduli, visi tā elementi, kas ir iekš tā kļūst it kā bloka rindas tipa elementi un uz visiem tiem darbojās daudzie CSS parametri, kuri mums līdz šim mums ar rindas tipa elementiem nedarbojas. */

/* Ievērojam, ka modulis flex, kas ir ieslēgts vecākām un tas darbojās uz pirmās pakāpes ieliktajiem elementiem, tas nedarbosies uz otrās vai trešās pakāpes ieliktajiem elementiem. */

/* Ja mēs gribam izmantot flex moduli, flex elementiem, tiem ir jābūt vienam kopīgam vecākam. Mūsu gadījumā: block. */

/* Neatkarīgi no tā, kāda tipa elements ir mūsu bloks, kuram mēs piemērojam moduli: flex, tas automātiski kļūst par bloka tipa elementu. Par to pārliecināmies arī, ja mēs mūsu bloku, kas ir kastīte pārveidojam par tegu: <span></span>. Tiklīdz mēs ieslēdzam moduli flex, attiecīgais elements kļūst par bloka tipa elementu. Bet elementi, kas ir iekš šī bloka, tie itkā kļūst par bloka rindas tipa elementiem. Atceramies: ka modulim: flex un bloka rindas tipa elementiem tomēr irr būtiskas atšķirības, kuras mēs jau izskatījām augstāk pierakstos. */

/* Elements, kuram būs ieslēgts modulis: flex kļūs par bloka tipa elementu un aizņems visu lapas platību, tā kā mūsu piemērā: block. Vēlāk mēs izskatīsim ar piemēriem, kā mēs flex modulim varam noteikt, ierobežot tā platību. Tas aizņems visu sava vecāka platību, atkarībā kur tas atrodas. */

/* Flex modulim ir vēl viena vērtība, kas bloku, kad tam nosakām: display: inline-flex pārveido par rindas tipa elementu, kas aizņem tik platības, cik ir tā saturā: flex elementi. Izskatām to ar mūsu bloka piemēru: */

/*
.block {
display: inline-flex;
} */

/* Būtiski: ja izmantojam: display: inline-flex, tas itkā kļūst par rindas tipa elementu, ar visām tām īpašībām, kas ir rindas tipa elementiem. Bet par cik tas tomēr ir modulis: flex, uz tā elementiem turpina darboties daudzie CSS parametri, kas nedarbojās uz rindas tipa elementiem. */

/* Atceramies no teorijas, ka flex modulis ir domāts, lai labāk aizpildītu tā laukumu. Mūsu gadījumā flex modulis ir ieslēgts blokam, un, lai labāk aizpildītu esošo bloka laukumu, pielāgotu flex elementus, mēs apgūstam jaunus flex moduļa parametrus */

/* Būtiski, ka pielāgot flex bloka aizpildīšanās laukumu ar flex elementiem, mēs varam tikai tad, kad izmantojam CSS parametru: display: flex;. Mēs nevaram to izdarīt, ja izmantojam display: inline-flex. */

/* Un tas ir pašsaprotami, ka, ja mēs izmantojam inline-flex, mēs nevaram strādāt ar tā laukumu, jo laukums tiek aizpildīts, tik cik ir elementu saturs, tam nav nekāda papildus laukuma. */

/* Apgūstam jaunu moduļa flex CSS parametru: flex-wrap: nowrap;, kas atbild par to, vai flex elementi tiks pārnesti jaunā rindā, kad tie vairs neietilps iekš flex konteinera - bloka. Pēc noklusējuma tā vērtība ir: nowrap, kas nozīmē, ka mainoties flex konteinera - elementu vecāka platumam, flex elementi netiks pārnesti jaunā rindā. Tie ir cieši viens pie otra, bez jebkādām fantoma atstarpēm, tā itkā tie būtu sacementēti. */

/* Bet mēs šo flex moduļa parametru varam mainīt: no flex-wrap: nowrap uz: flex-wrap: wrap, kas nozīmē, ka tagad, ja mainīsies vecāka platums, tad flex elementi tiks pārnesti jaunā rindā. Izslēdzam iepriekšējo aktīvo kodu. Izskatām to ar piemēru: */

/* 
.block {
	display: flex;
	flex-wrap: wrap;
} */

/* Mēs redzam, ka tagad mūsu flex elementi, mainoties vecāka platumam, mainoties flex konteinera platumam tiek pārnesti jaunā rindā. */


/* Nākošais flex moduļa parametrs ir: justify-content: kura vērtības nosaka kādā virzienā tiks izlīdzināti flex elementi pa galveno asi: X. Tā noklusējuma vērtība ir: flex-start, kas nozīmē, ka flex elementi tiks novietoti flex konteinera sākumā. Izskatām vairākas justify-content vērtības: */

/*
.block {
	display: flex;
	justify-content: flex-start;
} */

/* Mēs redzam, ka mūsu flex elementi ir izlīdzināti pa galveno asi: X, no kreisās puses uz labo pusi. */

/* Ši parametra: justify-content: vērtības ir līdzīgas kā CSS parametram: text-align, kuru mēs jau labi zinam. Attiecīgi, ja ir justify-content: flex-start, tad ir arī justify-content: flex-end, kuru izmantojot, mēs redzam, ka flex elementi tiek piespiesti pie flex konteinera labās puses. Izslēdzam iepriekšējo aktīvo kodu un izskatām to ar piemēru: */

/*
.block {
	display: flex;
	justify-content: flex-end;
} */

/* Šī parametra darbība ir atkarīga no flex moduļa parametra: flex-direction, kas pēc noklusējuma ir pa asi X. */

/* Ja mēs izmantojam: justify-content: center, tad mūsu flex elementi tiks izlīdzināti pa galveno asi: X, tā, lai tie būtu centrā. Izslēdzam iepriekšējo aktīvo kodu un izskatām to ar piemēru: */

/*
.block {
	display: flex;
	justify-content: center;
} */

/* Mēs redzam, ka mūsu flex elementi ir izlīdzināti pa galveno asi: X, tā, lai tie būtu centrā. */

/* Ja mēs izmantojam: justify-content: space-between, tad mūsu flex elementi tiks izlīdzināti pa galveno asi: X, tā, lai starp tiem būtu vienādas atstarpes. Izslēdzam iepriekšējo aktīvo kodu un izskatām to ar piemēru: */

/* 
.block {
	display: flex;
	justify-content: space-between;
} */

/* Mēs redzam, ka mūsu flex elementi ir izlīdzināti pa galveno asi: X, tā, lai starp tiem būtu vienādas atstarpes. Tie ir izlīdzināti tā, lai aizņemtu visu flex konteinera platumu. */

/* Ja mēs izmantojam: justify-content: space-around, tad mūsu flex elementi tiks izlīdzināti pa galveno asi: X, tā, lai starp tiem būtu vienādas atstarpes, bet arī no abām pusēm. Izslēdzam iepriekšējo aktīvo kodu un izskatām to ar piemēru: */

/*
.block {
	display: flex;
	justify-content: space-around;
} */

/* Mēs redzam, ka mūsu flex elementi ir izlīdzināti pa galveno asi: X, tā, lai starp tiem būtu vienādas atstarpes, arī no flex elementu abām pusēm. */

/* Atceramies: Šis flex parametrs darbojās tikai tad, ja flex konteineram ir brīva vieta. Ja mums ir ieslēgts flex modulis: display: flex. Jo, ja mums nav vietas flex konteinerā, tad šis parametrs nedarbojās. Piemēram, ja mums ir ieslēgts flex modulis: display: inline-flex. */

/* Šis attiecas arī uz situāciju, kad mums ir ieslēgts: display: flex, un mums tur nav brīvas vietas. Tad nedarbosies CSS parametrs: justify-content, jo mums vienkārši iekš flex konteinera nav brivas vietas. */

/* Vēl viena flex moduļa parametra: justify-content: vērtība ir: justify-content: space-evenly, kas nosaka, ka flex elementi tiks izvietoti ar vienādu atstarpi. Ar tik lielu atstarpi cik ir flex konteinerī vietas. Izslēdzam iepriekšējo aktīvo kodu un izskatām to ar piemēru: */

/*
.block {
	display: flex;
	justify-content: space-evenly;
} */

/* Mēs redzam, ka mūsu flex elementi ir izlīdzināti pa galveno asi: X, tā, lai starp tiem būtu vienādas atstarpes, tik cik ir brīvas vietas flex konteinerī. */

/* Šī justify-content vērtība: space-evenly ir līdzīga vērtībai: space-between, bet šinī tiek piemērota flex vienāda atstarpe flex konteinera sākumā un beigās. */

/* Lai izskatītu nākošo piemēru, izslēdzam iepriekšējos aktīvos kodus un pierakstām flex moduļa noklusējuma vērtības: display: flex un justify-content: flex-start. */
/*
.block {
	display: flex;
	justify-content: flex-start;
} */

/* Izveidojam situāciju, kad otrajā flex elementā mums ir vairāk satura. Lai to izdarītu izmantojam HTML. */

/* Un šeit mēs redzam visas flex moduļa izmantošanas priekšrocības. Mums ir vairāk satura iekš otrā flex elementa, tas kļūst augstāks. Visi pārējie flex elementi tiek arī automātiski kļuvuši augstāki. Tie piemērojas otrajam flex elementam. */

/* Līdz šim šādu efektu mēs nevarējām panākt. Ar tām zināšanām, kas mums bija līdz šai lekcijai. Bet tagad mēs to varam, izmantojot moduli: flex. */

/* Būtisks moduļa: flex parametrs ir: align-items: stretch, kas nosaka, ka visi flex elementi tiks izstiepti pa asi Y, kas ir lapas augstums, no augšas uz leju. */

/* Šis parametrs darbojas kopā ar flex parametru: flex-direction. */

/* Flex moduļa parametra: align-items: stretch nozīmē, ka flex konteineris ir kā gumija, tas pielāgojas lapas augstumam. Atceramies, ka mūsu lapā elementi tiek izvietoti no augšas uz leju un no kreisās uz labo pusi. */

/* Vis flex modulis, darbojas pēc principa: ja kāds no tā elementiem kļūst augstāks, tad attiecīgi visi pārējie elementi arī kļūst tāda paša augstuma, kāds ir augstākais elements. */

/* Flex moduļa parametra: align-items vērtības ir ļoti līdzīgas parametram: justify-content. Atceramies, ka justify-content nosaka flex elementu izvietošanos pa asi X, bet align-items pa asi Y. */

/* Ja izmantosim align-items: flex-start;, tad mūsu flex elementi tiks piespiesti pie flex konteinera augšas. Bet align-items: flex-end piespiedīs flex elementus pie flex konteinera apakšas. */

/* Ja izmantosim align-items: center;, tad mūsu flex elementi tiks izvietoti tā, lai tie būtu centrā pa asi Y. */

/* Ir vēl viena flex moduļa parametra: align-items vērtība: baseline, kas izlīdzina flex elementus tā, lai teksts būtu vidū. Flex elementi tiek izvietoti atkarībā no šrifta līnijas. Tas ir atkarīgs, cik liels šrifts tiek izmantots flex elementiem. Ja viens flex elements ir augstāks par pērējiem, tad pārējo elementus šrifts līdzinās augstākajam šriftam. */

/* Kā nākošo flex moduļa parametru mēs apgūstam: flex-direction, kam noklusētā vērtība ir: row. Moduļa flex parametrs: flex-direction nosaka pamatasi, tādā veidā nosakot flex elementu virzienu, kas atrodas flex konteinerā. */

/* Pēc noklusējuma: flex-direction: vērtība: row, nozīmē no Angļu valodas: rinda. Tas nozīmē, ka pēc noklusējuma flex elementi tiek attēloti pa asi X rindā, viens aiz otra. */

/* Ja mēs šī flex parametra vērtību mainīsim uz: row-reverse, tad iegūsim to, ka mūsu flex elementi tiek apgriezti otrādi un piespiesti pie flex konteinera beigām, mūsu gadījumā: pie labās puses. Bet tie ir otrādā secībā. izskatām ar piemēru kā tas darbojas: */

/*
.block {
	display: flex;
	flex-direction: row-reverse;
}	*/

/* Mēs redzam, ka mūsu flex elementi ir piespiesti pie flex konteinera beigām, un to secība, ja skatāmies no lapas kreisās puses uz labo, ir pretēja. Kā pirmo mēs redzam pēdējo flex elementu, un kā pēdējo: mēs redzam pirmo flex elementu. */

/* Mēs redzam, ka visa elementu rinda tiek apgriezta uz pretējo pusi. Nejaucam ar flex moduļa parametru: justify-content: flex-end, jo tas noliek flex elementus flex konteinera beigās, bet parametrs: flex-direction: row-reverse; ne tikai novieto elementus flex konteinera beigās, bet tas apgriež to kārtību. Ja pie iepriekšējā parametra flex elementi izvietojās secībā no kreisās puses uz labo, tad šeit tie izvietojas pretēji: no labās puses uz kreiso pusi. */

/* Kad izmantojam flex parametru: flex-direction: row-reverse mūsu līnija, ass X mainās uz pretējo pusi, tā iet no lapas labās puses uz kreiso pusi. */

/* Ja mēs izmantojam flex moduļa parametru: flex-direction: row-reverse kopā ar flex parametru: justify-content: flex-start, vai kādu citu vērtību, tad tas darbojas tieši tā pat kā iepriekš, tikai flex elementu kārtība ir apgriezta otrādi. */

/* Mēs redzam, ka piepildās flex moduļa nosacījums, ka: Mēs varam mainīt flex elementu kārtību izmantojot tikai CSS flex moduļa parametrus. Mums nav nepieciešams ko mainīt HTML failā. */

/* Līdz šim, līdz flex moduļa iepazīšanai mēs mainīt elementu kārtību no CSS faila varējām tikai ja izmantojām pozicionēšanas parametrus ar position: absolute utt, bet tas būtu risinājums tikai tad, ja mēs zinātu, ka elementi nemainīsies, netiks mainīts to daudzums un saturs. Bet mēs jau zinam, ka lapu izstrāde paredz to, ka lapas saturs tiks mainīts, un mums ir jānodrošina stabila - uzticama lapas izstrāde, kas nesalūzt pie mazākām izmaiņām. */

/* Tagad, kad zinam flex moduli, mēs varam ar pāris kodu rindām mainīt elementu kārtību. */

/* Flex parametram: flex-direction ir vēl vērtība: column. Izskatām to ar piemēru: */

/*
.block {
	display: flex;
	flex-direction: column;
} */

/* Kas tad notiek? Mēs redzam, ka mūsu flex elementi ir sākotnējā stāvoklī, kad mums nebija ieslēgts modulis: flex. Notika ass maiņas. Mums galvenā ass bija X un pēc tam ass Y, bet tagad ir pretēji, tagad mūsu galvenā ass ir Y un pēc tam X. Un tieši tādēļ mēs iegūstam šādu rezultātu. Mūsu galvenā ass ir no lapas augšas uz leju. Un tieši šī iemesla dēļ mēs redzam šādu rezultātu. */

/* Lai mēs redzētu kā tagad darbojās moduļa flex parametri: flex-direction: column un justify-content: ar jau ierastajām vērtībām, mums jāpalielina flex konteinera augstums. Izskatām to ar piemēru: */

.block {
	display: flex;
	flex-direction: column;
	height: 600px;
	justify-content: flex-end;
}

/* Rezultātā mēs redzam, ka mūsu flex elementi ir novietojušies pa asi Y, no augšas uz leju, flex konteinera beigās. Mēs izmantojot parametru: height palielinājām flex konteinera augstumu, lai varētu izmantot flex moduļa parametru: justify-content, jo atceramies: ka tas darbojas tikai tad, ja flex konteinerā ir brīva vieta. */