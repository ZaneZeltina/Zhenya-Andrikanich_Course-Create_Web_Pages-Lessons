
/* Sākumā atceramies kā pieslēgt šriftus: */

@import url("https://fonts.googleapis.com/css?family=Poppins:regular,700&display=swap");


@font-face {
	font-family: "Gilroy";
	src:
		url("../fonts/Gilroy-Regular.woff2") format("woff2"),
		url("../fonts/Gilroy-Regular.woff") format("woff");
	font-weight: normal;
	font-style: normal;
	font-display: swap;
}

@font-face {
	font-family: "Gilroy";
	src:
		url("../fonts/Gilroy-Bold.woff2") format("woff2"),
		url("../fonts/Gilroy-Bold.woff") format("woff");
	font-weight: bold;
	font-style: normal;
	font-display: swap;
}

body {
	font-family: "Gilroy", sans-serif;
	font-size: 16px;
	font-weight: 400;
}

/* Šodien, šinī lekcijā mēs mācīsimies jaunu moduli: flex. Flex modulis ir domāts, lai veidotu konstrukcijas. */

/* Līdz šim mēs veidojām konstrukcijas ar tām zināšanas, kas mums jau ir. Bet tagad sākot ar šodienu, mēs tās atstājam aiz muguras, pagātnē, jo turpmāk mēs strādāsim ar jaunu instrumentu: flex moduli. Strādāsim ar iepriekšējiem maketiem uzdevumiem, izmantojot: flex. */

/* Vēlāk, kursa beigās mēs apgūsim moduli: grid, bet tagad mums ir labi jāsaprot modulis: flex, lai beigās labāk saprastu: grid. */

/* Pierakstām HTML dokumentā dažus elementus, lai mēs uzskatāmāk saprastu jauno tēmu. Izveidojam bloku ar trīs elementiem, pievienojam tiem CSS parametrus. */

.block {
	/* border: 10px solid #794f45; */
}

.block__element {
	/* border: 10px solid #7a956b; */
	/* padding: 20px; */
	font-size: 30px;
	color: #fff;
}

/* Izmantojot dažus CSS parametrus, mēs padarām mūsu bloku un tā trīs elementus redzamus. Mēs to darām, lai labāk saprastu lekcijas tēmu. */

/* Mums HTML dokumentā: .block ir flex kastīte, konteineris, bet katrs: block__item ir flex elements. Iekš katra flex elementa ir flex saturs. */

/* Mēs redzam, ka iekš mūsu kastītes flex ir pirmā līmeņa ielikti trīs flex elementi, kam katram ir savs saturs. */

/* Kas tad īsti ir modulis: flex? Flexbox ir vesels modulis, kas sevī satur parametrus, kuru vērtības, kas tiek piemērotas vecākam: flex blokam: block, flex kastītei, kā arī flex elementiem. Galvenā flex priekšrocība ir: tā, ka tam ir  īpaša pielāgojamība lapas izstrādē, kad mēs varam pielāgot augstumu, platumu, apkārtējo laukumu un tā elementu: block__element atrašanās kārtību, lai izmantojot labāko pieeju aizpildītu pieejamo flex kastītes: block laukumu. Mēs varam mainīt flex elementu: block__element atrašanās kārtību, secību, nemainot neko iekš HTML dokumenta. */

/* Sākumā flex modulis mums liekas sarežģīts, bet ar laiku, ar pieredzi, mēs sapratīsim kā tieši tas darbojas un kādēļ mums tas ir jāizmanto. Jo mūsdienās, lapu izstrāde nav iedomājama bez moduļa flex. */

/* Mums ir vienmēr jāatceras, kad mēs ieslēdzam flex moduli, jo pagaidām mums ir vienkāršas <div></div> kastītes iekš HTML dokumenta. Jo pagaidām mums ir vienkārši bloks ar trīs elementiem, kas arī ir bloka tipa elementi, kuru īpašības mēs jau zinam. */

/* Ja mēs gribam ieslēgt flex moduli, mums ir jāvēršas pie tā bloka, kuram mēs gribam to ieslēgt. Mēs vēršamies pie vecāka, kas mūsu gadījumā ir: block. Mēs vēršamies pie galvenā objekta, kuru iekšienē mēs gribam ko mainīt. Izskatām to ar piemēru: */

/* Flex block. */

.block {
	/* Flex moduļa ieslēgšana: */
	display: flex;
}

/* Flex elementi. */

.block__element {

}

/* Mēs vēršamies pie galvenā bloka, kura struktūru mēs vēlamies mainīt. Kad mēs gribam veidot kādu konstrukciju. Mēs no flex elementiem: block__element vēlamies uzbūvēt kādu konstrukciju. */

/* Atzīmējam piemērā, kurš ir flex bloks un, kur ir flex elementi. */

/* Vispirms mums būsu flex blokam ir jāieslēdz flex konstrukcija. Tā kā piemērā augstāk: */

/* Mums jau ir zināms CSS parametrs: display, kura vērtības ir: block, inline, inline-block un none. Tas nozīmē, ka mēs varam globāli mainīt elementu struktūru. Tagad mums nāk klāt jauna CSS parametra: display: vērtība: flex; */

/* Mēs redzam, ka tad, kad izmantojam CSS parametru: display: flex, mums visi flex elementi: block__element ir sastājušies vienā rindā. Sākotnēji tie bija viens zem otra, bet tagad tie ir iekš vecāka: block sastājušies vienā rindā. */

/* Kas tad tieši notika, brīdī, kad ieslēdzām flex moduli mūsu blokam. Notika divas lietas: 1) flex elementi sarindojās vienā rindā pa asi X. Mūsu elementi kļūst itkā par bloka-rindas tipa elementiem. 2) Flex moduļa elementi: block__element katrs aizņem tik platības - laukumu, cik ir tā saturs. */

/* Mēs redzam, ka mūsu flex elementi ir kļuvuši par itkā bloka rindas tipa elementiem, jo to platums ir atkarīgs no to satura un uz tiem darbojās daudzi CSS parametri, bet tā tas nav. */

/* Mēs redzam, ka atšķirībā no inline - rindas tipa elementiem, uz flex elementiem darbojās CSS parametri, kas nedarbojās uz rindas tipa elementiem, piemēram: padding. */

/* Jo ir viena būtiska atšķirība - tie no bloka rindas tipa elementiem atšķiras ar to darbību - uzvedību. Pirmā būtiska darbības atšķirība ir tā, ka mūsu flex elementi, samazinoties ekrāna platumam nepāriet jaunā rindā. Otrkārt pie flex izmantošanas tiek citādi izlīdzināti elementi. */

/* Agrāk, lai izlīdzinātu elementus mēs izmantojām CSS parametru: vertical-align, lai kaut kā izlīdzinātu bloka rindas tipa elementus. Bet šeit arī tas strādā citādāk. Šeit arī vis itkā notiek tā pat, kā ar bloka rindas tipa elementiem, bet, kad izmantojam flex moduli, tad elementi tiek izlīdzināti no lapas kreisās puses uz labo, pa asi X. */

/* Ievērojam sīkumu, ka kad izmantojam moduli flex, mums zūd arī elementu fantomu atstarpes. Atceramies sākuma lekcijas, kad mācījāmies par attēliem, mums bija veids kā noņemt šuvju atstarpes. Tagad, kad izmantojam flex moduli, mums tās vairs neveidojas. */

/* Būtiski, kas mums ir jāatceras ir tas, ka: nav svarīgi kāda tipa elementi ir iekš flex moduļa, tie var būt jeb kāda tipa elementi, arī rindas tipa elementi, Flex modulis strādā pilnīgi vienādi. Par to pārliecināties mēs varam iekš HTML dokumenta izveidojot no konteinera kastītes tegu: <span></span>. Un mēs redzam, ka, ja izslēdzam flex moduli, tam nedarbojas daudzi CSS parametri, bet, kad ieslēdzam moduli: flex, mēs redzam, ka tas strādā tieši tā pat, kad mums ir konteinera kastīte - atvilkne. */

/* Jo brīdī, kad mēs vecākam ieslēdzam: flex moduli, visi tā elementi, kas ir iekš tā kļūst it kā bloka rindas tipa elementi un uz visiem tiem darbojās daudzie CSS parametri, kuri mums līdz šim mums ar rindas tipa elementiem nedarbojas. */

/* Ievērojam, ka modulis flex, kas ir ieslēgts vecākām un tas darbojās uz pirmās pakāpes ieliktajiem elementiem, tas nedarbosies uz otrās vai trešās pakāpes ieliktajiem elementiem. */

/* Ja mēs gribam izmantot flex moduli, flex elementiem, tiem ir jābūt vienam kopīgam vecākam. Mūsu gadījumā: block. */

/* Neatkarīgi no tā, kāda tipa elements ir mūsu bloks, kuram mēs piemērojam moduli: flex, tas automātiski kļūst par bloka tipa elementu. Par to pārliecināmies arī, ja mēs mūsu bloku, kas ir kastīte pārveidojam par tegu: <span></span>. Tiklīdz mēs ieslēdzam moduli flex, attiecīgais elements kļūst par bloka tipa elementu. Bet elementi, kas ir iekš šī bloka, tie itkā kļūst par bloka rindas tipa elementiem. Atceramies: ka modulim: flex un bloka rindas tipa elementiem tomēr irr būtiskas atšķirības, kuras mēs jau izskatījām augstāk pierakstos. */

/* Elements, kuram būs ieslēgts modulis: flex kļūs par bloka tipa elementu un aizņems visu lapas platību, tā kā mūsu piemērā: block. Vēlāk mēs izskatīsim ar piemēriem, kā mēs flex modulim varam noteikt, ierobežot tā platību. Tas aizņems visu sava vecāka platību, atkarībā kur tas atrodas. */

/* Flex modulim ir vēl viena vērtība, kas bloku, kad tam nosakām: display: inline-flex pārveido par rindas tipa elementu, kas aizņem tik platības, cik ir tā saturā: flex elementi. Izskatām to ar mūsu bloka piemēru: */

/*
.block {
display: inline-flex;
} */

/* Būtiski: ja izmantojam: display: inline-flex, tas itkā kļūst par rindas tipa elementu, ar visām tām īpašībām, kas ir rindas tipa elementiem. Bet par cik tas tomēr ir modulis: flex, uz tā elementiem turpina darboties daudzie CSS parametri, kas nedarbojās uz rindas tipa elementiem. */

/* Atceramies no teorijas, ka flex modulis ir domāts, lai labāk aizpildītu tā laukumu. Mūsu gadījumā flex modulis ir ieslēgts blokam, un, lai labāk aizpildītu esošo bloka laukumu, pielāgotu flex elementus, mēs apgūstam jaunus flex moduļa parametrus */

/* Būtiski, ka pielāgot flex bloka aizpildīšanās laukumu ar flex elementiem, mēs varam tikai tad, kad izmantojam CSS parametru: display: flex;. Mēs nevaram to izdarīt, ja izmantojam display: inline-flex. */

/* Un tas ir pašsaprotami, ka, ja mēs izmantojam inline-flex, mēs nevaram strādāt ar tā laukumu, jo laukums tiek aizpildīts, tik cik ir elementu saturs, tam nav nekāda papildus laukuma. */

/* Apgūstam jaunu moduļa flex CSS parametru: flex-wrap: nowrap;, kas atbild par to, vai flex elementi tiks pārnesti jaunā rindā, kad tie vairs neietilps iekš flex konteinera - bloka. Pēc noklusējuma tā vērtība ir: nowrap, kas nozīmē, ka mainoties flex konteinera - elementu vecāka platumam, flex elementi netiks pārnesti jaunā rindā. Tie ir cieši viens pie otra, bez jebkādām fantoma atstarpēm, tā itkā tie būtu sacementēti. */

/* Bet mēs šo flex moduļa parametru varam mainīt: no flex-wrap: nowrap uz: flex-wrap: wrap, kas nozīmē, ka tagad, ja mainīsies vecāka platums, tad flex elementi tiks pārnesti jaunā rindā. Izslēdzam iepriekšējo aktīvo kodu. Izskatām to ar piemēru: */

/* 
.block {
	display: flex;
	flex-wrap: wrap;
} */

/* Mēs redzam, ka tagad mūsu flex elementi, mainoties vecāka platumam, mainoties flex konteinera platumam tiek pārnesti jaunā rindā. */


/* Nākošais flex moduļa parametrs ir: justify-content: kura vērtības nosaka kādā virzienā tiks izlīdzināti flex elementi pa galveno asi: X. Tā noklusējuma vērtība ir: flex-start, kas nozīmē, ka flex elementi tiks novietoti flex konteinera sākumā. Izskatām vairākas justify-content vērtības: */

/*
.block {
	display: flex;
	justify-content: flex-start;
} */

/* Mēs redzam, ka mūsu flex elementi ir izlīdzināti pa galveno asi: X, no kreisās puses uz labo pusi. */

/* Ši parametra: justify-content: vērtības ir līdzīgas kā CSS parametram: text-align, kuru mēs jau labi zinam. Attiecīgi, ja ir justify-content: flex-start, tad ir arī justify-content: flex-end, kuru izmantojot, mēs redzam, ka flex elementi tiek piespiesti pie flex konteinera labās puses. Izslēdzam iepriekšējo aktīvo kodu un izskatām to ar piemēru: */

/*
.block {
	display: flex;
	justify-content: flex-end;
} */

/* Šī parametra darbība ir atkarīga no flex moduļa parametra: flex-direction, kas pēc noklusējuma ir pa asi X. */

/* Ja mēs izmantojam: justify-content: center, tad mūsu flex elementi tiks izlīdzināti pa galveno asi: X, tā, lai tie būtu centrā. Izslēdzam iepriekšējo aktīvo kodu un izskatām to ar piemēru: */

/*
.block {
	display: flex;
	justify-content: center;
} */

/* Mēs redzam, ka mūsu flex elementi ir izlīdzināti pa galveno asi: X, tā, lai tie būtu centrā. */

/* Ja mēs izmantojam: justify-content: space-between, tad mūsu flex elementi tiks izlīdzināti pa galveno asi: X, tā, lai starp tiem būtu vienādas atstarpes. Izslēdzam iepriekšējo aktīvo kodu un izskatām to ar piemēru: */

/* 
.block {
	display: flex;
	justify-content: space-between;
} */

/* Mēs redzam, ka mūsu flex elementi ir izlīdzināti pa galveno asi: X, tā, lai starp tiem būtu vienādas atstarpes. Tie ir izlīdzināti tā, lai aizņemtu visu flex konteinera platumu. */

/* Ja mēs izmantojam: justify-content: space-around, tad mūsu flex elementi tiks izlīdzināti pa galveno asi: X, tā, lai starp tiem būtu vienādas atstarpes, bet arī no abām pusēm. Izslēdzam iepriekšējo aktīvo kodu un izskatām to ar piemēru: */

/*
.block {
	display: flex;
	justify-content: space-around;
} */

/* Mēs redzam, ka mūsu flex elementi ir izlīdzināti pa galveno asi: X, tā, lai starp tiem būtu vienādas atstarpes, arī no flex elementu abām pusēm. */

/* Atceramies: Šis flex parametrs darbojās tikai tad, ja flex konteineram ir brīva vieta. Ja mums ir ieslēgts flex modulis: display: flex. Jo, ja mums nav vietas flex konteinerā, tad šis parametrs nedarbojās. Piemēram, ja mums ir ieslēgts flex modulis: display: inline-flex. */

/* Šis attiecas arī uz situāciju, kad mums ir ieslēgts: display: flex, un mums tur nav brīvas vietas. Tad nedarbosies CSS parametrs: justify-content, jo mums vienkārši iekš flex konteinera nav brivas vietas. */

/* Vēl viena flex moduļa parametra: justify-content: vērtība ir: justify-content: space-evenly, kas nosaka, ka flex elementi tiks izvietoti ar vienādu atstarpi. Ar tik lielu atstarpi cik ir flex konteinerī vietas. Izslēdzam iepriekšējo aktīvo kodu un izskatām to ar piemēru: */

/*
.block {
	display: flex;
	justify-content: space-evenly;
} */

/* Mēs redzam, ka mūsu flex elementi ir izlīdzināti pa galveno asi: X, tā, lai starp tiem būtu vienādas atstarpes, tik cik ir brīvas vietas flex konteinerī. */

/* Šī justify-content vērtība: space-evenly ir līdzīga vērtībai: space-between, bet šinī tiek piemērota flex vienāda atstarpe flex konteinera sākumā un beigās. */

/* Lai izskatītu nākošo piemēru, izslēdzam iepriekšējos aktīvos kodus un pierakstām flex moduļa noklusējuma vērtības: display: flex un justify-content: flex-start. */
/*
.block {
	display: flex;
	justify-content: flex-start;
} */

/* Izveidojam situāciju, kad otrajā flex elementā mums ir vairāk satura. Lai to izdarītu izmantojam HTML. */

/* Un šeit mēs redzam visas flex moduļa izmantošanas priekšrocības. Mums ir vairāk satura iekš otrā flex elementa, tas kļūst augstāks. Visi pārējie flex elementi tiek arī automātiski kļuvuši augstāki. Tie piemērojas otrajam flex elementam. */

/* Līdz šim šādu efektu mēs nevarējām panākt. Ar tām zināšanām, kas mums bija līdz šai lekcijai. Bet tagad mēs to varam, izmantojot moduli: flex. */

/* Būtisks moduļa: flex parametrs ir: align-items: stretch, kas nosaka, ka visi flex elementi tiks izstiepti pa asi Y, kas ir lapas augstums, no augšas uz leju. */

/* Šis parametrs darbojas kopā ar flex parametru: flex-direction. */

/* Flex moduļa parametra: align-items: stretch nozīmē, ka flex konteineris ir kā gumija, tas pielāgojas lapas augstumam. Atceramies, ka mūsu lapā elementi tiek izvietoti no augšas uz leju un no kreisās uz labo pusi. */

/* Vis flex modulis, darbojas pēc principa: ja kāds no tā elementiem kļūst augstāks, tad attiecīgi visi pārējie elementi arī kļūst tāda paša augstuma, kāds ir augstākais elements. */

/* Flex moduļa parametra: align-items vērtības ir ļoti līdzīgas parametram: justify-content. Atceramies, ka justify-content nosaka flex elementu izvietošanos pa asi X, bet align-items pa asi Y. */

/* Ja izmantosim align-items: flex-start;, tad mūsu flex elementi tiks piespiesti pie flex konteinera augšas. Bet align-items: flex-end piespiedīs flex elementus pie flex konteinera apakšas. */

/* Ja izmantosim align-items: center;, tad mūsu flex elementi tiks izvietoti tā, lai tie būtu centrā pa asi Y. */

/* Ir vēl viena flex moduļa parametra: align-items vērtība: baseline, kas izlīdzina flex elementus tā, lai teksts būtu vidū. Flex elementi tiek izvietoti atkarībā no šrifta līnijas. Tas ir atkarīgs, cik liels šrifts tiek izmantots flex elementiem. Ja viens flex elements ir augstāks par pērējiem, tad pārējo elementus šrifts līdzinās augstākajam šriftam. */

/* Kā nākošo flex moduļa parametru mēs apgūstam: flex-direction, kam noklusētā vērtība ir: row. Moduļa flex parametrs: flex-direction nosaka pamatasi, tādā veidā nosakot flex elementu virzienu, kas atrodas flex konteinerā. */

/* Pēc noklusējuma: flex-direction: vērtība: row, nozīmē no Angļu valodas: rinda. Tas nozīmē, ka pēc noklusējuma flex elementi tiek attēloti pa asi X rindā, viens aiz otra. */

/* Ja mēs šī flex parametra vērtību mainīsim uz: row-reverse, tad iegūsim to, ka mūsu flex elementi tiek apgriezti otrādi un piespiesti pie flex konteinera beigām, mūsu gadījumā: pie labās puses. Bet tie ir otrādā secībā. izskatām ar piemēru kā tas darbojas: */

/*
.block {
	display: flex;
	flex-direction: row-reverse;
}	*/

/* Mēs redzam, ka mūsu flex elementi ir piespiesti pie flex konteinera beigām, un to secība, ja skatāmies no lapas kreisās puses uz labo, ir pretēja. Kā pirmo mēs redzam pēdējo flex elementu, un kā pēdējo: mēs redzam pirmo flex elementu. */

/* Mēs redzam, ka visa elementu rinda tiek apgriezta uz pretējo pusi. Nejaucam ar flex moduļa parametru: justify-content: flex-end, jo tas noliek flex elementus flex konteinera beigās, bet parametrs: flex-direction: row-reverse; ne tikai novieto elementus flex konteinera beigās, bet tas apgriež to kārtību. Ja pie iepriekšējā parametra flex elementi izvietojās secībā no kreisās puses uz labo, tad šeit tie izvietojas pretēji: no labās puses uz kreiso pusi. */

/* Kad izmantojam flex parametru: flex-direction: row-reverse mūsu līnija, ass X mainās uz pretējo pusi, tā iet no lapas labās puses uz kreiso pusi. */

/* Ja mēs izmantojam flex moduļa parametru: flex-direction: row-reverse kopā ar flex parametru: justify-content: flex-start, vai kādu citu vērtību, tad tas darbojas tieši tā pat kā iepriekš, tikai flex elementu kārtība ir apgriezta otrādi. */

/* Mēs redzam, ka piepildās flex moduļa nosacījums, ka: Mēs varam mainīt flex elementu kārtību izmantojot tikai CSS flex moduļa parametrus. Mums nav nepieciešams ko mainīt HTML failā. */

/* Līdz šim, līdz flex moduļa iepazīšanai mēs mainīt elementu kārtību no CSS faila varējām tikai ja izmantojām pozicionēšanas parametrus ar position: absolute utt, bet tas būtu risinājums tikai tad, ja mēs zinātu, ka elementi nemainīsies, netiks mainīts to daudzums un saturs. Bet mēs jau zinam, ka lapu izstrāde paredz to, ka lapas saturs tiks mainīts, un mums ir jānodrošina stabila - uzticama lapas izstrāde, kas nesalūzt pie mazākām izmaiņām. */

/* Tagad, kad zinam flex moduli, mēs varam ar pāris kodu rindām mainīt elementu kārtību. */

/* Flex parametram: flex-direction ir vēl vērtība: column. Izskatām to ar piemēru: */

/*
.block {
	display: flex;
	flex-direction: column;
} */

/* Kas tad notiek? Mēs redzam, ka mūsu flex elementi ir sākotnējā stāvoklī, kad mums nebija ieslēgts modulis: flex. Notika ass maiņas. Mums galvenā ass bija X un pēc tam ass Y, bet tagad ir pretēji, tagad mūsu galvenā ass ir Y un pēc tam X. Un tieši tādēļ mēs iegūstam šādu rezultātu. Mūsu galvenā ass ir no lapas augšas uz leju. Un tieši šī iemesla dēļ mēs redzam šādu rezultātu. */

/* Lai mēs redzētu kā tagad darbojās moduļa flex parametri: flex-direction: column un justify-content: ar jau ierastajām vērtībām, mums jāpalielina flex konteinera augstums. Izskatām to ar piemēru: */

/*
.block {
	display: flex;
	flex-direction: column;
	height: 600px;
	justify-content: flex-start;
} */

/* Rezultātā mēs redzam, ka mūsu flex elementi ir novietojušies pa asi Y, no augšas uz leju, flex konteinera beigās. Mēs izmantojot parametru: height palielinājām flex konteinera augstumu, lai varētu izmantot flex moduļa parametru: justify-content, jo atceramies: ka tas darbojas tikai tad, ja flex konteinerā ir brīva vieta. */

/* Mainot flex moduļa parametra: justify-content vērtības, mēs redzam kā tas darbojas pa mūsu tagad galveno asi Y. Visas vērtības darbojas tieši tā pat, kā, kad bija galvenā ass X, tikai tagad vis notiek no lapas augšas uz leju. */

/* Kas notiek, ja mēs pievienojam flex moduļa parametru: align-items: flex-start;. Mēs redzam, ka mūsu flex elementi piespiežas pie augšas un iet rindā uz leju, jo mēs tiem esam noteikuši flex parametru: flex-direction: column. */

/* Izskatām to ar piemēru: */

/*
.block {
	align-items: flex-start;
} */

/* Mēs redzam, ka mūsu flex elementi ir izvietojušies pa galveno asi Y, no augšas uz leju, un par cik tiem ir noteikts flex parametrs: align-items: flex-start, mēs redzam, ka flex elementi ir pielipuši - novietojušies cieši kopā pie flex konteinera sākuma. Atceramies, ka sākums tagad mums ir pa asi Y. */

/* Mainot flex moduļa parametru: align-items: vērtības mēs redzam kā mūsu flex elementi izvietojas tieši tā kā pa asi X, bet tagad tie tieši tā pat izvietojas pa asi Y. */

/* Ieteikums: Kā mēs varam panākt, ka visi mūsu flex elementi ir flex konteinera centrā: mums jāpieraksta sekojoši: */

/*
.block {
	justify-content: center;
	align-items: center;
} */

/* Mēs iegūstam, ka visi mūsu flex elementi ir flex konteinera centrā. Neatkarīgi vai flex moduļa parametrs ir ar vērtībām: flex-direction: row vai flex-direction: column. Mainās tikai galvenā ass, bet mūsu flex elementi ir centrā. */

/* Mainās tikai tas, vai mūsu elementi ir rindā - row vai kolonā uz leju pa asi Y. Atceramies, ka pie vērtības: row mūsu galvenā ass ir X, bet pie vērtības: column galvenā ass ir Y. */

/* Ja mums ir flex parametrs: flex-direction: row-reverse, tad mums ir arī: flex-direction: column-reverse, kas atkal apgriež flex elementus, bet jau pa asi Y, bet tagad mūsu ass Y maina virzienu uz pretējo pusi: no lapas apakšas uz lapas augšu. */

/* Lai labāk saprastu kā tas darbojās, izslēdzam iepriekšējos aktīvos kodus un pierakstām sekojošu piemēru: */

/*
.block {
	display: flex;
	height: 600px;
	flex-direction: column-reverse;
} */

/* Rezultātā mēs iegūstam, ka mūsu flex elementi ir apgriezti otrādi pa asi Y, pretējā secībā, pirmais flex elements ir pašā flex konteinera apakšā. */

/* Un mums atkal ir iespēja, tikai šoreiz pa asi Y, apgriezt elementus pretējā secībā, neko nemainot HTML dokumentā. Mēs redzam flex moduļa lielās iespējas. */

/* Vēl viens flex moduļa flex konteinera parametrs ir: align-content, kas izlīdzina flex elementus pa galveno asi, kas ir atkarīga no flex moduļa parametra: flex-direction, un pie nosacījumiem, ka: flex konteinerī ir brīva vieta un flex elementi ir vismaz divās rindās. Bet ir viena atšķirība: Flex elementi, ja notiek pārnese otrā rindā, tad tie pēc augstuma vairs nelīdzinās augstākajam elementam, bet gan vienkārši piespiežas viens pie otra. */

/* Pēc noklusējuma flex moduļa parametram: align-content: vērtība ir: stretch, kas nozīmē to, ka mūsu flex elementi */

/* Kad izmantojam flex moduļa parametru: align-items: flex-start;, flex konteinerī, ja mainās ekrāna platums un mēs izmantojam konteinerim fiksētu augstumu, tad flex elementi nostājās tā, ka tie veido starp vienu rindu un otru rindu, un arī aiz otrās rindas brīvu vietu flex konteinerī. Tie veido tukšus laukumus flex konteinerī. */

/* Mēs varam kontrolēt - iespaidot šos tukšos laukumus flex konteinerī ar flex moduļa parametru: align-content: flex-start;, mēs varam piespiest flex elementus pie flex konteinera sākuma. Ja mums mainās lapas platums, tad flex elementi pārlec jaunā rindā un mums neveidojas tukši laukumi. Un mums priekš tā vairs nevajag parametru: align-items: flex start;. */

/* Mūsu flex elementi pārlecot jaunā rindā centīsies pastiepties viens otram līdzi, tie līdzinās visaugstākajam elementam, pielāgojas. Atceramies galveno flex moduļa priekšrocību: flex konteineris ir kā gumija, kuru mēs varam pielāgot, pastiept, sašaurināt utt. */

/* Kad mums ir noklusējuma vērtība flex moduļa parametram: flex-direction un, kad mums flex konteineris ir augstāks nekā augstums, ko aizņem flex elementi, tad mums veidojas tukšas vietas. Šīs tukšās vietas mēs varam kontrolēt ar flex moduļa parametru: align-content: vērtībām: space-between un space-around. */

/* Bet šī parametra darbību mēs redzam tikai tad, kad mums ir flex elementi vairākās rindās. Ja tie mums ir vienā rindā, tad mēs neko neredzam, bet tiklīdz mēs sašaurinām ekrānu, mēs redzam kā darbojas šis flex moduļa parametrs. */

/* Būtiski: lai šīs flex moduļa parametrs strādātu, mums ir jābūt ieslēgtam parametram: flex-wrap: wrap;, jo savādāk mums nedarbosies flex elementu pārnese jaunā rindā. Izskatām flex moduļa parametru: align-content darbību ar piemēru: */

/*
.block {
	display: flex;
	height: 600px;
	flex-wrap: wrap;
	align-content: space-between;
} */

/* Atceramies: šo flex moduļa parametru: align-content mēs varam izmantot tikai tad, kad mums flex elementi ir vairāk nekā vienā rindā un mums ir brīva vieta flex konteinerī. */

/* Kā mēs varam noteikt atstarpes priekš flex elementiem. Mēs tās nosakām iekš flex konteinera izmantojot flex moduļa parametru: gap: kas nosaka cik liels attālums būs starp flex elementiem. Pēc noklusējuma parametrs: gap ir 0;. Izskatām to ar piemēru: */

/*
.block {
	display: flex;
	gap: 20px;
} */

/* Izpildot šo piemēru mēs redzam, ka starp mūsu flex elementiem ir 20px attālums. */

/* Šim flex elementu attāluma parametram ir vēl divi papildus - smalkāki parametri: row-gap un column-gap, kas tieši uzstāda elementu attālumu pa asi Y - row-gap - kas nosaka, cik liela atstarpe būs starp rindām, un pa asi X - column-gap, kas nosaka cik liela atstarpe būs starp flex elementiem. Izskatām tos atkal ar piemēru: */

/*
.block {
	display: flex;
	flex-wrap: wrap;
	row-gap: 20px;
	column-gap: 10px;
} */

/* Mēs redzam, ka tad, kad mums lapai mainās platums, samazinās flex konteinera izmērs, flex elementi sastājās vairākās rindās un starp tiem ir attālums, gan pa asi Y, gan pa asi X. Pa asi Y mums ir: 20px, bet pa asi X mums ir: 10px. */

/* Šos abus flex-elementu attāluma parametrus mēs varam pierakstīt arī ar vienu: gap: parametru, tā pirmo vērtību rakstot: row - pa asi Y, un otro vērtību rakstot: column - pa asi X. Izskatām to ar piemēru: */

/*
.block {
	display: flex;
	flex-wrap: wrap;
	gap: 20px 10px;
} */

/* Mēs redzam, ka attālums starp flex elementiem ir tieši tādas pašas kā tad, kad izmantojām iepriekšējos ( katru atsevišķi ) atstarpju parametrus: gap. */

/* Ar ko parametrs: gap ir unikāls? Ar to, ka tas nenosaka atstarpes visam elementam, bet gan tikai attālumu starp elementiem. Tas ir tāds kā atstarpju drošības parametrs. */

/* Vēlāk mēs mācīsimies citādākus flex elementu attāluma parametrus, kas nodrošinās, ka mūsu lapa ir stabilāka pret pārmaiņām, un, kas strādā visur, ne tikai uz flex elementiem, bet jau tagad mēs varam sākt izmantot gap. */

/* Atceramies: Nejaucam flex un grid moduļa elementu attāluma parametru: gap ar tām atstarpēm, ko mēs jau zinam. Vēlāk, kad mēs mācīsimies grid moduli, tur arī būs savs: gap. */

/* Kādēļ mēs flex elementiem nevaram noteikt mums jau zināmo atstarpju parametru: margin? To mēs izskatīsim nedaudz vēlāk. */

/* Šie bija flex moduļa parametri, lai strādātu tieši ar flex konteineru, un elementiem, kas ir iekš tā, bet tagad paskatīsimies kā mēs varam strādāt tieši ar flex elementiem. */

/* izslēdzam iepriekšējos aktīvos kodus, atstājam tikai flex moduļa ieslēgšanu: display: flex; */

/* Iekš HTML dokumenta pierakstām pirmajam flex elementam papildus klasi ar modifikatoru: _align. Atceramies BEM metodoloģiju. Vēršamies no CSS pie pirmā  flex elementa: */

/* 
.block__element_align {
	align-self: auto;
} */

/* Moduļa flex, flex elementa parametrs: align-self, kas nosaka konkrētam flex elementam izlīdzināšanu pa galveno asi, atkarībā no flex moduļa parametra: flex-direction. Atceramies, ka izmantojot: flex-direction mēs varam mainīt galveno asi. Pēc noklusējuma šī flex elementa parametra: align-self vērtība ir: auto, bet mēs to varam mainīt, piemēram uz: flex-start. Izskatām to ar piemēru: */

/* 
.block__element_align {
	align-self: flex-start;
} */

/* Mēs redzam, ka mūsu pirmā flex elementa izlīdzināšana ir mainīta uz: flex-start. Tas vairs nav vienāds ar visiem pārējiem flex elementiem un netiek līdzināts pēc augstākā flex elementa, tas kļūst pats par sevi. */

/* Šis flex elementa parametrs tiek izmantots diez gan bieži, kad mums ir nepieciešams, lai kāds no flex elementiem nebūtu vienāda augstuma. Tas vairs nav gumijas veida elements, kā sākumā, kad ieslēdzam flex moduli, visi flex elementi kļūst kā gumija. */

/* Tagad mēs redzam, ka pārējie flex elementi vairs nav pielīdzināmi pirmajam flex elementam, un, lai mēs dabūtu visus flex elementus vienādā laukumā, mums jau ir jāpielieto kādi citi parametri, lai tos izlīdzinātu. */

/* Izskatīsim kā mēs varam kontrolēt tieši flex elementu lielumu. Kā pirmais flex elementu kontrolēšanas parametrs ir: flex-basis, kas nosaka flex elementa izmēru pēc noklusējuma, līdz atlikušās platības sadalīšanai. Tā vērtības mēs varam noteikt pikseļos: px, procentos: %, utt. */

/*
.block__element_first {
  flex-wrap: wrap;
	flex-basis: 200px;
} */

/* Pēc noklusējuma šī flex elementa parametra: flex-basis vērtība ir: auto, kas nozīmē, ka flex elementa izmērs tiek noteikts pēc tā satura, kas ir iekš tā. */

/* Nejaucam šo parametru: flex-basis ar parametru: width, jo flex-basis nosaka flex elementa vēlamo izmēru, ja flex konteinerī ir vietas. Svarīgi: flex-basis nosaka flex elementa vēlamo platumu, ja flex konteinerī ir brīvas vietas. */

/* Izpildot šo piemēru ar pirmo flex elementu, mēs redzam, ka tā platums palielinās līdz 100px, jo mums ir brīva vieta flex konteinerī. */

/* Ja mēs izslēdzam flex moduļa parametru: flex-wrap, tad mēs redzam, ka mūsu pirmais flex elements mainoties ekrāna platumam, kad tam vairs nav vietas, tad tas saraujas. */

/* Tagad mēs saprotam, ka parametrs: flex-basis nav viens un tas pats ar parametru: width. Ja mēs mūsu pirmajam elementam noteiksim parametru: width mēs redzam, ka ar flex elementiem tas nestrādā tā kā mums gribētos. */

/* Parametrus: width un height mēs varam izmantot, lai kontrolētu flex elementus, nevis pa pamatasi, kas ir atkarīga no parametra: flex-direction, bet gan pa otru asi. Bet lai kontrolētu pamatasi mums jāizmanto parametrs: flex-basis. */

/* Nākošais parametrs ar kuru mēs varam kontrolēt flex elementus ir: flex-grow, kas nosaka flex elementa iespēju palielināties, pēc nepieciešamības aizpildot visu flex konteineri. Tam ir tikai divas vērtības: 0 - kas nozīmē, ka mēs aizliedzam tam palielināties un: 1 - ka mēs atļaujam tam palielināties. Izskatām to ar piemēru, izslēdzam iepriekš aktīvo kodu: */

/*
.block__element_first {
	flex-grow: 0;
} */

/* Rezultātā mēs redzam, ka mūsu pirmais flex elements ir palielinājies tā, lai tiktu aizpildīts vis flex konteineris, pārējie flex elementi ir palikuši nemainīgi. */

/* Vēl viens flex elementu parametrs: flex-shrink, kas nosaka vai flex elementa izmērs var samazināties, pēc nepieciešamības aizpildot visu flex konteineru. Tam arī ir tikai divas vērtības: 0 - kas nozīmē, ka tam ir aizliegts samazināties un: 1 - ka tam ir atļauts samazināties. Izskatām to ar piemēru: */

/*
.block__element_first {
	flex-shrink: 1;
	flex-basis: 200px;
} */

/* Šie abi flex elementu parametri strādā kopā ar flex elementu parametru: flex-basis. Lai labāk saprastu rezultātu, pievienojam šo parametru mūsu piemērā. */

/* Mēs redzam, ka samazinoties lapas platumam, kad flex pirmais elements vairs neietilpst flex konteinerī, tas samazinās. Par to atbild: flex-shrink parametrs. */

/* Pēc noklusējuma šiem abiem flex elementu parametriem ir šādas vērtības: flex-grow: 0;, kas aizliedz flex elementam palielināties un flex-shrink: 1, kas atļauj flex elementam samazināties. */

/* Flex elementa parametra: flex-basis: noklusējuma vērtība ir: auto. Kas nozīmē, ka tā izmērs ir automātiski attiecīgs tik cik ir tā saturs. */

/* Parametru: flex-grow: 1; mēs varam noteikt visiem flex elementiem. Rezultātā mēs redzēsim, ka otrais flex elements pēc lieluma paliek nemainīgs, bet visi pārējie flex elementi paliek lielāki, tā, lai aizpildītu visu flex konteineru. Otrs flex elements paliek nemainīgs, jo tam ir vairāk satura un visi četri flex elementi cenšas izvietoties pa flex konteineri proporcionāli. */

/* Bet ja izmantosim šo flex elementu parametru: flex-grow tikai vienam elementam, tad mēs redzam, ka visi pārējie flex elementi pēc to lieluma paliek nemainīgi, bet pirmais elements aizpilda visu flex konteinera platību, tā, lai flex konteinerī ietilptu visi četri flex elementi. */

/* Pat tad, ja izmantojam flex elementu parametru: flex-basis: 200px kopā ar parametru: flex-grow: 1;, tad mēs redzam, ka mūsu pirmais flex elements izstiepjas pa visu pieejamo brīvo vietu. */

/* Šī situācija mums atgādina par parametra: min-width izmantošanu, kad mēs nosakām kādam elementam minimālo lielumu, un tas var palielināties, bet nevar būt mazāks par noteikto: min-width. */

/* Bet šeit situācija tomēr ir citādāka, jo mēs varam noteikt, ka mūsu pirmais flex elements var gan palielināties, gan samazināties. Tas var automātiski kļūt mazāks par 200px, jo pēc noklusējuma mums ir flex parametrs: flex-shrink: 1;, kas atļauj pēc nepieciešamības flex elementam samazināties. */

/* Lai panāktu šo trīs flex elementu lieluma - platuma darbību tieši tā, kā, ja tiktu izmantots CSS parametrs: min-width: 200px, mums šie trīs parametri ir jānosaka sekojoši: */

/*
.block__element_first {
	flex-basis: 200px;
	flex-grow: 1;
	flex-shrink: 0;
} */

/* Mēs nosakām, ka elementa lielums ir 200px, ka pēc nepieciešamības tas var palielināties, ja ir brīva vieta, bet tas nedrīkst samazināties. Mēs iegūstam tieši to pašu kā tad, ja mēs izmantotu parametru: min-width: 200px. */

/* Ja mēs nosakām abus šos flex elementu lieluma parametrus uz: 0;, tad mēs iegūstam to pašu, ko tad, ja izmantotu stingri noteiktu lielumu: width: 200px. */

/* Svarīgi: Lietojot flex moduli, flex elementiem pa to galveno asi, kura konkrētā situācijā tiek izmantota nav ieteicams izmantot CSS parametrus: width un height, jo tie nedarbosies tā kā mēs domājam. Tādēļ mums tiek doti attiecīgi flex elementu lieluma parametri: flex-basis, flex-grow un flex-shrink. */

/* Bet mēs varam izmantot CSS parametrus: width un height flex elementiem pa otro asi, kas konkrētā gadījumā nav galvenā ass. */

/* Par cik šie trīs flex elementu lieluma noteikšanas parametri darbojas kopā, tie visi tiek izmantoti vienlaicīgi, mēs tos varam pierakstīt vienā flex elementa parametrā: flex: kā pirmo vērtību norādot: flex-grow, kā otro norādot: flex-shrink un kā trešo norādot: flex-basis. Šī parametra universālais īsais pieraksts ar noklusējuma vērtībām ir šāds: flex: 0 1 auto;. Izskatām to ar piemēru: */

/*
.block__element_first {
	flex: 0 1 200px;
} */

/* Mēs rezultātā redzam, ka mūsu pirmais flex elements nepalielinās, var samazināties, un ir fiksēta lieluma: 200px. */

/* Lai mūsu kods izskatītos labāk, un lai mums būtu mazāk koda rindas, ir ieteicams izmantot tieši šo saīsināto flex pierakstu. */

/* Lai labāk visu saprastu, kā šis darbojās: iekš HTML dokumenta noņemam ceturto flex elementu, izslēdzam šeit aktīvos kodus un pierakstām reālo piemēru: */

/* 
.block {
	display: flex;
	flex-wrap: wrap;
}

.block__element {
	flex: 1 1 33.333%;
} */

/* Mēs redzam, ka ar maksimāli īsu koda pierakstu mēs esam panākuši vēlamo rezultātu. */

/* Itkā sīkums, bet mūsu profesionalitāti nosaka tieši tas, ka protam izmantot universālus CSS parametrus un, ka mūsu kods ir pēc iespējas īsāks, jo tā mēs taupām atmiņu, kā arī mums un citiem ir vieglāk orientēties pierakstītajā kodā.  */

/* Būtiski: Ja iekš universālā flex parametra iekš flex-basis norādīsim vērtību procentos, tad mūsu elementa lielums tiks aprēķināts no kopējā flex konteinera lieluma. Piemēram, ja norādīsim: 33.333%, tad tas vienmēr aizņems vienu trešdaļu no flex konteinera. */

/* Protams mēs šo universālo flex parametru varam piemērot visiem flex elementiem. Situācijā, kad mums vajag iegūt trīs vienādas kolonnas, mēs visiem mūsu flex elementiem norādām sekojošo: flex: 0 0 33.333%. Rezultātā mēs iegūstam, ka visi mūsu flex elementi ir vienāda lieluma un aizpilda visu flex konteineru. */

/* Šādi mēs ar divām koda rindām varam panākt sev vēlamo rezultātu. Konteinerim flex norādot parametru: display: flex; un flex elementiem norādot universālo parametru: flex: 0 0 33.333%. Tā mēs ar maksimāli īsu kodu, parādot savu profesionalitāti panākam vēlamo rezultātu. */

/* Par cik mēs flex parametra: flex-basis vērtībā norādījām procentus atceramies, ka mēs varam izslēgt flex-grow un flex-shrink vērtības, rakstot: 0, jo mūsu flex elementu platums ir atkarīgs no flex konteinera platuma, kas ir atkarīgs no lapas platuma. */

/* Domājot par lapas adaptīvu, kad mainīsies lapas platums, mēs varam norādīt flex konteinerim parametru: flex-wrap: wrap un iekš flex elementiem norādīt parametru: flex: 1 1 33.333%. Mēs nosakām, ka mūsu flex elementi var gan palielināties, gan samazināties, tādejādi iegūstot labu efektu, ja samazinās flex konteinera platums. Mēs redzam, ka pirmie divi flex elementi ir pirmā rindā un trešais flex elements ir izstiepies pa visu tam pieejamo flex konteinera platumu. To mēs panākam pateicoties tam, ka esam norādījuši iekš: flex-grow: 1.  */

/* Šāda pieeja reizēm var būt ļoti noderīga, tādēļ mums tā labi jāsaprot, kurš parametrs, kura vērtība par ko atbild. Un kāds būs gala rezultāts. Bet atceramies pašu galveno: Mūsu lapai vienmēr pie jebkādām pārmaiņām ir jābūt stabilai, lai nekur nekas nejūk un nebrūk. */

/* Ja mums ir nepieciešams, lai pirmie divi flex elementi būtu vienā rindā, pa visu pieejamo flex konteinera platumu, un, lai trešais flex elements tiktu pārnest jaunā rindā, mums ir jāpieraksta sekojošs piemērs: Izslēdzam iepriekš aktīvo kodu un pierakstām: */

/*
.block {
	display: flex;
	flex-wrap: wrap;
}

.block__element {
	flex: 1 0 50%;
} */

/* Rezultātā mēs redzam, ka divi pirmie flex elementi ir pa visu flex konteinera platumu, un trešais flex elements ir otrā rindā, izstiepies pa visu flex konteinera platumu. */

/* Ja mēs vēlamies, lai mūsu flex elementi būtu vienāda platuma divās rindās un, lai trešais flex elements arī būtu tikai līdz pus flex konteinera platumam, tad mēs izslēdzam iespēju flex elementiem palielināties, pierakstot sekojoši: flex: 0 0 50%. Rezultātā mēs iegūstam, ka mūsu flex elementi ir itkā divās kolonnās. */

/* Atceramies, ka šī pieeja strādā tikai tad, kad mums darbojas flex parametrs: flex-wrap: wrap. Jo, ja mums nebūs noteikts šis parametrs, mēs redzēsim briesmīgu rezultātu. Redzēsim, ka trešais flex elements neietilpst flex konteinerā un izlien no visām robežām. */

/* Šādai pieejai ir gan savi plusi, gan savi mīnusi. Mīnuss ir: elementu pārlikšana jaunā rindā: tad, kad tie vairs neietilps flex konteinera platumā notiek neprognozējami. Izstrādājot lapu šāda pieeja ne vienmēr mums der, jo mums ir jānodrošina, ka tad, kad mainīsies lapas saturs, mums nekas nesalūzīs un nesabruks. Bet šinī pieejā vis ir diezgan neprognozējami. */

/* Izskatīsim jaunu flex elementu parametru, kas iznes flex moduli jaunā līmenī. Mēs sapratīsim cik jaudīgs ir flex modulis. Lai labāk saprastu piemērus, izslēdzam iepriekš aktīvo kodu un iekš HTML dokumenta pievienojam katram flex elementam papildus klasi ar modifikatoru, atceramies BEM metodoloģiju. */

/* Mēs iepazīstam jaunu flex elementu parametru: order, kas nosaka kādā kārtībā tiks attēlots katrs flex elements. Tas ļauj mainīt flex elementu kārtību šeit iekš kaskādes stiliem, iekš HTML dokumenta izveidojam ceturto flex elementu. Pierakstām elementu papildus klases ar modifikatoriem. */

/* Mēs jau zinam, ka izmantojot: flex-reverse, mēs varam apgriezt flex elementus pretēji, arī, kad izmantojam column-reverse. Izskatīsim kā darbojas flex elementu parametrs: order. Tā vērtībā rakstam skaitli, kādā kārtībā mēs vēlamies, lai tiktu attēloti flex elementi. */

/*
.block {
	display: flex;
	flex-wrap: wrap;
}

.block__element_first {
	order: 4;
}

.block__element_second {
	order: 3;
}

.block__element_third {
	order: 2;
}

.block__element_fourth {
	order: 1;
} */

/* Rezultātā mēs redzam, ka mūsu flex elementi ir izvadīti pretējā secībā, līdzīgi kā td, kad izmantojām reverse. Bet šeit pēc nepieciešamības mēs varam attēlot flex elementus jebkurā secībā, jauktā, pēc kārtas, pretējā secībā. */

/* Būtiski: ja izmantojam flex elementu parametru: order, mums ir svarīgi to norādīt katram flex elementam, jo citādi mums var sanākt negaidīts - nevēlams rezultāts. */

/* Izslēdzam visus iepriekš aktīvos kodus, jo tagad mums jānostiprina jauniegūtās zināšanas praktiski, ar piemēriem. */

/* Svarīgi: Mēs nevaram flex elementiem likt vienam otru iespaidot. Piemēram mēs nevaram mainot pirmo flex elementu domāt, ka arī trešais un ceturtais flex elements mainīsies. Tas tā nenotiks, tādēļ mēs nevaram piemēram: izmantot flex moduli, lai izstrādātu tabulu. */

/* Atšķirībā no grid moduļa flex elementi nav viens ar otru saistīti. Vēlāk mēs mācīsimies par moduli: grid. */

/* Flex elements var būt kā flex konteineris. Mš ar to varam strādāt tieši tā pat. Izskatām to ar piemēru: */

/*
.block {
	display: flex;
	flex-wrap: wrap;
}

.block__element {
	display: flex;
	justify-content: center;
	align-items: center;
} */

/* Rezultātā mēs redzam, ka mūsu flex elementu saturs ir centrā. Mēs redzam, ka jebkurš flex elements var būt flex konteineris. */

/* Mēs gribam mūsu trīs flex elementiem pēc lieluma izmantot procentus, bet pēc atstarpēm: gap: 20px. Mēs redzam, ka mums tas nesanāk. Noņemam HTML dokumentā ceturto flex elementu. Izskatām to ar piemēru: */

/*
.block__element {
	flex: 0 0 33.333%;
	gap: 20px;
} */

/* Bet ir viens veids kā mēs nedaudz mainot mūsu kodu varam panākt vēlamo rezultātu. Atgriežamies iekš HTML dokumenta, izveidojam iekš katra flex elementa papildus kastīti ar content un atgriežamies šeit, pierakstot: Izslēdzam iepriekšējo aktīvo kodu. */

.block {
	margin: 0 -10px;
	row-gap: 20px;
	flex-wrap: wrap;
}

.block__element {
	flex: 0 0 33.333%;
	padding: 0 10px;
}

.block__content {
	background-color: #77608d;
	padding: 20px;
	height: 100%;
}

/* Izskatīsim situācijas atrisinājumu, kur mēs gribam, lai starp mūsu flex elementiem būtu 20px atstarpe. Mēs nosakām mūsu flex elementiem: iekšējās atstarpes, tādejādi atdalot tos vienu no otra pa 10px, un mūsu blokam: flex konteineram pierakstām ārējās atstarpes, tādejādi sadalot mūsu flex konteineri trīs daļās. Noņemam visas apmales. Rezultātā mēs redzam, ka lai kāds būtu flex konteinera izmērs, platums, starp mūsu flex elementiem ir 20px atstarpe. */

/* Tagad, kad mēs esam atrisinājuši pirmo uzdevumu, mums ir jāatrisina otrs uzdevums. Kā panākt, lai visi mūsu flex elementi būtu vienāda augstuma? Mēs vienkārši iekš flex konteinera, flex elementu apvalkam: flex__content pievienojam CSS parametru: height: 100%. Un mēs esam atrisinājuši arī otru uzdevumu, visi mūsu flex elementi ir vienāda augstuma. */

/* Situācijā, kad mūsu flex elementi neietilpst flex konteinerā, tie pārlec jaunā rindā un starp tiem nav atstarpes. Šādā situācijā mums tieši noder flex moduļa atstarpju parametrs: row-gap, ko nosakām mūsu flex konteinerim. Neaizmirstam, ka mums ir jābūt ieslēgtam parametram: flex-wrap: wrap. Jo citādi mums nekas nestrādās. */

/* Izpildot pareizi visus pierakstus mēs redzam, ka mums vis darbojas pareizi, un mēs esam atrisinājuši visus uzdevumus. */


/* Šiem visiem uzdevumiem ir vēl otrs risinājums, kad mums paliek vis sākotnēji, bez papildus kastītes katram flex elementam iekš HTML dokumenta, šeit iekš CSS izmantot iekš block__element: calc() funkciju, kur mēs no 33.333% - 20px, un iegūstam, ka flex elementiem ir 20px atstarpes. */

/* Otrajai pieejai, kad mēs nosakām atstarpes no CSS faila, izmantojot dažādus parametrus lai to panāktu ir būtisks pluss: ja mums zūd kāds no flex elementiem, tad automātiski atlikušie flex elementi aizpilda flex konteineru. Bet, ja mēs izmantojam pieeju no HTML dokumenta ar kastīti apkārt katram flex elementam, tad, ja mums zūd kāds flex elements, tad tā vieta paliek, un tas ne vienmēr mums ir vajadzīgs. */

/* Ja tagad mums kaut kas nav līdz galam skaidrs, nesatraucamies, jo to visu mēs atstrādāsim - noslīpēsim kursa praktiskajā daļā. */

/* Pie tam, visa nākošā lekcija būs par flex moduli ar praktiskiem piemēriem. Mēs uzzināsim visus sīkumus, un apskatīsim katram uzdevumam labāko risinājumu. */
