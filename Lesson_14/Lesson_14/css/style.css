
/* Sākumā atceramies kā pieslēgt šriftus: */

@import url("https://fonts.googleapis.com/css?family=Poppins:regular,700&display=swap");


@font-face {
	font-family: "Gilroy";
	src:
		url("../fonts/Gilroy-Regular.woff2") format("woff2"),
		url("../fonts/Gilroy-Regular.woff") format("woff");
	font-weight: normal;
	font-style: normal;
	font-display: swap;
}

@font-face {
	font-family: "Gilroy";
	src:
		url("../fonts/Gilroy-Bold.woff2") format("woff2"),
		url("../fonts/Gilroy-Bold.woff") format("woff");
	font-weight: bold;
	font-style: normal;
	font-display: swap;
}

body {
	font-family: "Gilroy", sans-serif;
	font-size: 16px;
	font-weight: 400;
}

/* Šodien, šinī lekcijā mēs mācīsimies jaunu moduli: flex. Flex modulis ir domāts, lai veidotu konstrukcijas. */

/* Līdz šim mēs veidojām konstrukcijas ar tām zināšanas, kas mums jau ir. Bet tagad sākot ar šodienu, mēs tās atstājam aiz muguras, pagātnē, jo turpmāk mēs strādāsim ar jaunu instrumentu: flex moduli. Strādāsim ar iepriekšējiem maketiem uzdevumiem, izmantojot: flex. */

/* Vēlāk, kursa beigās mēs apgūsim moduli: grid, bet tagad mums ir labi jāsaprot modulis: flex, lai beigās labāk saprastu: grid. */

/* Pierakstām HTML dokumentā dažus elementus, lai mēs uzskatāmāk saprastu jauno tēmu. Izveidojam bloku ar trīs elementiem, pievienojam tiem CSS parametrus. */

.block {
	border: 10px solid #8b0000;
}

.block__element {
	border: 10px solid #008000;
	padding: 20px;
	font-size: 30px;
	color: #fff;
}

/* Izmantojot dažus CSS parametrus, mēs padarām mūsu bloku un tā trīs elementus redzamus. Mēs to darām, lai labāk saprastu lekcijas tēmu. */

/* Mums HTML dokumentā: .block ir flex kastīte, konteineris, bet katrs: block__item ir flex elements. Iekš katra flex elementa ir flex saturs. */

/* Mēs redzam, ka iekš mūsu kastītes flex ir pirmā līmeņa ielikti trīs flex elementi, kam katram ir savs saturs. */

/* Kas tad īsti ir modulis: flex? Flexbox ir vesels modulis, kas sevī satur parametrus, kuru vērtības, kas tiek piemērotas vecākam: flex blokam: block, flex kastītei, kā arī flex elementiem. Galvenā flex priekšrocība ir: tā, ka tam ir  īpaša pielāgojamība lapas izstrādē, kad mēs varam pielāgot augstumu, platumu, apkārtējo laukumu un tā elementu: block__element atrašanās kārtību, lai izmantojot labāko pieeju aizpildītu pieejamo flex kastītes: block laukumu. Mēs varam mainīt flex elementu: block__element atrašanās kārtību, secību, nemainot neko iekš HTML dokumenta. */

/* Sākumā flex modulis mums liekas sarežģīts, bet ar laiku, ar pieredzi, mēs sapratīsim kā tieši tas darbojas un kādēļ mums tas ir jāizmanto. Jo mūsdienās, lapu izstrāde nav iedomājama bez moduļa flex. */

/* Mums ir vienmēr jāatceras, kad mēs ieslēdzam flex moduli, jo pagaidām mums ir vienkāršas <div></div> kastītes iekš HTML dokumenta. Jo pagaidām mums ir vienkārši bloks ar trīs elementiem, kas arī ir bloka tipa elementi, kuru īpašības mēs jau zinam. */

/* Ja mēs gribam ieslēgt flex moduli, mums ir jāvēršas pie tā bloka, kuram mēs gribam to ieslēgt. Mēs vēršamies pie vecāka, kas mūsu gadījumā ir: block. Mēs vēršamies pie galvenā objekta, kuru iekšienē mēs gribam ko mainīt. Izskatām to ar piemēru: */

/* Flex block. */

.block {
	/* Flex moduļa ieslēgšana: */
	display: flex;
}

/* Flex elementi. */

.block__element {

}

/* Mēs vēršamies pie galvenā bloka, kura struktūru mēs vēlamies mainīt. Kad mēs gribam veidot kādu konstrukciju. Mēs no flex elementiem: block__element vēlamies uzbūvēt kādu konstrukciju. */

/* Atzīmējam piemērā, kurš ir flex bloks un, kur ir flex elementi. */

/* Vispirms mums būsu flex blokam ir jāieslēdz flex konstrukcija. Tā kā piemērā augstāk: */

/* Mums jau ir zināms CSS parametrs: display, kura vērtības ir: block, inline, inline-block un none. Tas nozīmē, ka mēs varam globāli mainīt elementu struktūru. Tagad mums nāk klāt jauna CSS parametra: display: vērtība: flex; */

/* Mēs redzam, ka tad, kad izmantojam CSS parametru: display: flex, mums visi flex elementi: block__element ir sastājušies vienā rindā. Sākotnēji tie bija viens zem otra, bet tagad tie ir iekš vecāka: block sastājušies vienā rindā. */

/* Kas tad tieši notika, brīdī, kad ieslēdzām flex moduli mūsu blokam. Notika divas lietas: 1) flex elementi sarindojās vienā rindā pa asi X. Mūsu elementi kļūst itkā par bloka-rindas tipa elementiem. 2) Flex moduļa elementi: block__element katrs aizņem tik platības - laukumu, cik ir tā saturs. */

/* Mēs redzam, ka mūsu flex elementi ir kļuvuši par itkā bloka rindas tipa elementiem, jo to platums ir atkarīgs no to satura un uz tiem darbojās daudzi CSS parametri, bet tā tas nav. */

/* Mēs redzam, ka atšķirībā no inline - rindas tipa elementiem, uz flex elementiem darbojās CSS parametri, kas nedarbojās uz rindas tipa elementiem, piemēram: padding. */

/* Jo ir viena būtiska atšķirība - tie no bloka rindas tipa elementiem atšķiras ar to darbību - uzvedību. Pirmā būtiska darbības atšķirība ir tā, ka mūsu flex elementi, samazinoties ekrāna platumam nepāriet jaunā rindā. Otrkārt pie flex izmantošanas tiek citādi izlīdzināti elementi. */

/* Agrāk, lai izlīdzinātu elementus mēs izmantojām CSS parametru: vertical-align, lai kaut kā izlīdzinātu bloka rindas tipa elementus. Bet šeit arī tas strādā citādāk. Šeit arī vis itkā notiek tā pat, kā ar bloka rindas tipa elementiem, bet, kad izmantojam flex moduli, tad elementi tiek izlīdzināti no lapas kreisās puses uz labo, pa asi X. */

/* Ievērojam sīkumu, ka kad izmantojam moduli flex, mums zūd arī elementu fantomu atstarpes. Atceramies sākuma lekcijas, kad mācījāmies par attēliem, mums bija veids kā noņemt šuvju atstarpes. Tagad, kad izmantojam flex moduli, mums tās vairs neveidojas. */

/* Būtiski, kas mums ir jāatceras ir tas, ka: nav svarīgi kāda tipa elementi ir iekš flex moduļa, tie var būt jeb kāda tipa elementi, arī rindas tipa elementi, Flex modulis strādā pilnīgi vienādi. Par to pārliecināties mēs varam iekš HTML dokumenta izveidojot no konteinera kastītes tegu: <span></span>. Un mēs redzam, ka, ja izslēdzam flex moduli, tam nedarbojas daudzi CSS parametri, bet, kad ieslēdzam moduli: flex, mēs redzam, ka tas strādā tieši tā pat, kad mums ir konteinera kastīte - atvilkne. */

/* Jo brīdī, kad mēs vecākam ieslēdzam: flex moduli, visi tā elementi, kas ir iekš tā kļūst it kā bloka rindas tipa elementi un uz visiem tiem darbojās daudzie CSS parametri, kuri mums līdz šim mums ar rindas tipa elementiem nedarbojas. */

/* Ievērojam, ka modulis flex, kas ir ieslēgts vecākām un tas darbojās uz pirmās pakāpes ieliktajiem elementiem, tas nedarbosies uz otrās vai trešās pakāpes ieliktajiem elementiem. */

/* Ja mēs gribam izmantot flex moduli, flex elementiem, tiem ir jābūt vienam kopīgam vecākam. Mūsu gadījumā: block. */

/* Neatkarīgi no tā, kāda tipa elements ir mūsu bloks, kuram mēs piemērojam moduli: flex, tas automātiski kļūst par bloka tipa elementu. Par to pārliecināmies arī, ja mēs mūsu bloku, kas ir kastīte pārveidojam par tegu: <span></span>. Tiklīdz mēs ieslēdzam moduli flex, attiecīgais elements kļūst par bloka tipa elementu. Bet elementi, kas ir iekš šī bloka, tie itkā kļūst par bloka rindas tipa elementiem. Atceramies: ka modulim: flex un bloka rindas tipa elementiem tomēr irr būtiskas atšķirības, kuras mēs jau izskatījām augstāk pierakstos. */

/* Elements, kuram būs ieslēgts modulis: flex kļūs par bloka tipa elementu un aizņems visu lapas platību, tā kā mūsu piemērā: block. Vēlāk mēs izskatīsim ar piemēriem, kā mēs flex modulim varam noteikt, ierobežot tā platību. Tas aizņems visu sava vecāka platību, atkarībā kur tas atrodas. */

/* Flex modulim ir vēl viena vērtība, kas bloku, kad tam nosakām: display: inline-flex pārveido par rindas tipa elementu, kas aizņem tik platības, cik ir tā saturā: flex elementi. */

/* Būtiski: ja izmantojam: display: inline-flex, tas itkā kļūst par rindas tipa elementu, ar visām tām īpašībām, kas ir rindas tipa elementiem. Bet par cik tas tomēr ir modulis: flex, uz tā elementiem turpina darboties daudzie CSS parametri, kas nedarbojās uz rindas tipa elementiem. */

/* Atceramies no teorijas, ka flex modulis ir domāts, lai labāk aizpildītu tā laukumu. Mūsu gadījumā flex modulis ir ieslēgts blokam, un, lai labāk aizpildītu esošo bloka laukumu, pielāgotu flex elementus, mēs apgūstam jaunus flex moduļa parametrus */

/* Būtiski, ka pielāgot flex bloka aizpildīšanās laukumu ar flex elementiem, mēs varam tikai tad, kad izmantojam CSS parametru: display: flex;. Mēs nevaram to izdarīt, ja izmantojam display: inline-flex. */

/* Un tas ir pašsaprotami, ka, ja mēs izmantojam inline-flex, mēs nevaram strādāt ar tā laukumu, jo laukums tiek aizpildīts, tik cik ir elementu saturs, tam nav nekāda papildus laukuma. */

/* Apgūstam jaunu moduļa flex CSS parametru: flex-wrap: nowrap;, kas atbild par to, vai flex elementi tiks pārnesti jaunā rindā, kad tie vairs neietilps iekš flex konteinera - bloka. Pēc noklusējuma tā vērtība ir: nowrap, kas nozīmē, ka mainoties flex konteinera - elementu vecāka platumam, flex elementi netiks pārnesti jaunā rindā. Tie ir cieši viens pie otra, bez jebkādām fantoma atstarpēm, tā itkā tie būtu sacementēti. */

/* Bet mēs šo flex moduļa parametru varam mainīt: no flex-wrap: nowrap uz: flex-wrap: wrap, kas nozīmē, ka tagad, ja mainīsies vecāka platums, tad flex elementi tiks pārnesti jaunā rindā. */

