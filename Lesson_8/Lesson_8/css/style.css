
/* Šinī lekcijā mēs izskatīsim jaunu tēmu: pseido elementi un pseido klases. */
/* Sākumā atceramies kā pieslēgt šriftus: */

@import url("https://fonts.googleapis.com/css?family=Poppins:regular,700&display=swap");


@font-face {
	font-family: "Gilroy";
	src:
		url("../fonts/Gilroy-Regular.woff2") format("woff2"),
		url("../fonts/Gilroy-Regular.woff") format("woff");
	font-weight: normal;
	font-style: normal;
	font-display: swap;
}

@font-face {
	font-family: "Gilroy";
	src:
		url("../fonts/Gilroy-Bold.woff2") format("woff2"),
		url("../fonts/Gilroy-Bold.woff") format("woff");
	font-weight: bold;
	font-style: normal;
	font-display: swap;
}

body {
	font-family: "Gilroy", sans-serif;
	font-size: 20px;
	font-weight: 400;
}

.block {

}

/* .link {
	color: #9acd32;
	font-size: 40px;
} */

/* Iesākumā, pirmajā lekcijas daļā uzzināsim, kas ir pseido klases. Mums HTML dokumentā ir katram tegam klase, bet CSS mums ir selektori. HTML klases nav tas pats, kas CSS dokumentā pseido klases. Pseido klases ir nosacīti kāda elementa stāvoklis. */

/* Sintakse ir šāda: .link:hover {} iekš iekavām varam rakstīt dažādus CSS parametrus. Un pie šī stāvokļa, kad uzvedam ar peli uz saites, tad tiek pielietoti noteikti CSS parametri. */

/* Pseido klases var sadalīt divās daļās. Viena daļa: noteikti elementa stāvokļi. Izskatīsim CSS selektora link:hover stāvokli ar piemēru. */

/* .link:hover {
	color: red;
	opacity: 0;
	visibility: hidden;
} */

/* :hover stāvokli mēs varam izmantot jebkuram CSS selektoram. */

/* Pseido klasei :hover, mēs varam izmantot visus CSS parametrus. */

/* Izskatīsim citu situāciju, kad mums ir bloks. Piemēram: */

.block {
	display: inline-block;
	padding: 30px;
	background: #909090;
	margin-bottom: 20px;
}

/* Mēs pievienojam saitei :hover stāvoklim divus CSS parametrus: opacity un visibility. Mēs redzam, ka mēs iegūstam ne gluži to ko mēs gribējām. Un lapu izstrādē tā skaitās kā kļūda. Ko mums darīt lietas labā? */

/* Bet, ja mēs sākotnēji CSS selektoram: .link {} pievienojam CSS parametrus: opacity un visibility, tad mums nestrādās :hover stāvoklis, jo mums jau sākotnēji ir noteikts, ka mēs nevaram mijiedarboties ar .link.  */

/* Bet kā mēs varam rīkoties, lai mums vis strādātu tā kā vēlējāmies. Mums ir nedaudz jāpārraksta CSS parametri. Mums ir jāvēršas pie CSS selektora: .block un jānorāda tam šādi CSS parametri izmantojot stāvokli: hover un jāpievieno CSS selektors: .link */

/* .block:hover .link {
	opacity: 1;
	visibility: visible;
} */

/* Mēs izmantojam CSS selektoru, kurš atrodas augstāk un vēršamies pie elementa, kas ir iekš tā, izmantojot stāvokli :hover, kad mēs uzvedam ar peli uz augstāka līmeņa selektora. */

/* Mēs ar šādu pieeju iegūstam vēlamo rezultātu. Mēs to varam izmantot, kad mums ir kāds neredzams objekts, mēs vēršoties pie tā vecāka, iekš kā ir šis neredzamais objekts, varam panākt, ka pie stāvokļa :hover {} izmantojot CSS parametrus: opacity un visibility tie kļūst redzami. */


/* .link {
	color: #9acd32;
	font-size: 40px;
	font-weight: 700;
  opacity: 0;
	visibility: hidden;
} */

/* Šo pieeju mēs varam izmantot jebkuram augstāka līmeņa tegam, kaut vai uz tega: body. Vienmēr atceramies, ka mums ir šāda iespēja. */

/* Lai mums netraucētu iepriekšējie aktīvie kodi, mēs tos aizkomentējam. */

/* CSS selektoram, HTML dokumentam a, kas ir saite ir vēl viens stāvoklis, kas tiek izmantots retāk, bet par to mums ir jāzin. tas ir stāvoklis :visited */

/* Kad mēs esam noklikšķinājuši uz saites, apmeklējuši to, tad tā mainās izmantojot stāvokli :visited. Mēs varam to iekrāsot citā krāsā, izmantojot CSS stilus utt. */

/* .link:visited {
	color:#fff;
} */

/* Izpildot šādu darbību ar pseido klasi, mēs nospiežot uz saites redzam, ka tā iekrāsojas baltā krāsā. Par to atbild tieši stāvoklis: visited. */

/* Atceramies, ka HTML dokumentā mēs saitei ar klasi: .link, atribūtā: href="" varam norādīt konkrētu vietni uz kuru mēs gribam pāriet, piemēram: https://www.google.lv */

/* Pagaidām mēs HTML dokumentā atribūtā: href="#" liekam restīti, kas nozīmē, ka mēs paliekam tur pat mūsu lapā. Atceramies, ka, kad lapa mums ir gara, mēs izmantojot atribūtu: id="" varam norādīt konkrētu mūsu lapas vietu, kur mēs gribam pāriet, un tad ar saites palīdzību mēs varam to realizēt. */

/* Šīs saites stāvoklis :visited ir ļoti labi redzams, kad izmantojam google. Mēs apmeklējam kādu vietni, un norāde uz to saiti tiek pārkrāsota citā krāsā. */

/* Kad realitātē mēs izstrādājam kādu lapu, tad pareizi ir izmantot šo pseido klasi :visited priekš saitēm. Neaizmirstam arī izmantot pseido klasi :hover. */

/* Atšķirība no pseido klases :hover, kuru mēs varam izmantot jeb kuram HTML dokumenta tegam, pseido klasi: visited mēs varam izmantot tikai saitēm. */

/* Būtiski ir tas, ka uz pseido klases :hover mēs varam izmantot visus CSS parametrus, bet uz pseido klases :visited mēs nevaram izmantot visus CSS parametrus, bet gan tikai noteiktus. CSS stilu izmantošanu uz pseido klases :visited tiek ierobežota ar interneta pārlūku drošības apsvērumu dēļ. */

/* Lielāko tiesu, kurus CSS stilus mēs varam izmantot pseido klasei :visited saistās ar background saimi, dažādus krāsu parametrus un ar border izmantošanu. Pārējos mēs nevaram izmantot. */

/* Vēl viena pseido klase, kas tiek izmantota saitēm ir :active, kas nozīmē to, ka kad mēs uz tās uzspiežam, neatlaižot peli, tā piemēram maina krāsu. Bet realitātē šī pseido klase tiek reti kad izmantota. Bet šī pseido klase :active tiek lietota biežāk nekā pseido klase :visited. */

/* .link:active {
	color: #000;
} */

/* Rezultātā mēs redzam, ka saite, kad nospiežam peles kreiso taustiņu un neatlaižam to, tad saite iekrāsojas melnā krāsā. */

/* Bet mēs šīs pseido klases izmantošanu praktiski neredzam, jo realitātē mēs uzklikšķinam uz saites, un uzreiz pārejam uz kādu vietu lapā jeb uz citu lapu, jo neviens realitātē netur nospiestu peles kreiso taustiņu. Mēs knapi redzam šo efektu. */

/* Pseido klasei :active ir viena laba priekšrocība, kad mēs saiti izveidojam kā pogu mūsu HTML dokumentā. izskatām to ar piemēru: */

/* .button {
	border-radius: 20px;
	position: relative;
	top: 0;
	padding: 15px 25px;
	background-color: #0000ff;
	color: #fff;
	margin: 10px;
	box-shadow: 0px 8px 0px 0px rgba(0,0,0,0.75);
} */

/* .button:hover {
	background-color: #5d5def;
} */

/* Praktizējamies taisot pogu, un izmantojam mums jau zināmās pseido klases. Izmantojot pseido klasi :hover mēs redzam, ka, kad uzvedam uz pogas, tad tā kļūst gaišāka. */

/* Izmantojam interesantu pieeju, izmantojot mūsu pogai pseido klasi :active. Aizkomentējam HTML dokumentā bloku, lai tas mums netraucētu redzēt kā darbojas pseido klases :hover un :active uz pogas. */

/* .button:active {
	top: 4px;
	box-shadow: 0px 4px 0px 0px rgba(0, 0, 0, 0.5);
 }  */

/* Pielietojot mums vēl dažus nezināmus CSS parametrus, mēs redzam, ka mūsu pogai nostrādā pseido klase :hover, tā maina krāsu uz gaišāku un mums nostrādā pseido klase :active, kad mēs klikšķinām uz pogu. Mēs iegūstam interesantu efektu. */

/* Kad mums ir poga, tad ir ieteicams izmantot šīs abas pseido klases, jo šāds efekts izskatās ļoti labi. Kā arī lapas lietotājam uzreiz ir saprotams, ka viņš ir noklikšķinājis uz pogas. */

/* Ejam tālāk, aizkomentējam CSS selektorus: .button un ieslēdzam HTML dokumentā mūsu bloku. Jo tā mums būs vienkāršāk strādāt tālāk. */

/* Tālāk mums ir diez gan specifiska pseido klase :focus, kas atbild par fokusu uz konkrētu elementu. Vis biežāk šī pseido klase tiek izmantota formām, input lodziņos, bet par formām mēs  mācīsimies nedaudz vēlāk. Bet mēs varam pseido klasi :focus izmantot arī mūsu saitei. */

/* Pseido klase :focus var tikt izmantota visiem elementiem ar kuriem mēs varam mijiedarboties, kas atrodas mūsu lapā. */

/* .link:focus {
	outline: 2px dotted #000;
} */

/* Pseido klases stāvoklis :focus, ja neesam tai neko norādījuši pēc noklusējuma darbojas ar visiem lapas elementiem, ar kuriem mēs varam mijiedarboties, veidojot ap tiem CSS parametru: outline: 1px solid #000. Bet mēs varam izmantojot CSS parametru outline to mainīt jeb noņemt, rakstot: outline: none. */

/* Mēs iegūstam iespēju stilizēt kādu elementu, kad tas atrodas fokusā. Atceramies, ka mēs varam pārvietoties pa mūsu lapu izmantojot tabulāciju, taustiņu Tab. Tādejādi mēs varam mijiedarboties ar lapas elementiem. Agrāk, kad nebija vēl datora peles, tad tieši tā pārvietojās pa lapu, izmantojot Tab. */

/* Vēl interesanta lieta, Ja mēs iekš CSS selektora izmantojam pseido klasi :focus un tajā norādām kādus mūsu stilus, tad mēs šo fokusa stāvokli varam novērot uzklikšķinot un turot peles kreiso taustiņu. Vienkārši uz to noklikšķinot mēs praktiski neredzam šo stāvokli. */

/* Elementiem ar kuriem mēs varam mijiedarboties ir vēlams norādīt CSS selektora pseido klasi :focus, bet tikai tad, ja mēs gribam tam norādīt kādu īpašu stilu, jo pēc noklusējuma visiem lapas elementiem, ar kuriem mēs varam mijiedarboties jau ir šī pseido klase ar CSS parametru: outline. */

/* Kad mēs mācīsimies par formu izstrādi mūsu lapā, tad mēs vēl atgriezīsimies pie CSS pseido klases :focus. Izmantojot pseido klasi :focus, mēs varam norādīt arī citus CSS parametrus, piemēram: color, background utt. */

/* Ļoti svarīga ir kārtība kādā mēs izmantojam pseido klases, jo, ja mēs pseido klasi :focus uzliksim augstāk pirms pseido klases :visited, tad mums tā nedarbosies. Tādēļ vienmēr, kad izmantojam šīs apgūtās pseido klases, pseido klase :focus mums jānorāda beigās. CSS selektora beigās. */

/* Ja mēs pseido klasi :focus norādām pirms pseido klases :visited, tad mēs neiegūstam vēlamo rezultātu, arī tad, ja izmantosim taustiņu: Tab, jo neievērojam kārtību, kas pseido klasēs ir ļoti svarīga. Mums pseido klase :focus ir jānorāda aiz pseido klases :visited, un tad mums vis darbosies. */

/* Pseido klases izmantošana :focus saitēm ir reti sastopama, jo interneta pārlūks jau to izmanto pēc noklusējuma. Tādēļ mums ļoti reti būs tādi gadījumi, kad vajadzēs stilizēt saiti ar pseido klasi :focus. */

/* Pareiza CSS pseido klašu izmantošana būtu šāda: vispirms :visited, pēc tam :hover, :focus, :active. Izlabojam arī mūsu piemērus, lai vienmēr zinātu kādā kārtībā ir jāizmanto šīs CSS pseido klases. Aizkomentējam iepriekšējo kodu un saliekam visu pareizajā kārtībā. */

.link {
	color: #9acd32;
	font-size: 40px;
	font-weight: 700;
} 

.link:visited {
	color:#fff;
} 

.link:hover {
	color: red;
}

.link:focus {
	outline: 3px dotted #0000ff;
}

.link:active {
	color: #000;
}

/* Lai labāk saprastu nākošo pseido klasi, mums ir nedaudz jāpieraksta HTML dokumentā, jāizveido kastīte ar tekstu un jāpielieto daži CSS parametri, Nākošā pseido klase, kas mums ir jāzin ir: target, kas tiešā tulkojumā nozīmē: mērķis, ceļš. */

.window {
	padding: 20px;
	background-color: #77608d;
	color: #fff;
	display: none;
}

/* Mēs gribam panākt, lai kastīte mūsu lapā nav redzama, bet kad noklikšķinām uz saites, tad, lai tā parādītos. Kā mēs to varam izdarīt? Mēs iekš iepriekšējā HTML dokumenta kastītes saites ieliekam href="#window", un izveidojam jaunu kastīti ar id="window" un klasi window. Izmantojam CSS parametru jaunajai kastītei ar tekstu: display:none. Pēc tam izmantojam CSS selektoru ar klasi . window, izmantojam pseido klasi :target {} iekavās norādot display: block. */

.window:target {
	display: block;
}

/* Izpildot visu pareizi mēs iegūstam vēlamo rezultātu. Sākumā mēs redzam tikai saiti, bet, kad noklikšķinām uz tās mums parādās mūsu otrā kastīte: window. Šādu pieeju var izmantot daudz kur, tā reizēm ir ļoti izdevīga un vajadzīga pieeja, bet tai ir viens mīnuss: Mēs redzam, ka mēs, kad izmantosim scroll, tas vienmēr atgriezīsies pie šī elementa. Tā pat, kad iepriekšējās lekcijās un mājas darbos taisījām navigāciju pa lapu. Un tas ne vienmēr mums ir izdevīgi. */

/* Un tieši šī mīnusa dēļ mēs centīsimies pseido klasi :target neizmantot. Bet mums ir par to jāzin, ka tāda iespēja ir, jo ļoti reti mums var gadīties tāda situācija, ka citādāk nevar. */

/* ievērojam, ka CSS pseido klases, elementa stāvoklis :target, nav tas pats, kas HTML dokumenta atribūts: target="_blank", jo tās ir divas dažādas lietas. HTML dokumenta saitei var izmantot atribūtu: target="_blank", lai ceļš, kas norādīts atribūtā: href="", lai tas atvērtos jaunā logā. */

/* Šie bija visi pseido klašu stāvokļi. Izslēdzam, aizkomentējam HTML aktīvo kodu, atstājam saiti, lai mums ir ērtāk strādāt. Izslēdzam arī austāk esošo CSS selektoru: .link, lai tas mums netraucētu apgūt jaunas pseido klases. */

/* Mēs sadalījām pseido klases divās daļās, tikai, lai labāk uztvertu jauno informāciju. Jo tās visas darbojās vienādi, un pa lielam tās visas ir pseido klases stāvokļi. */

/* Izveidojam HTML dokumentā sarakstu, izmantojot tegu pāri <ul> un <li> un izveidojam pirms saraksta, kastīti ar tekstu, izmantojot iekš kastītes paragrāfus. */

/* Sāksim strādāt ar pseido klašu stāvokļiem kodā. Ko īsti nozīmē šīs pseido klases, pseido klases pēc stāvokļa kodā? Tas nozīmē, ka mēs varam no CSS, nemainot neko HTML dokumentā vērsties objektiem izmantojot tā stāvokli, ievērojot to kārtību, kas mums ir HTML dokumentā */

.text {
	margin-bottom: 40px;
}

.text p {
	margin-bottom: 20px;
}

.list {

}

.list li {
	margin-bottom: 20px;
}

/* izskatām pirmo elementa stāvokli kodā :first-child, kas nozīmē, ka mēs vēršamies pie pirmā bloka elementa. Tas vēršas pie pirmā objekta, kas ir iekš vecāka (augstāka līmeņa) objekta. */

/* Izskatīsim šo pseido klasi ar mūsu CSS selektoriem ar piemēru. */

.text p:first-child {
	color: #ff0000;
}


/* Kad mums vajag panākt, lai vienmēr pirmais bloka elements, kas iekš tā atrodas būtu ar noteiktiem stiliem, mēs izmantojam pseido klases stāvokli :first-child. */

/* Izmantojot pseido klašu stāvoklis mūsu lapa iegūst izturību, jo atceramies, ka mūsu lapas saturs var mainīties, mūsu lapai ir jābūt praktiskai, uzticamai, izturīgai. */

/* ja mēs izmantojam pseido klašu stāvokļus kodā, mums nav nepieciešams katram HTML elementam rakstīt klasi: class="", jo mēs uz tiem iedarbojamies ar pseido klašu stāvokļiem kodā ar CSS. */

/* Ja mēs pirms pirmā paragrāfa HTML dokumentā ieliksim kādu citu tegu, piemēram: <span></span>, tad mūsu pseido klases stāvoklis :first-child vairs nedarbosies. */

/* Šādā situācijā mums jāizmanto uzlabotais pseido klases stāvoklis, jo tad mums vis darbosies kā piemērā ar CSS selektoru: p, arī tad, ja virs tā būs vēl kādi citi elementi HTML dokumentā. Šis pseido klases stāvoklis ir :first-of-type. Izskatīsim to mūsu piemērā. */

.text p:first-of-type {
	color: #ff0000;
}

/* Pielietojot šādu pseido klases stāvokli mēs iegūstam vēlamo rezultātu: mūsu pirmais paragrāfs ir sarkanā krāsā neskatoties uz to, ka virs tā HTML dokumentā ir cits tegs. */

/* Kādu pseido klases stāvokli mums labāk izmantot? Vis atkarīgs no uzdevuma - mērķa, ko tieši mēs vēlamies panākt. */

/* Ja mums ir situācija, kad gribam lietot CSS parametrus tieši pirmajam, iekš bloka esošam elementam, neatkarīgi no tā tipa, nosaukuma, tad mēs veicam sekojošu pierakstu: */

.text *:first-child {
	color: #ff0000;
}

/* Mēs jau zinām, ka CSS selektors: * nozīmē to, ka mēs vēršamies pie visiem tegiem, kas ir HTML dokumentā. */

/* Izpildot šādu pierakstu mēs iegūstam to, ka jeb kurš elements, kas ir pirmais iekš bloka (vecāka) ir sarkanā krāsā. */

/* :first-child pretējs pseido klases stāvoklis ir :last-child, kas darbojas uz pēdējo elementu, kas ir iekš bloka, iekš (vecāka). */

.text p:last-child {
	color: #9acd32;
}

/* Uz šo pseido klases stāvokli attiecās visi iepriekšminētie nosacījumi, kas pseido klases stāvoklim :first-child. */

/* Un vēl viens pseido klases stāvoklis, kas pēc darbības un nosacījumiem ir pretējs pseido klases stāvoklim :first-of-type ir :last-of-type. Uz to arī attiecās visi nosacījumi.  */

.text p:last-of-type {
	color:#0000ff;
}

.text *:last-child {
	color: #0000ff;
	margin-bottom: 0;
}

/* Tas pats attiecās uz pseido klases stāvokli, kad mēs vēršamies pie jeb kura tipa tega, kas ir pēdējais mūsu blokā (vecākā). */

/* :first-child un :last-child ir divi pseido klašu stāvokļi, kas ir kā spogulis viens otram. */

/* Lai noņemtu pēdējam bloka elementam mums nevajadzīgo atstarpi, mums ir jāizmanto pseido klases stāvoklis, kur izmantojam CSS selektoru: * aiz tā liekot : un rakstot :last-child {} iekavās noņemot atstarpes. Uzskatāmu rezultātu mēs varam redzēt, ja noņemam HTML dokumentā pēdējo elementu, kas ir iekš bloka - kastītes: <span></span>. Bet, ja mēs atliekam atpakaļ iekš HTML dokumenta tegu <span></span>, tad mēs redzam, ka ārējā atstarpe pēdējam paragrāfam nav pazudusi, un tas ir pareizi, jo tegs <p></p> vairs nav pēdējais bloka elements. */

/* Šis bija pirmais variants kā mēs varam noņemt pēdējam bloka elementam ārējo apakšējo atstarpi, ebt ir vēl citi varianti. Šinī lekcijā mēs izmantosim citu pseido klases stāvokli, kas ir labāks lai noņemtu pēdējam kastītes elementam atstarpi. */

/* Turpinam apgūt vēl dažādus pseido klašu stāvokļus. Un tas ir :nth-child(elementa kārtas numurs, kuram mēs gribam pielietot CSS parametrus) {}. Tas vēršas pie konkrēta elementa, kas ir mūsu HTML blokā - kastītē. Lai labāk saprastu kā tas darbojās izveidojam HTML dokumentā vēl vienu 4to paragrāfu un noņemam span, lai uzskatāmāk redzētu pseido klases stāvokļa :nth-child() darbību. */

.text p:nth-child(2) {
	color: #008000;
}

/* Šis pseido klases stāvoklis vienmēr piemērosies 2jam bloka - kastītes elementam. Ja mums pirms paragrāfa būs tags: <span></span>, tad attiecīgi mums iekrāsosies 1mais paragrāfs. Lai redzētu kā tas notiek, pierakstām mūsu blokam - kastītei kā pirmo elementu tag: <span></span>. */

/* Izpildot šādas darbības, mēs redzam, ka mūsu pirmais paragrāfs ir zaļā krāsā, jo tas tagad skaitās blokā - kastītē otrais elements. Turpinam strādāt ar CSS pseido klašu stāvokļiem. Izņemam no HTML dokumenta tag span. */

