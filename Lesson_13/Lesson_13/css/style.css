
/* Sākumā atceramies kā pieslēgt šriftus: */

@import url("https://fonts.googleapis.com/css?family=Poppins:regular,700&display=swap");


@font-face {
	font-family: "Gilroy";
	src:
		url("../fonts/Gilroy-Regular.woff2") format("woff2"),
		url("../fonts/Gilroy-Regular.woff") format("woff");
	font-weight: normal;
	font-style: normal;
	font-display: swap;
}

@font-face {
	font-family: "Gilroy";
	src:
		url("../fonts/Gilroy-Bold.woff2") format("woff2"),
		url("../fonts/Gilroy-Bold.woff") format("woff");
	font-weight: bold;
	font-style: normal;
	font-display: swap;
}

body {
	font-family: "Gilroy", sans-serif;
	font-size: 16px;
	font-weight: 400;
	background-color: #5c5c5c;
}

/* Šinī lekcijā mēs mācīsimies par animācijām. Veidosim plūstošas pārējas izmantojot CSS parametru transition un animation. */


/* Mēs mūsu 12 mājas darbu ar mašīnu atdzīvināsim, piešķirsim tai animāciju. */


/* Mēs strādāsim ar veselu CSS parametru saimi. Līdzīgi kā mēs to darījām ar CSS parametru saimi: background. */

/* Mācīsimies jauno tēmu par animācijām. Sāksim to ar vienkāršu piemēru, HTML dokumentā izveidojot parastu saiti: */

.link {
	color: #ffff00;
}

/* Kā pirmo mēs mācīsimies animāciju pāreju CSS parametru: transitions, kas tiek pielietots visiem elementiem, arī pseido elementiem. Tiek izmantots, lai atdzīvinātu mūsu lapu. Kas uzlabo mijiedarbību ar lapas lietotāju, parasti, lai nodrošinātu patīkamu animāciju, darbībām ar noteiktiem lapas elementiem. Piemēram: kad uzvedam uz saites ar peli, tā kustās - notiek animācija. Kā arī CSS parametrs: transition var tik izmantots lai veidotu vienkāršas animācijas. Faktiski CSS pārejas nodrošina citu parametru vērtību maiņu atsevišķām animācijām, iespējām. Visus šos animācijas efektus var panākt izmantojot CSS parametru saimi: transition vei arī izmantot atsevišķus CSS parametrus: transition. */

/* Ar CSS parametru: transition mēs varam mainīt CSS parametrus, vērtības kādā laika intervālā, noteiktā laika intervālā. Mēs to varam izdarīt ņemot vērā vēl dažādas iespējas, patīkamus papildinājumus. */

/* Izskatīsim piemēru ar mūsu saiti. Pielietosim mums jaunos CSS parametrus: */

/*
.link:hover {
	color: #ff0000;
} */

/* Izmantojot CSS parametru: transition mēs varam nodrošināt, ka saites krāsa mainās plūstoši. */

/* Kā pirmo animācijas veidu mēs arī mācīsimies: plūstošu pāreju. Pirmais CSS parametrs, ko mēs mācamies ir: transform-duration, kas nosaka laika intervālu kurā jānotiek pārejai. Mēs norādām cik ilgā laikā ir jānotiek pārējai no vienas vērtības uz otru, piemēram: saitei jāmainās krāsai. Notiek animācija. Šis CSS parametrs netiek mantots. */

/* CSS parametra: transform-duration: noklusētā vērtība ir: 0, tādēļ mēs redzam, ka saite mainās uz sarkanu krāsu zibenīgi, tai nav plūstoša pāreja. Pielietojam šo CSS parametru mūsu piemērā ar saiti. */

/*
.link {
	transition-duration: 0.5s;
} */

/* izpildot šo piemēru mēs iegūstam, ka mūsu saite maina krāsu plūstoši, pus sekundes laikā. Mēs izmantojam jaunu mērvienību: s - sekundes. Mēs varam arī izmantot mērvienību: ms - milisekundes. Bet ērtāk un pareizāk ir izmantot sekundes. Atceramies, ka mērvienības ir jānorāda caur punktu, nevis komatu, jo dators to nesapratīs un mums nekas nedarbosies. */

/* Šāds nebūtisks sīkums ar saites plūstošu pāreju mūsu lapai piešķir vērtību, kā arī lietotājam ir daudz patīkamāk lietot mūsu lapu. Izmantojot šādu pieeju mēs nodrošinām lietotājiem patīkamu mijiedarbību ar mūsu lapu, un tas ir arī galvenais mūsu kā izstrādātāju mērķis. Šeit galvenais ir nepārcensties. Visam jābūt ar mēru. */

/* Mums tiek iedoti jauni instrumenti kā mēs varam uzlabot lapu, uzlabot tās lietošanu, bet mums katru reizi izstrādājot lapu ir jāievēro, lai mēs uzlabotu lapas lietošanu, lai uzlabotos lietojamība. Mums jāsaprot intuitīvi kur un kā mēs varam izmantot jaunos CSS parametrus, lai nesabojātu lapas lietojamību. */

/* Kā piemēram, ja norādīsim mūsu saitei CSS parametru: transition-duration: 2.5s, mūsu saite lapā mainīs krāsu ļoti lēni, un tas sabojās lapas lietojamību.  */

/* Ar CSS parametriem priekš animācijām mums jābūt uzmanīgiem, jāpielieto tie pareizās vietās, ar loģiskām vērtībām. Jo izmantojot šo CSS parametru: transition mēs varam ievērojami uzlabot lapas izstrādi. Bet pielietojot to nepareizi mēs varam sabojāt lapas izstrādi, lapa var kļūt nelietojama. */

/* Ar pieredzi mēs sapratīsim kur un kā tieši izmantot jaunos CSS parametrus, mums nepietiek tikai ar zināšanām, mums ir jāizjūt skaistums, kur un kā tieši pielietojot šos CSS parametrus mēs varam padarīt lapu skaistu, ērtu lietošanā, stabilu - drošu. */

/* Mēs pārsvarā izmantosim mikro animācijas, kas ir: 0.2 vai 0.3 sekundes. Lai labāk saprastu kā tas darbojās, izveidojam HTML dokumentā otru saiti. Un šeit iekš CSS faila pielietojam: CSS parametru: transition-duration. Lai labāk saprastu kā tas darbojās, izslēdzam iepriekšējo aktīvo kodu ar CSS parametra: transition-duration piemēru: */

/*
.link_animation {
	transition-duration: 0.3s;
} */

/* Mēs izmantojam minimālu animāciju, tā saucamo - mikro animāciju. Ko tas mums dod? Lietotājs lietojot mūsu lapu pat nepamanīs, ka šeit esam izmantojuši mikro animāciju. Bet lietotājam būs nezin kādēļ patīkami atrasties mūsu lapā. */

/* Ja mums rodas situācija, kad nezinām cik laika intervālu: sekundes uzlikt kādam lapas elementam, lai nodrošinātu plūstošu pāreju, mums jāuzliek mikro animācija, piemēram: 0.3s, un mēs noteikti nekļūdīsimies. */

/* Vis ir atkarīgs arī no lapas tematikas. ja tā ir kāda biznesa lapa, tad visam ir jānotiek nedaudz ātrāk, bet ja tā ir kāda neitrāla, mierīgas tēmas lapa, piemēram: par tējas dzeršanu, meditēšanu, tad šeit mēs varam likt lēnāku animāciju, lielākas sekundes, piemēram: 0.3s un 0.4s. */

/* Svarīgi, ka mainot vairākus CSS parametrus, tie visi animēsies. Izskatām to ar piemēru, mainot font-size mūsu saitei. Izslēdzam iepriekšējo aktīvo kodu, lai labāk saprastu kā tas darbojās: */

.link:hover {
	color: #ff0000;
	font-size: 20px;
}

/*
.link_animation {
	transition-duration: 0.3s;
} */

/* Rezultātā mēs redzam, ka saitēm mainās ne tikai krāsā bet arī šrifta lielums. Ar šo piemēru mēs redzam, ka tiek animēti visi CSS parametri, kurus norādām iekš pseidoklases: hover. */

/* Mums ir iespēja iekš CSS parametra: transition-duration: norādīt divas vērtības vai vairāk, ja mums ir vairāki CSS parametri, kuriem vēlamies norādīt izpildes laiku sekundēs vai milisekundēs. Izslēdzam iepriekšējo aktīvo kodu. Izskatām to ar piemēru: */

/*
.link_animation {
	transition-duration: 0.3s, 1.2s;
} */

/* Rezultātā mēs redzam, ka saitei mainās krāsa pēc 0.3 sekundēm, bet šrifta lielums mainās pēc 1.5 sekundēm. */

/* Plūstoša animācija, plūstoša pāreja nedarbojas ar visiem CSS parametriem. Piemēram, ja mēs mainām elementa tipu, izmantojot CSS parametru: display: block uz display: none. Tam nedarbosies hover efekts, nedarbosies plūstoša pāreja, tas vienkārši kļūs neredzams. Tas pats arī attiecās uz CSS parametru: visibility: visible un visibility: hidden. */

/* Kādēļ tas tā notiek? Tādēļ, ka mainot šos parametrus zūd hover efekts. Tādēļ arī nedarbojas plūstošas animācijas, jo mēs mainām elementu tipu un redzamību. Atceramies, ka CSS parametrs: visibility parāda vai noslēpj elementu, un mums zūd iespēja mijiedarboties ar šiem elementiem. Un protams zūd arī pseido elementu izmantošana. */

/* Bet piemēram CSS parametrs: opacity lieliski animēsies. Izskatām to ar piemēru: */

/*
.link {
	opacity: 0;
}

.link:hover {
	opacity: 1;
} */

/* Mēs redzam, ka sākumā mūsu saites nav redzamas, bet kad uzvedam uz tām ar peli tās parādās. Viena acu mirklī, otra ar plūstošu pāreju: 0.3s. */

/* Lekcijas beigās mums būs špikeris, kur varēsim visu šinī lekcijā izskatīto redzēt un labāk saprast kā tieši šis vis darbojas. */

/* Šobrīd mums ir svarīgi saprast, ka netiek animēti tādi CSS parametri, kas kardināli maina objektu - elementu. Tiek animēti visi CSS parametri, kur ir pikseļu vērtības, krāsu vērtības utt. */

/* Nākošais CSS parametrs ko mums ir jāzin ir: transition-property: ar noklusējuma vērtību: all, kas satur vairākas vērtības, ar kurām tiek nodrošināta plūstoša pārēja - animācija kādam objektam. Šis CSS parametrs var saturēt vienu vērtību, kā arī vairākas, atdalot tās ar komatu. */

/* Svarīgi zināt, ka visi CSS parametri, kas nodrošina plūstošu pāreju - animāciju netiek mantoti, tie nav mantojami no saviem vecākiem. */

/* Mēs iekš CSS parametra: transition-property: kā vērtību varam ierakstīt piemēram: color. Izslēdzam CSS parametru: opacity. Izskatām to ar piemēru: */

/*
.link_animation {
	transition-property: color;
} */

/* Rezultātā mēs redzam, ka plūstoša pāreja - animācija notiek tikai saites krāsai, bet šrifta lielumam tā paliek ar noklusējuma vērtību: 0s, un tam nav plūstošas pārejas - animācijas. */

/* Izmantojot šādu pieeju mēs varam noteikt, kurš tieši CSS parametrs tiks animēti, vai viens, vai vairāki, vai visi. Mēs izmantojot komatu varam noteikt vairākus CSS parametrus, kuri tiks animēti. Izskatām to ar piemēru zemāk, izslēdzam iepriekšējo aktīvo kodu: */

/*
.link_animation {
	transition-property: color, font-size;
} */

/* Rezultātā mēs redzam, ka notiek plūstoša pāreja - animācija, gan krāsai, gan šrifta izmēram. */

/* CSS parametra: transition-property: noklusētā vērtība ir: all, kas nozīmē, ka animācija - plūstoša pāreja būs visiem CSS parametriem. */

/*
.link_animation {
	transition-property: all;
} */

/* Izskatām nākošo CSS parametra transition saimes parametru: transition-delay: kas nosaka pēc cik ilga laika notiks animācija - plūstoša pāreja. Tas nozīmē, ka animācija nesāksies uzreiz, bet gan pēc noteikta laika, pēc tā laika, ko būsim norādījuši sekundēs vai milisekundēs. */

/* Šī CSS parametra: transition-delay: noklusētā vērtība ir: 0. Izskatām to ar piemēru: */

/*
.link_animation {
	transition-delay: 1s;
} */

/* Rezultātā mēs redzam, ka mūsu saite maina krāsu un šrifta lielumu pēc 1 sekundes. */

/* CSS parametra: transition-delay: var norādīt vairākas vērtības, ja mums ir vairāki CSS parametri, kuriem vēlamies norādīt animācijas laiku. Izskatām to ar piemēru: */

/*
.link_animation {
	transition-delay: 0.4s;
} */

/* Mēs redzam, cik konkrēti varam norādīt dažādus CSS transition saimes parametrus, lai iegūtu mums vēlamo rezultātu. Vis kļūst aizvien interesantāk. */

/* Kā nākošo CSS parametru saimes: transition parametru mēs izskatām: transition-timing-function: kas nosaka mūsu animācijas - plūstošās pārejas stilu. Pēc noklusējuma tā vērtība ir: ease. */

/* Kas tad ir CSS parametrs: transition-timing-function? Tā ir funkcija jeb greiza līnija pa kuru notiek plūstoša pāreja - animācija. Izskatām to ar piemēru: */

/*
.link_animation {
	transition-timing-function: ease;
} */

/* Elementi netiks animēti - nenotiks plūstoša pāreja taisni pa līniju, netiks lineāri animēti, bet tie tiks animēti pa īpašu loku. Lai iegūtu lineāru pāreju - animāciju mums iekš CSS parametra: transition-timing-function vērtības jānorāda: linear. Tad mūsu elementi tiks animēti lineāri pa līniju. Mēs to iegūstam pierakstot šādi: */

/*
.link_animation {
	transition-timing-function: linear;
} */

/* Vizuāli šim piemēram mēs neredzam atšķirību, bet tā ir. Mūsu saite tiek animēta lineāri, pa līniju. */

/* CSS parametra: transition-timing-function: ease animē elementu itkā ar loku, kas sākas no lejas lēni, un tad itkā strauji ar loku, un beidzās arī nedaudz lēnāk. Dotajā piemērā augstāk, mēs īsti neredzam atšķirību starp ease un linear, bet tā tomēr ir. */

/* Mēs zinam, ka CSS parametra: transition-timing-function: noklusējuma vērtība ir: ease. Tam ir vēl citas vērtības. Bet pārsvarā visur tiek izmantota tieši: ease vērtība. Mums izstrādājot lapas ir svarīgi atcerēties tieši par ease vērtību, jo pārsvarā tiek izmantota tieši tā. Par pārējām mums nav tik svarīgi zināt. */

/* CSS parametrs: transition-timing-function: ease ir fundamentālas zināšanas, pārējās vērtības ir papildus zināšanas. Lekcijas beigās mums būs arī špikeris, ar visu, ko šodien apgūsim. */

/* Lai izstrādātu plūstošu pāreju - animāciju mums ar šīm zināšanām ir pietiekami, bet paskatīsimies uz sarežģītāku piemēru, kur efekts ir interesantāks, izslēdzam iepriekšējo aktīvo kodu, lai mēs labāk saprastu kā tas darbojās: */

/*
.link_animation {
	transition-timing-function: steps(2, start);
} */

/* Rezultātā mēs iegūstam interesantu efektu. Mūsu pāreja - animācija notiek pa soļiem, pirmais solis, otrais solis. Pirmā vērtība iekš steps(2) norāda to, ka animācija sadalās divos soļos ar tādu laika intervālu, kādu mēs esam norādījuši iekš CSS parametra: transition-duration: laiks tiek sadalīts uz pusēm. Ja piemēram: esam norādījuši: 0.4s vai 0.2s tad tas tiek sadalīts divās daļās. */

/* Otra vērtība: start nozīmē to, ka animācija sāksies no sākuma. Mēs nekavējoties sākam šos animācijas - plūstošās pārejas soļus. Bet, ja norādīsim vērtību: end, tad mūsu animācija - plūstošā pāreja notiks ar aizturi. */

/* Kur CSS parametrs: transition-timing-function: steps(2, start) izmantošana mums var būt noderīga? Tā var noderēt, lai izveidotu pulksteni vai kādu apļa grafiku, kas arī darbojās kā pulkstenis. Bet vai tas būs vajadzīgs lapu izstrādē, varbūt ļoti īpašos gadījumos. */

/* Kad mums vajag īpaši smalki uzstādīt CSS parametra: transition-timing-function: vērtības, kā zemāk piemērā, izslēdzam iepriekšējos aktīvos kodus, lai labāk redzētu kā tas darbojās: */

/*
.link_animation {
	transition-timing-function: cubic-bezier(0.68, -0.55, 0.265, 1.55);
} */

/* Mēs iegūstam ļoti konkrēti uzstādītu plūstošu pāreju - animāciju. Mēs redzam, ka mēs varam ļoti smalki, principā ieprogrammēt mūsu animāciju. */

/* Atceramies, ka visi šie instrumenti ir kā dažādi risinājumi kādam uzdevumam. Un mums nav tagad visur jāizmanto: cubic-bezier(), jo mums jāiemācās izmantot parastos CSS transition parametrus, kas pieder pie fundamentālām zināšanām. Mums vēl nav tik daudz pieredzes, lai adekvāti izmantotu CSS parametru: transition-timing-function: cubic-bezier(). */

/* Mums nav nepieciešams reizēs, kad mums tomēr vajag izmantot CSS parametru: transition-timing-function: cubic-bezier:() izdomāt vērtības, jo internetā ir daudz resursu, kur mēs varam izvēlēties gatavu rezultātu, tādu kādu mums vajag, un iegūt kodu, iekopēt iekš () iekavām un iegūt rezultātu. */

/* Kā redzam, mums nav nepieciešams visu šo iegaumēt, iksevišķi sarežģītos CSS parametrus: transition-timing-function: jo māksla nav tos izmantot, bet māksla ir pareizi tos izmantot. */

/* Šos visus CSS parametrus, ko mēs apguvām, mēs varam pierakstīt vienā universālā rindā izmantojot CSS parametru: transition: un uzskaitot visas vērtības. Izslēdzam iepriekšējos aktīvos kodus un izskatām to ar piemēru: */

/*
.link_animation {
	transition: font-size 1s ease 0.5s, color 5s ease-out 0s;
} */

/* Izmantojot saīsināto universālo CSS parametru: transition, mēs iegūstam, ka mūsu saite ātri maina šrifta lielumu, bet krāsa mainās lēni. Šādi mēs vienā rindā varam sarakstīt visu CSS parametra: transform izmantošanas saimi, lai iegūtu plūstošas pārejas - animācijas. */

/* Īsāks, konkrētam elementam izmantojams CSS parametra saimes: transition pieraksts ir šāds: */

/*
.link_animation {
	transition: all 0.3s ease 0s;
} */

/* Izmantojot vienkāršu, saīsinātu CSS parametru saimes: transition pierakstu mēs iegūstam vēlamo efektu. Mēs vienlaicīgi nosakām, ka vis tiks animēts, 0.3s laikā, ease stilā un ar 0s aizturi. */

/* Pats īsākais veids, ne'mot vērā CSS parametra saimes: transition noklusētās vērtības, mēs varam vēl saīsināti pierakstīt to un iegūt tieši to pašu rezultātu kā augstāk piemērā. Izslēdzam iepriekšējo aktīvo kodu un pierakstām: */

.link_animation {
	transition: 0.3s;
}

/* Rezultātā mēs redzam, ka rezultāts ir tieši tāds pats, kā ja izmantojam garāko pierakstu. Mēs varam ņemot vērā mērķi - uzdevumu pierakstīt garāko piemēru, ja zinām, ka mums būs kādas vērtības jāmaina. Bet, ja zinam, ka nē, tad vram izmantot saīsināto pierakstu. */

/* Mēs izmantojot saīsināto piemēru iegūstam to, ka visi CSS parametri,kas padodas animācijai tiek animēti - iegūst plūstošu pāreju, kā mūsu gadījumā: 0.3 sekunžu laikā. */

/* Mums pēc noklusējuma CSS parametrs: transition-timing-function ir ease, kas arī skaitās pati patīkamākā plūstošā pāreja - animācija. Ne velti tā pēc noklusējuma ir: ease. Un mums nav nepieciešams katru reizi to rakstīt. */

/* Izskatīsim apgūtos jaunos CSS parametru saimes: transition izmantošanu ar praktiskiem piemēriem: Izslēdzam iepriekšējos aktīvos kodus. Mēs izskatīsim transition izmantošanas piemērus, lai labāk saprastu kā un kur tos adekvāti pielietot. Atgriežamies HTML dokumentā un izmantojot saiti, izveidojam pogu. Izslēdzam iepriekšējo aktīvo kodu ar saitēm. */

/*
.button {
	display: inline-block;
	color: #fff;
	background-color: #008000;
	border-radius: 10px;
	padding: 10px 15px;
	box-shadow: 0px 5px 0px rgba(0, 0, 0, 0.3);
	transition: 0.3s;
}

.button:hover {
	box-shadow: 0px 1px 0px rgba(0, 0, 0, 0.3);
	transform:translate(0, 3px);
} */

/* Šinī piemērā mēs izveidojam pogu, pievienojam tai apakšējo ēnu, izmantojam pseido klasi: hover, nobīdām pa asi X pogu uz leju. Iegūstam efektu, ko vēlējāmies. Pievienojam pogai plūstošu pāreju - animāciju, kas mūsu gadījumā ir mikro animācija. Iegūstam, ka poga plūstoši kustas, kad uzvedam uz tās ar peli. */

/* Redzam, ka mēs šeit lietojam CSS parametru: transform: translate mūsu pogai pie hover efekta,  bet mēs to lietojam pareizi, jo, ja mēs noteiksim: transform: translate(0, 10px), tad mēs iegūsim nevēlamu efektu, pārspīlētu efektu, mūsu poga nobīdīsies par daudz uz leju. */

/* Tas pats attiecās uz CSS parametru: transition: ja noteiksim piemēram: 5s, tad arī iegūsim nevēlamu, neadekvātu efektu. Tādēļ, mēs uzreiz ar piemēriem redzam, kur un kā, ko tieši izmantot, lai tas būtu adekvāti. */

/* Mēs redzam, ka mūsu poga ir kļuvusi daudz patīkamāka, lietotājam ir daudz patīkamāk uz tās uzvest. */

/* Arī, ja mēs noteiksim pogai ar hover efektu CSS parametru: transform: translate(10px, 0), mēs iegūsim neadekvātu, lietotājam nepatīkamu efektu, poga slīdēs prom no lapas kreisās puses uz labo. */

/* Šādi paeksperimentējot ar CSS parametriem: transform un transition mēs varam secināt, kādas ir adekvātas vērtības un kādas ir neadekvātas vērtības, lietotājam nepatīkami efekti. */

/* Mums ir jānodrošina patīkama lapas lietojamība lietotājam. Ar šiem CSS parametriem, kad veidojam menu vai pogas, mums ir jānodrošina, ka lietotājam ir ērti un patīkami atrasties un pārvietoties pa mūsu lapu. */

/* Šo pašu efektu mēs varam panākt izmantojot CSS parametru saimi: position, bet tad būtu vairāk koda, un šinī gadījumā vispareizāk ir izmantot tieši CSS parametru: transform: translate(). */

/* Izskatīsim piemēru, izveidojot HTML dokumentā sarakstu: menu. Izslēdzam iepriekšējo aktīvo kodu HTML dokumentā ar pogu. Šeit arī izslēdzam aktīvo kodu ar pogas parametriem. */

/*
.menu {
	overflow: hidden;
}

.menu:hover .menu__list {
	transform: translate(0);
	transition-delay: 0s;
}

.menu:hover .menu__item {
	transform: translateX(0);
}

.menu__list {
	background-color: #008000;
	padding: 15px;
	transform: translateX(-100%);
	transition: 0.5s;
	transition-delay: 0.8s;
}

.menu__item {
	transform: translateX(-100%);
	transition-duration: 0.5s;
}

.menu__item:nth-child(1) {
	transition-delay: 0s;
}

.menu__item:nth-child(2) {
	transition-delay: 0.2s;
}

.menu__item:nth-child(3) {
	transition-delay: 0.4s;
}

.menu__item:nth-child(4) {
	transition-delay: 0.6s;
}

.menu__item:not(:last-child) {
	margin: 0px 0px 20px 0px;
}

.menu__link {	
	color: #fff;
} */

/* Mēs izstrādājot šādu menu mūsu lapā, pielietojot CSS parametrus: transform un transition, iegūstam, ka mūsu menu sākotnēji nav redzams, jo mēs to nobīdām pa asi X:(-100%), to nobīdām pa kreisi, izmantojam vecākam elementam: menu CSS parametru: overflow:hidden, lai neredzētu menu malas. */

/* Izmantojam pseido klasi: hover mūsu menu, vēršamies pie menu__list un izmantojot CSS parametru: transform: translate(0) iegūstam, ka tad, kad uzvedam uz menu ar peli, tas no lapas kreisās puses izmantojot animāciju, tas mums atkal parādās. */

/* Bet mēs varam iegūt vēl interesantāku efektu. Sarežģīsim nedaudz mūsu piemēru. */

/* Mēs vēršamies pie menu, pie hover efekta, katram saraksta elementam izmantojot nth-child, pievienojot CSS parametru: transition-delay: dodot tam katram elementam lielāku laika intervālu iegūstam to, ka mums katrs saraksta punkts parādās viens aiz otra. Iegūstam plūstošu pāreju - animāciju, katram mūsu punktam. */

/* Tagad mūsu saraksts ir kļuvis interaktīvs. Un to visu mēs panākam tikai ar HTML un CSS parametriem. Ar tām zināšanām, kas mums ir dotajā brīdī, mēs jau varam paveikt brīnumus. */

/* Tagad paskatīsimies kur tieši mums ir nepieciešams izmantot CSS parametru saimi: transition. Mums ir uzstādīts CSS parametrs: transition uz menu__list un menu__item. Kādēļ tā? Mēs neliekam to mirklī, kad uzvedam uz tā ar peli, izmantojot hover efektu, bet mēs liekam to pēc noklusējuma uz elementiem. */

/* Vis pareizākais ir norādīt CSS parametru uz parastiem elementiem, to parastajā stāvoklī, jo, ja mēs norādīsim CSS parametru: transition uz hover efekta, tad mums tas darbosies tikai, tad, kad uzvedīsim uz tā ar peli, bet, tam nebūs atpakaļ ceļa, tas neaizies atpakaļ, nepazudīs. Tādēļ mēs to izmantojam pēc noklusējuma tiem elementiem, kurus vēlamies animēt - izmantot plūstošu pāreju. */

/* Iesācēji bieži pieļauj šo kļūdu norādot CSS parametru: transition pie hover efekta, tādejādi nedodot iespēju tiem aiziet atpakaļ. Tagad to saprast mums ir grūti, bet, jo vairāk praktizēsimies, jo labāk sapratīsim, kur un kā pareizi izmantot šo CSS parametru. */

/* Pareizi visu norādot mēs iegūstam iespēju CSS parametru: transition noteikt, gan, kad tiks parādīts elements, cik ilgā laikā tas parādīsies - animēsies, gan arī, cik ilgā laikā tas pazudīs. Mēs uzlabojam mūsu piemēru ar menu vēl vairāk */

/* Mēs pievienojam CSS parametru: transition menu hover efektam vēršoties pie menu__list, kas nozīmē cik ilgā laikā mums sāksies, notiks animācija un pēc tam vēršamies pie noklusējuma menu__list nosakot cik ilgā laikā plūstošā pāreja - animācija beigsies. Šādi mēs varam sīki un smalki izstrādāt animācijas. */

/* Mēs varam noteikt animācijas - plūstošās pārejas aizturi, izmantojot CSS parametru: transition-delay. Mēs iekš menu__list ierakstām CSS parametru: transition-delay: 1s. Atceramies, ka mēs atstājam iepriekšējo transition: 0.5s. Bet šeit ir svarīgi norādīt pie hover efekta: transition-delay: 0s. */

/* Rezultātā mēs redzam, ka mūsu animācija - plūstošā pāreja notiek ar vienas sekundes aizturi. Tā parādās un pazūd ar vienas sekundes aizturi. */

/* Mums ir iespēja mūsu sarakstu punktiem uzlikt plūstošu pāreju - animāciju uz atpakaļu. Mūsu piemērā pierakstām CSS parametru: transition-delay vēršoties pie vienkāršā menu__item stāvokļa izmantojot: nth-child. Skatīt augstāk piemērā: */

/* Rezultātā mēs iegūstam, ka mūsu saraksta punkti plūstoši pāriet - notiek animācija uz pretējo pusi, tie pazūd. Vēršamies pie menu__list un uzliekam nedaudz mazāki transition-delay: 0.8s. */

/* Rezultātā mēs izmantojot HTML un CSS esam ieguvuši sarežģītu, bet patīkamu  efektu. Mēs redzam, ka izmantojot vienkāršus CSS parametrus, kurus mēs jau tagad zinam, mēs varam izstrādāt interesantas lietas. */

/* Tas arī ir galvenais programmētāju uzdevums, izdomāt ko vēl var izdarīt ar jau esošajām zināšanām. Jo pats galvenais izstrādātāju mērķis ir ne vis iegūtās zināšanas, bet prasme tās izmantot, lai radītu kaut ko jaunu. */

/* Mums ir vajadzīgas zināšanas un arī mākslinieka pieeja, lai tās pareizi un īstajā vietā prastu pielietot. Labi mākslinieki iziet no standarta rāmjiem un rada ko jaunu - unikālu. */

/* Pats galvenais mūsu mācību mērķis ir prasme domāt. Nav tik svarīgi cik CSS parametrus mēs zinām, jo svarīgāka ir prasme domāt, kas būs, ja es izdarīšu šādi vai citādi, kā es vienu uzdevumu varu paveikt vis labāk, kādu pieeju man izmantot. */

/* Šim piemēram menu, kam mēs realizējām animāciju - plūstošu pāreju, sākumā un beigās ir viens būtisks mīnus: ja mums iekš HTML parādīsies vēl viens saraksta punkts, tad tas nedarbosies kopā jau ar esošajiem punktiem. Mums vajadzēs to atkal šeit iekš CSS parametriem ierakstīt, izmantojot: nth-child(5) un noteikt tam lielāku transition-delay: 0.8s un to pievienot arī pie atpakaļ pazušanas animācijas. */

/* Mēs varam mūsu sarakstam noņemt hover efektu no menu__item:nth-child(), atstāt tikai to uz parastā menu__item: nth-child() stāvokļa. Mēs redzam, ka mums nekas nemainās, vis darbojas, jo hover efekts mums bija vajadzīgs tikai sākumā, lai labāk saprastu kā pareizi darbojās animācijas. */

/* Bet, ko darīt, ja mums HTML dokumentā parādās jauns punkts iekš mūsu menu. Kad strādāsim ar JavaScript, tad mēs uzzināsim kā pareizi šo situāciju atrisināt. Pagaidām, kamēr mēs nezinam JavaScript mums būtu katram jaunam punktam vēršoties caur jaunu :nth-child() jāpievieno CSS parametrs: transition-delay: katru reizi kā vērtību norādot lielāku laiku. */

/* Virzamies tālāk izskatot jaunus piemērus. Izslēdzam aktīvo kodu šeit CSS un HTML dokumentā. */

/* Mēs esam tikuši skaidrībā ar CSS parametru: transition. Esam sapratuši kā tas darbojās un kā mēs to varam izmantot. Pats galvenais ir saprast, ka CSS parametrs: transition pie konkrētas darbības kaut ko maina, iekustina. Kā mūsu gadījumā pie uzvešanas ar peli uz saraksta. */

/* -------------------------- */

/* Apgūstam jaunu CSS parametru: animation, kas ir vēl labāks par transition. Izveidojam HTML dokumentā bloku. Atdalīsim iepriekšējo kodu, jo sākam jaunu tēmu. */

/* Būtiskākā CSS parametra: animation īpašība ir tā, ka tam ir @keyframes. Animation priekšrocība ir tā, ka ja to izmantojam, mūsu lapu izstrāde kļūst dinamiskāka un atsaucīgāka, nekā pie transition izmantošanas. Tā dod mums iespēju atdzīvināt mūsu lapu, labākai mijiedarbībai ar lietotāju un pārsteidzošiem efektiem. */

/* Atšķirībā no plūstošas pārejas - animācijas, CSS parametram: animation ir @keyframes, kas ir uz noteiktu kadru bāzes, kas ļauj automātiski izveidot un atkārtot efektus tam noteiktajā laikā, ko esam norādījuši, kā arī noteiktā laikā - gadījumos apstādināt mūsu animāciju. */

/* Īsāk sakot izmantojot CSS parametru: animation un @keyframes mums dod iespēju izstrādāt daudz sarežģītākas animācijas. Tiešā nozīmē: @keyframes ir kadri. Iespējamie scenāriji. Izmantojot animāciju mēs nosakām laiku, kad tā tiks attēlota un izmantojot @keyframes mēs nosakām kuros brīžos notiks konkrētas lietas. */

/* @keyframes ir attīstītāka animāciju versija nekā transition. Var teikt tas ir transition maksimālisms. Izmantojot: @keyframes mēs noteiktos laikos, gadījumos varam mainīt CSS parametrus. */

/* CSS parametrs: animation nav tikai viens, tā ir vesela saime. Kā pirmo izskatīsim: animation-name, kas nosaka elementam animāciju sarakstu ( ieslēgtos kadrus ). Tos var norādīt vairākus, atdalot ar komatu. Vislielākā prioritāte būs pēdējam rakstītajam. */

/* Mums ir jāizveido saikne connect animation-name un @keyframes. Kā mēs to varam izdarīt. Mēs rakstām iekš animation-name: someName un rakstām @keyframes someName. Šādi mēs viņus abus sasaistām. Izskatām to mūsu block piemērā: */

/*
.block {
	width: 200px;
	height: 200px;
	background-color: #7a956b;
	animation-name: someName;
	animation-duration: 2s;
	animation-timing-function: ease;
	animation-delay: 1s;
	/* animation-iteration-count: 2; */
	/* animation-iteration-count: infinite;

}

@keyframes someName {
		0% {
			transform: translate(0px, 0px);
}
		100% {
			transform: translate(200px, 0px);
}
	} */

/* Mēs sasaistām šos abus CSS parametrus, un iekš @keyframes varam izmantot mums jau zināmus CSS parametrus: transform: translate(). Mēs liekam līniju, izmantojot procentus, sākot no 0% un beidzot ar 100%. Mums ir animācijas sākums un animācijas beigas. */

/* Iepriekš mums bija CSS parametrs: transition-duration, tagad mums ir līdzīgs CSS parametrs: animation-duration. To mēs nosakām mūsu blokam. Iekš @keyframes izmantojam CSS parametru: transform: translate(). */

/* Ievērojam stingru sintaksi, šeit ļoti svarīgi ir pareizi uzrakstīt, lai notiktu animācija. Mūsu piemērā mēs nosakām, ka mūsu zaļais kvadrāts animēsies 200px pa labi, no tā sākuma punkta. */

/* Nākošais parametrs no CSS animation saimes ir: animation-timing-function, kam pēc noklusējuma vērtība ir: ease. Tas nosaka animācijas scenāriju, kā notiks animācija noteiktajos kadros - @keyframes. Tā pat kā ar CSS parametru: transition-timing-function arī šeit mēs varam mainīt mo noklusējuma vērtības ease uz linear vērtību. Bet kā jau zinam, ease ir labāks risinājums. Bet reizēm var noderēt linear. */

/* Kā redzam, ka iepriekš apgūtais CSS parametrs: transition un jaunais animation ir ļoti līdzīgi. */

/* Nākošais CSS parametra animation saimes parametrs ir: animation-delay, kas nosaka ar cik lielu laika aizturi notiks mūsu animācija. Pierakstām to mūsu piemērā augstāk. */

/* Bet ir viens atšķirīgs CSS animation saimes parametrs, kas nav CSS parametru saimei transition. Un tas ir: animation-iteration-count: ar noklusējuma vērtību: 1. Tas nosaka cik reizes animācija atkārtosies, cik reizes tiks atkārtoti tās kadri. Pierakstām šo parametru augstāk mūsu piemērā: */

/* Rezultātā mēs redzam, ka mūsu zaļais kvadrāts tiek animēts divas reizes. Šī arī ir būtiskākā at šķirība starp transition un animation parametriem. */

/* CSS parametram: animation-iteration-count kā vērtības mēs varam norādīt arī neveselus skaitļus, piemēram: animation-iteration-count: 2.5. Rezultātā mēs redzam, ka pie trešās reizes mūsu zaļais kvadrāts tiek animēts tikai līdz pusei. */

/* Bet pats foršākais CSS parametra: animation-iteration-count: ir vērtība: infinity, kas nozīmē, ka animācija notiks visu laiku, bezgalīgas reizes. Pierakstām to mūsu piemērā, un mēs redzam, ka animācija notiek visu laiku, ka tā ir bezgalīga. */

/* Izskatām vēl vienu animācijas piemēru, iekš @key-frames izmantojam CSS parametru: transform: rotate(): */

/*
@keyframes someName {
		0% {
			transform: rotate(0deg);
}
		100% {
			transform: rotate(360deg);
}
	} */

/* Mēs redzam, ka zaļais kvadrāts bezgalīgi griežas pa apli pulksteņa rādītāja virzienā, tas apgriežas pa 360 grādiem. Animācija ir bezgalīga. */

/* Izskatām vienu interesantu iespēju, animāciju mūsu zaļajam kvadrātam> Pierakstām to ar piemēru, izslēdzam iepriekšējo aktīvo kodu. */

/*
.block {
	width: 200px;
	height: 200px;
	background-color: #7a956b;
	position: relative;
	animation-name: someName;
	animation-duration: 4s;
	animation-timing-function: linear;
	animation-delay: 1s;
	animation-iteration-count: infinite;
}

.block::before {
	content: "";
	position: absolute;
	width: 100%;
	height: 100%;
	top: 0;
	left: 0;
	background-color: #ffff00;
	transform: rotate(45deg);
}

@keyframes someName {
		0% {
			transform: rotate(0deg);
}
		100% {
			transform: rotate(360deg);
}
	} */

/* Rezultātā mēs iegūstam interesantu figūru, kas sastāv no diviem zaļajiem kvadrātiem. Otro kvadrātu mēs pagriežam par 45 grādiem, un abiem kvadrātiem izmantojam animāciju ar kadriem @keyframes un iegūstam īpatnēju figūru, kas griežas pulksteņa rādītāja virzienā. */

/* Lai uzskatāmāk redzētu, kurš kvadrāts uz kura ir virsū, izmantojam otrajam kvadrātam, ko esam izveidojuši ar pseido elementu::before, pieliekam tam citu krāsu. */

/* Izslēdzam pēdējo aktīvo kodu un pierakstām šeit iepriekšējo kodu, lai apgūtu vēl dažas CSS parametru saimes: animation izmantošanas iespējas. */

.block {
	width: 200px;
	height: 200px;
	background-color: #7a956b;
	animation-name: someName;
	animation-duration: 2s;
	animation-timing-function: linear;
	animation-delay: 1s;
	/* animation-iteration-count: 2; */
	animation-iteration-count: infinite;
	/* animation-direction: normal; */
	/* animation-direction: reverse; */
	animation-direction: alternate;

}

@keyframes someName {
		0% {
			transform: translate(0px, 0px);
}
		100% {
			transform: translate(200px, 0px);
}
	} 

/* CSS parametrs: animation-direction: nosaka animācijas virzienu un tipu tās kadriem. Pēc noklusējuma vērtība ir: normal, kas nozīmē, ka animācija notiks no sākuma līdz beigām. */

/* Izskatām šī CSS parametra: animation-direction iekš mūsu piemēra augstāk. Mēs varam kā vērtību norādīt: reverse, kas nozīmē, ka animācija notiks pretējā virzienā. izskatām to mūsu piemērā augstāk. Izmantojot vērtību: reverse mūsu animācija pagriežas uz pretējo pusi, arī kadri pagriežas uz kreiso pusi. */

/* Vēl viena interesanta CSS parametra: animation-direction vērtība ir: alternate, kas nosaka, ka animācijas kadri notiks no vienas puses uz otru. Izskatām to ar piemēru augstāk. */
